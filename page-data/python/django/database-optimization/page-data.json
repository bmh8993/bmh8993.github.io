{"componentChunkName":"component---src-templates-post-template-jsx","path":"/python/django/database-optimization/","result":{"data":{"site":{"siteMetadata":{"title":"Blog by 인간지능","subtitle":"깔끔한 프로그래밍","copyright":"© All rights reserved.","author":{"name":"인간지능","twitter":"#"},"disqusShortname":"bmh8993-github-io","url":"https://bmh8993.github.io/"}},"markdownRemark":{"id":"04d4c0b8-7cb0-5b9a-acd0-10fdae987b66","html":"<p>Django를 사용하다보면 DB 최적화를 자연스럽게 접하게 된다. 알고는 있지만 정리가 안된 내용을\n이번 블로깅을 통해 진행해보려한다.\n<br>\n얼마전부터 <code class=\"language-text\">django-debug-toolbar</code>를 사용하여 프로젝트의 쿼리를 최적화하기 시작했다.\n나름 고민하며 ORM을 작성했다고 생각했는데 여전히 중복되거나 최적화를 필요로하는 부분이 많았다.\n어찌보면 대략적으로, 그저 표면적으로만 알고있는 지식을 통해 최적화를 진행했다고 생각하여\n공식문서를 바탕으로 이런 글을 쓰게 되었다.</p>\n<h2>1. 기본적으로 제공하는 DB 최적화 기술을 사용해라</h2>\n<p>이 부분은 SQL 최적화 기본 원리를 알아야하는데 <a href=\"https://bmh8993.github.io/SQL/sql-%EC%B5%9C%EC%A0%81%ED%99%94%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EB%A6%AC/\">다음 포스트</a>를 참고하기를 바란다.\n즉, 기본적인 DB 최적화를 먼저 해야한다는 이야기이다.</p>\n<ul>\n<li>\n<p>1-1. 인덱싱</p>\n<blockquote>\n<p>인덱싱은 최우선적으로 고려되는 부분이다. Field의 옵션으로 <code class=\"language-text\">db_index=True</code>를 세팅하면된다.\n혹은 Meta class에 <code class=\"language-text\">indexes</code>를 추가한다. 두 옵션의 동작은 동일하다. 추가하게되면 검색속도를\n높일 수 있다.<br>\n<br>\n그렇다면 어떤 필드에 추가해야할까. <code class=\"language-text\">filter()</code>, <code class=\"language-text\">exclude()</code>, <code class=\"language-text\">order_by()</code>를 자주 쿼리하는 필드에\n추가하도록하자</p>\n</blockquote>\n</li>\n</ul>\n<br>\n<ul>\n<li>1-2. 적절한 필드타입 사용하기</li>\n</ul>\n<h2>2. QuerySets 이해하기</h2>\n<h4><em>쿼리셋을 이해하는 것은 좋은 퍼포먼스를 만들어낼 때 매우 중요하다.</em></h4>\n<p>QuerySet에 대한 내용은 <a href=\"https://kimdoky.github.io/django/2020/02/03/django-queryset-api/\">다음 포스트</a>를 참고하기를 바란다.</p>\n<h3>2-1. 쿼리셋 평가 이해하기</h3>\n<ul>\n<li>\n<p>쿼리셋은 매우 게으르다.</p>\n<ul>\n<li>코드로 queryset을 생성하는 작업은 DB에 아무런 작업을 하지 않는다. DB의 query는 실제로\nqueryset이 결과값이 평가되기 전까지 실행되지 않는다. 예를들어 filter를 아무리 많이\n하더라도 DB query는 일어나지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>쿼리셋 평가되는 시점</p>\n<ul>\n<li>반복, 슬라이싱, Pickling/Caching, repr(), len(), list(), bool()</li>\n</ul>\n</li>\n<li>\n<p>데이터를 메모리에 저장하는 방법</p>\n<ul>\n<li>\n<p>각 queryset에는 데이터베이스 접근을 최소화하기 위한 cache를 포함하고 있다.</p>\n<ol>\n<li>새로운 queryset을 만들면 cache는 비어있는 상태이다.</li>\n<li>데이터베이스 쿼리가 발생해서 쿼리셋이 평가되는데, Django는 query 결과를 queryset의 캐시에 저장한다. 그리고 요청사항에 따른 결과를 리턴한다.</li>\n</ol>\n</li>\n<li>해당 queryset을 재사용하면 캐시된 결과를 가져와서 사용한다.</li>\n</ul>\n</li>\n</ul>\n<h4><em>Cache 활성화</em></h4>\n<p>QuerySet에서 cache를 사용하려면 QuerySet을 변수에 저장하여 재사용하면 된다.</p>\n<ul>\n<li>다음과 같은 코드는 캐싱하지 않았으므로 재사용이 불가능한 queryset이다</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>e<span class=\"token punctuation\">.</span>headline <span class=\"token keyword\">for</span> e <span class=\"token keyword\">in</span> Entry<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>e<span class=\"token punctuation\">.</span>pub_date <span class=\"token keyword\">for</span> e <span class=\"token keyword\">in</span> Entry<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>아래 코드는 queryset이라는 변수에 QuerySet을 할당했다</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token operator\">>></span><span class=\"token operator\">></span> queryset <span class=\"token operator\">=</span> Entry<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">.</span>headline <span class=\"token keyword\">for</span> p <span class=\"token keyword\">in</span> queryset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># QuerySet이 평가됨</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">.</span>pub_date <span class=\"token keyword\">for</span> p <span class=\"token keyword\">in</span> queryset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 이미 평가가 되었으므로 캐시로 재사용한다.</span></code></pre></div>\n<h4><em>queryset이 평가되지 않을 때</em></h4>\n<p>쿼리셋은 항상 그 결과를 캐싱하지는 않는다. 다음 코드를 보면서 이해해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token operator\">>></span><span class=\"token operator\">></span> queryset <span class=\"token operator\">=</span> Entry<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>queryset<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># queryset이 평가되지 않았으므로 쿼리를 실행한다.</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>queryset<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># queryset이 평가되지 않았으므로 쿼리를 실행한다.</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token operator\">>></span><span class=\"token operator\">></span> queryset <span class=\"token operator\">=</span> Entry<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span>entry <span class=\"token keyword\">for</span> entry <span class=\"token keyword\">in</span> queryset<span class=\"token punctuation\">]</span> <span class=\"token comment\"># 리스트컴프리헨션을 사용해서 queryset이 평가되었다.</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>queryset<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 평가가 발생했기 때문에 캐시를 사용한다.</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>queryset<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 평가가 발생했기 때문에 캐시를 사용한다.</span></code></pre></div>\n<h3>2-2. 캐시된 속성 이해하기</h3>\n<p>전체 쿼리셋을 캐싱할 뿐만 아니라, ORM 객체의 속성 또한 캐싱이 가능하다. 일반적으로 호출할 수 없는 속성은 캐시된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token operator\">>></span><span class=\"token operator\">></span> entry <span class=\"token operator\">=</span> Entry<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token builtin\">id</span><span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> entry<span class=\"token punctuation\">.</span>blog   <span class=\"token comment\"># 이때 blog가 연결된 어떠한 instance라면 쿼리가 발생하고 그것을 캐싱, 그게 아니라 어떠한 속성이라면 속성 값을 캐싱</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> entry<span class=\"token punctuation\">.</span>blog   <span class=\"token comment\"># instance라면 쿼리가 발생하지 않고 캐싱된 값을 가져온다. 속성이여도 캐싱된 값을 가져온다.</span></code></pre></div>\n<ul>\n<li>호출 가능한 속성은 캐싱되지 않고 DB에 접근한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token operator\">>></span><span class=\"token operator\">></span> entry <span class=\"token operator\">=</span> Entry<span class=\"token punctuation\">.</span>objects<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token builtin\">id</span><span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> entry<span class=\"token punctuation\">.</span>authors<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\"># 캐싱되지 않아서 쿼리가 발생한다.</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> entry<span class=\"token punctuation\">.</span>authors<span class=\"token punctuation\">.</span><span class=\"token builtin\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\"># 캐싱되지 않아서 쿼리가 발생한다.</span></code></pre></div>\n<p>❌사용자가 정의한 속성은 주의를 해야한다. 캐싱이 필요하다면 <code class=\"language-text\">cached_property</code> 데코레이터를 사용해야한다.\n<a href=\"https://americanopeople.tistory.com/317\">다음 포스트</a>를 참고하자.</p>\n<h3>2-3. iterator()를 사용해라</h3>\n<p>많은 양의 객체를 가져오게 될 때 쿼리셋의 캐싱하는 행위로 인해 많은 양의 메모리가 사용될 수 있다. 이때 <code class=\"language-text\">iterator()</code>를 사용하자</p>\n<h2>3. 파이썬으로 가져와서 처리하기보다 DB에서 결과를 처리하도록 하라</h2>\n<ul>\n<li>F, aggregate를 사용하면 파이썬으로 가져오지 않고 DB에서 결과를 처리할 수 가 있는데 다음 포스트를 참고하자.</li>\n<li><a href=\"https://docs.djangoproject.com/en/3.0/topics/db/aggregation/#aggregation\">Django 공식문서</a></li>\n<li><a href=\"https://blog.myungseokang.dev/posts/django-f-class/\">Django에서 F() 객체 알아보기</a></li>\n</ul>\n<h2>4. 인덱스나 유니크한 값으로 조회해라</h2>\n<p>get()을 사용하여 단일 객체를 조회할 때 <code class=\"language-text\">unique</code> 또는 <code class=\"language-text\">db_index</code>열을 사용하는 데는\n두 가지 이유가 있다.</p>\n<ol>\n<li>데이터베이스 인덱스로 인해 여러 쿼리 속도가 빨라진다.</li>\n<li>두번째 조회는 단 하나의 객체가 반환될 것이라고 보장하지 않는다.</li>\n</ol>\n<h2>5. 필요한 정보들을 알고 있다면 한 번에 싹 가져와라</h2>\n<ul>\n<li><code class=\"language-text\">select_related</code>와 <code class=\"language-text\">prefetch_related</code>를 통해서 적은 쿼리를 동작시키는 것이 효율적이다. 필요한 데이터가 무엇인지\n알고 있으면서 여러번 데이터베이스를 hitting하는 것은 효율적이지 못하다.</li>\n<li>view 코드 혹은 다른 레이어에서 필요에 따라 prefetch_related_objects()를 사용해라.</li>\n<li><code class=\"language-text\">select_related</code>와 <code class=\"language-text\">prefetch_related</code>에 대한 자세한 내용은 다음 포스트를 참고하라.</li>\n</ul>\n<h2>6. 필요없는 항목은 검색하지 마라</h2>\n<h4>QuerySet.values() 및 values_list()를 사용하기</h4>\n<p>dict 또는 list 값을 원할 때, ORM 모델 객체가 필요하지 않은 경우에는 values()를 적절하게\n사용하라</p>\n<h4>QuerySet.<code class=\"language-text\">defer()</code> 및 <code class=\"language-text\">only()</code>를 사용하기</h4>\n<p>대부분 모든 데이터가 필요하지는 않을 것이다. 모든 컬럼이 로드되지 않도록 하려면 defer()와\nonly()를 사용하라<br>\n하지만 잘못 사용하면 별도의 쿼리로 데이터를 가져와야 하므로 더 나빠질 수도 있다.<br>\n<br>\n또한 지연된 필드(deferred fields)가 있는 모델을 생성할 때, Django 내부에서 발생하는\n약간의 오버 헤드가 있음에 유의하라. defer() 및 only() 메서드는 많은 텍스트 데이터를\n로드하지 않거나 Python으로 다시 변환하기 위해 많은 처리가 필요한 필드의 경우\n가장 유용하다. 항상 그렇듯이 먼저 프로파일링을 한 다음 최적화하라.</p>\n<h4>QuerySet.count()를 사용하라</h4>\n<p>len(queryset)을 사용하는 것보다 낫다.</p>\n<h4>QuerySet.exists()를 사용하라</h4>\n<p>적어도 하나가 있는지 확인하기 위해서는 if queryset을 사용하기보다 exists()를 사용하라</p>\n<h4>QuerySet.update()와 delete()를 사용하라</h4>\n<p>단일객체를 검색하고 일부를 변경하고 저장하지마라, bulk SQL UPDATE를 사용하라 또한 bulk delete\n를 사용해도 좋다.</p>\n<h4>foreign key values를 직접 사용하라</h4>\n<p><code class=\"language-text\">entry.blog.id</code> 보다 <code class=\"language-text\">entry.blog_id</code> 를 사용해라</p>\n<h4>상관 없다면 결과를 정렬하지 말 것</h4>\n<p>odering은 비용이 안드는 작업이 아니다. 데이터베이스가 반드시 수행해야하는 작업이다.<br>\n데이터베이스에 인덱스를 추가하면 정렬성능을 향상 시키는데 도움이 될 수 있다.</p>\n<h2>7. bulk를 사용하라</h2>\n<p><code class=\"language-text\">bulk_create()</code>를 사용하면 query를 줄일 수 있다. 이런 방법은 ManyToMany에서도 동일하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># bad</span>\nmy_band<span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>me<span class=\"token punctuation\">)</span>\nmy_band<span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>my_friend<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">my_band<span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>me<span class=\"token punctuation\">,</span> my_friend<span class=\"token punctuation\">)</span></code></pre></div>\n<hr>\n<p>ref <a href=\"https://kimdoky.github.io/django/2020/03/11/django-querysets-cashing-eval/\">django - QuerySets Evaluation and Caching</a></p>","fields":{"tagSlugs":["/tags/django/"],"slug":"/python/django/database-optimization/"},"frontmatter":{"title":"Django / 데이터베이스 접근 최적화에 대해서","tags":["django"],"date":"2020-07-04T13:08:28.000Z","description":"Django에서 DB 최적화에 대해서 알아봅시다.","path":"/python/django/database-optimization/","category":"Django"},"tableOfContents":"<ul>\n<li><a href=\"/python/django/database-optimization/#1-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8A%94-db-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B8%B0%EC%88%A0%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%9D%BC\">1. 기본적으로 제공하는 DB 최적화 기술을 사용해라</a></li>\n<li>\n<p><a href=\"/python/django/database-optimization/#2-querysets-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\">2. QuerySets 이해하기</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/python/django/database-optimization/#%EC%BF%BC%EB%A6%AC%EC%85%8B%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%80-%EC%A2%8B%EC%9D%80-%ED%8D%BC%ED%8F%AC%EB%A8%BC%EC%8A%A4%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%82%BC-%EB%95%8C-%EB%A7%A4%EC%9A%B0-%EC%A4%91%EC%9A%94%ED%95%98%EB%8B%A4\">쿼리셋을 이해하는 것은 좋은 퍼포먼스를 만들어낼 때 매우 중요하다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/python/django/database-optimization/#2-1-%EC%BF%BC%EB%A6%AC%EC%85%8B-%ED%8F%89%EA%B0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\">2-1. 쿼리셋 평가 이해하기</a></p>\n<ul>\n<li><a href=\"/python/django/database-optimization/#cache-%ED%99%9C%EC%84%B1%ED%99%94\">Cache 활성화</a></li>\n<li><a href=\"/python/django/database-optimization/#queryset%EC%9D%B4-%ED%8F%89%EA%B0%80%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84-%EB%95%8C\">queryset이 평가되지 않을 때</a></li>\n</ul>\n</li>\n<li><a href=\"/python/django/database-optimization/#2-2-%EC%BA%90%EC%8B%9C%EB%90%9C-%EC%86%8D%EC%84%B1-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\">2-2. 캐시된 속성 이해하기</a></li>\n<li><a href=\"/python/django/database-optimization/#2-3-iterator%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%9D%BC\">2-3. iterator()를 사용해라</a></li>\n</ul>\n</li>\n<li><a href=\"/python/django/database-optimization/#3-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EA%B0%80%EC%A0%B8%EC%99%80%EC%84%9C-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0%EB%B3%B4%EB%8B%A4-db%EC%97%90%EC%84%9C-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8F%84%EB%A1%9D-%ED%95%98%EB%9D%BC\">3. 파이썬으로 가져와서 처리하기보다 DB에서 결과를 처리하도록 하라</a></li>\n<li><a href=\"/python/django/database-optimization/#4-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%82%98-%EC%9C%A0%EB%8B%88%ED%81%AC%ED%95%9C-%EA%B0%92%EC%9C%BC%EB%A1%9C-%EC%A1%B0%ED%9A%8C%ED%95%B4%EB%9D%BC\">4. 인덱스나 유니크한 값으로 조회해라</a></li>\n<li><a href=\"/python/django/database-optimization/#5-%ED%95%84%EC%9A%94%ED%95%9C-%EC%A0%95%EB%B3%B4%EB%93%A4%EC%9D%84-%EC%95%8C%EA%B3%A0-%EC%9E%88%EB%8B%A4%EB%A9%B4-%ED%95%9C-%EB%B2%88%EC%97%90-%EC%8B%B9-%EA%B0%80%EC%A0%B8%EC%99%80%EB%9D%BC\">5. 필요한 정보들을 알고 있다면 한 번에 싹 가져와라</a></li>\n<li>\n<p><a href=\"/python/django/database-optimization/#6-%ED%95%84%EC%9A%94%EC%97%86%EB%8A%94-%ED%95%AD%EB%AA%A9%EC%9D%80-%EA%B2%80%EC%83%89%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC\">6. 필요없는 항목은 검색하지 마라</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/python/django/database-optimization/#querysetvalues-%EB%B0%8F-values_list%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">QuerySet.values() 및 values_list()를 사용하기</a></li>\n<li><a href=\"/python/django/database-optimization/#querysetcode-classlanguage-textdefercode-%EB%B0%8F-code-classlanguage-textonlycode%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">QuerySet.&#x3C;code class=\"language-text\">defer()&#x3C;/code> 및 &#x3C;code class=\"language-text\">only()&#x3C;/code>를 사용하기</a></li>\n<li><a href=\"/python/django/database-optimization/#querysetcount%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\">QuerySet.count()를 사용하라</a></li>\n<li><a href=\"/python/django/database-optimization/#querysetexists%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\">QuerySet.exists()를 사용하라</a></li>\n<li><a href=\"/python/django/database-optimization/#querysetupdate%EC%99%80-delete%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\">QuerySet.update()와 delete()를 사용하라</a></li>\n<li><a href=\"/python/django/database-optimization/#foreign-key-values%EB%A5%BC-%EC%A7%81%EC%A0%91-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\">foreign key values를 직접 사용하라</a></li>\n<li><a href=\"/python/django/database-optimization/#%EC%83%81%EA%B4%80-%EC%97%86%EB%8B%A4%EB%A9%B4-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EC%A0%95%EB%A0%AC%ED%95%98%EC%A7%80-%EB%A7%90-%EA%B2%83\">상관 없다면 결과를 정렬하지 말 것</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/python/django/database-optimization/#7-bulk%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\">7. bulk를 사용하라</a></li>\n</ul>","headings":[{"value":"1. 기본적으로 제공하는 DB 최적화 기술을 사용해라","depth":2},{"value":"2. QuerySets 이해하기","depth":2},{"value":"쿼리셋을 이해하는 것은 좋은 퍼포먼스를 만들어낼 때 매우 중요하다.","depth":4},{"value":"2-1. 쿼리셋 평가 이해하기","depth":3},{"value":"Cache 활성화","depth":4},{"value":"queryset이 평가되지 않을 때","depth":4},{"value":"2-2. 캐시된 속성 이해하기","depth":3},{"value":"2-3. iterator()를 사용해라","depth":3},{"value":"3. 파이썬으로 가져와서 처리하기보다 DB에서 결과를 처리하도록 하라","depth":2},{"value":"4. 인덱스나 유니크한 값으로 조회해라","depth":2},{"value":"5. 필요한 정보들을 알고 있다면 한 번에 싹 가져와라","depth":2},{"value":"6. 필요없는 항목은 검색하지 마라","depth":2},{"value":"QuerySet.values() 및 values_list()를 사용하기","depth":4},{"value":"QuerySet.<code class=\"language-text\">defer()</code> 및 <code class=\"language-text\">only()</code>를 사용하기","depth":4},{"value":"QuerySet.count()를 사용하라","depth":4},{"value":"QuerySet.exists()를 사용하라","depth":4},{"value":"QuerySet.update()와 delete()를 사용하라","depth":4},{"value":"foreign key values를 직접 사용하라","depth":4},{"value":"상관 없다면 결과를 정렬하지 말 것","depth":4},{"value":"7. bulk를 사용하라","depth":2}]}},"pageContext":{"slug":"/python/django/database-optimization/"}},"staticQueryHashes":[]}