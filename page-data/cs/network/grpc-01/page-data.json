{"componentChunkName":"component---src-templates-post-template-jsx","path":"/cs/network/grpc-01/","result":{"data":{"site":{"siteMetadata":{"title":"Blog by 인간지능","subtitle":"깔끔한 프로그래밍","copyright":"© All rights reserved.","author":{"name":"인간지능","twitter":"#"},"disqusShortname":"bmh8993-github-io","url":"https://bmh8993.github.io/"}},"markdownRemark":{"id":"61aabd05-c89c-52f9-a6c3-c657dbc3d52e","html":"<p>gRPC를 공부하려고 많은 글들을 찾아보다가 네이버 클라우드 플랫폼 블로그에서 좋은 글을 찾아 하나씩 써내려가면서 정독해보겠습니다.좋은 글 감사합니다.</p>\n<h1>gRPC의 등장배경</h1>\n<h2>1. 아키텍처의 변화</h2>\n<p><em><strong>Monolithic >>> Microservice</strong></em>\n1970년대 IBM에서 개인용컴퓨터를 생산한 이후 PC라는 개념이 생겼고 하나의 메인 프레임 워크에서 동작하는 <code class=\"language-text\">Monolithic구조</code>로 설계되었습니다.\n시간이 흐르고 기술이 발전하면서 우리가 익히 알고있는 <code class=\"language-text\">Server-Client</code>의 구조를 가지게 되었고, 하나의 메인 프레임워크에서 프로그램이 동작하는 Monolithic 구조에서는 크게 중요하지 않았던 네트워크의 개념이 정리되기 시작합니다.</p>\n<p>그렇게 서버 간 혹은 서버와 개인 PC간 네트워크 연결/통신이 중요해지면서 IOS 7 layer, TCP/IP 등 네트워크 계층 구조가 정의되고 발전하기 시작합니다.</p>\n<h2>2. RPC의 등장</h2>\n<h3>IPC와 Socket</h3>\n<p>실행되고 있는 컴퓨터 프로그램을 말하는 프로세스는 기본적으로 상호독립적입니다. 즉, 메모리를 공유하지않고 서로 간섭을 하지 않습니다. 하지만 필요에 따라 프로세스간 정보를 교환해야하는 경우가 있습니다. 이때 별도 수단을 이용하여 프로세스 간 통신하는 방법론을 IPC(Iner Process Communication)이라고 합니다.</p>\n<p>IPC기법에는 여러가지가 있지만 Socket에 대해서 살펴보겠습니다.\nSocket이란, 앞서 언급한 OSI 7 layer 구조의 L7계층(Application Layer)에서 L4계층(Transport Port)의 TCP 또는 UDP를 이용하기 위한 수단입니다. 일종의 창구라고 생각하면 됩니다. 우리는 온라인을 PC와 PC의 네트워크 통신이라고 알고 있지만, 조금 더 정확히 이야기하면 출발지 프로세스와 도착지 프로세스가 통신을 하는 IPC방법으로 통신한다고 이야기 하는게 정확합니다.</p>\n<p>Socket을 통해서 무언가를 개발 해 본 분들은 알겠지만 언어에서 지원해주는 API가 있어서 쉬운 것처럼 보이지만 client-server 통신과정을 직접구현해야하는 어려움을 가지고 있습니다. 통신 장애와 같은 많은 부분들이 개발자의 능력과 직결됩니다. 서비스가 고도화 될 수록 많은 데이터가 돌아다니게 될텐데, 이에 따라 data formatting을 하는 것도 점점 어려워지게 됩니다.</p>\n<h3>RPC</h3>\n<p>socket의 어려움을 극복하기 위해 RPC(Remote Procedure Call)라는 기술이 등장합니다. 이름 그대로 네트워크로 연결된 서버 상의 프로시저(함수, 메서드 등)를 원격으로 호출할 수 있는 기능입니다.\nRPC의 목적은 통신에 신경쓰지 않고, 원격지의 자원을 사용하는데에 있습니다.</p>\n<h4>RPC에서 사용되는 개념</h4>\n<ul>\n<li>IDL(Interface Definication Laguage)\n: 서로 다른 언어로 작성된 여러 서비스들 사이에서 공통된 인터페이스를 정의하기 위한 중간 인터페이스 정의 언어</li>\n<li>stub\n: 서버와 클라이언트는 서로 다른 주소 공간을 사용하므로, 함수 호출에 사용된 매개 변수를 꼭 변화해주어야 합니다. 그렇지 않으면 메모리 매개변수에 대한 포인터가 다른 데이터를 가리키게 됩니다. 이러한 변환을 담당하는게 stub입니다.</li>\n</ul>\n<blockquote>\n<p><code class=\"language-text\">client stub의 역할</code>\n함수 호출에 사용된 파라미터의 변환(Mashalling) 및 함수 실행 후 서버에서 전달 된 결과의 반환\n<code class=\"language-text\">server stub의 역할</code>\n클라이언트가 전달한 매개 변수의 역변환(Unmashalling) 및 함수 실행 결과 변환을 담당</p>\n</blockquote>\n<h4>RPC의 통신과정</h4>\n<ol>\n<li>IDL(Interface Definition Language)을 사용하여 호출 규약을 정의합니다.\n함수명, 인자, 반환값에 대한 데이터형이 정의된 IDL 파일을 rpcgen으로 컴파일하면 stub code가 자동으로 생성됩니다.</li>\n<li>Stub Code에 명시된 함수는 원시코드의 형태로, 상세 기능은 server에서 구현됩니다.\n만들어진 stub 코드는 클라이언트/서버에 함께 빌드합니다.</li>\n<li>client에서 stub 에 정의된 함수를 사용할 때,</li>\n<li>client stub은 RPC runtime을 통해 함수 호출하고</li>\n<li>server는 수신된 procedure 호출에 대한 처리 후 결과 값을 반환합니다.</li>\n<li>최종적으로 Client는 Server의 결과 값을 반환받고, 함수를 Local에 있는 것 처럼 사용할 수 있습니다.</li>\n</ol>\n<p>생각보다 통신과정이 복잡합니다. 많은 이점이 있지만 결국 구현이 어렵고, 지원 기능의 한계 등으로 제대로 활용되지 못했습니다. 그러다 Web을 활용해보려는 시도가 이어졌고 <code class=\"language-text\">REST</code>가 등장하게 됩니다</p>\n<h2>3. REST의 등장</h2>\n<p>REST(REpresentational State Transfer)는 HTTP/1.1을 기반으로 URI를 통해 모든 자원(Resource)을 명시하고 HTTP Method를 통해 처리하는 아키텍처입니다.\nHTTP Method와 payload의 합은 매우 명시적이고 쉽게 사용할 수 있다는 장점이 있어서 보편화된 방식입니다.\n하지만 REST에도 한계는 존재합니다.REST는 일종의 스타일이지 표준이 아니기 때문에 parameter와 응답 값이 명시적이지 않습니다. 또한 HTTP 메소드의 형태가 제한적이기 때문에 세부 기능 구현에는 제약이 있습니다.\n덧붙여 웹 데이터 전달 format으로 json을 많이 사용합니다. 간결한 <code class=\"language-text\">key-value</code> 구조를 기반으로 동작하고 사람이 읽기 좋은 string이기 때문입니다. 하지만 제공되는 자료형의 한계로 파싱 후 추가 형변환을 하는 작업이 필요한 경우가 많다는 점, string의 형태이기 때문에 데이터 통신/처리를 위한 serialize과정이 빠질 수 없다는 단점이 있습니다.</p>\n<h1>gRPC</h1>\n<p>gRPC는 google사에서 개발한 오픈소스 RPC(Remote Procedure Call) 프레임워크입니다. 이전까지는 RPC 기능은 지원하지 않고, 메세지(JSON 등)을 Serialize할 수 있는 프레임워크인 PB(Protocol Buffer)만을 제공해왔는데, PB기반 Serializer에 HTTP/2를 결합하여 PRC 프레임워크를 탄생시켰습니다.</p>\n<p><strong>(HTTP/2와 PB에 대한 설명은 다른 포스트에서 설명하도록 하겠습니다)</strong></p>\n<p>여기까지가 gRPC가 탄생하게된 배경과 gRPC에 대한 소개입니다.\n다음 포스트에서는 gRPC에 대해 더 자세히 이야기하도록 하겠습니다.</p>\n<hr>\n<p>참고: <a href=\"https://blog.naver.com/n_cloudplatform/221751268831\">https://blog.naver.com/n_cloudplatform/221751268831</a></p>","fields":{"tagSlugs":["/tags/g-rpc/"],"slug":"/cs/network/grpc-01/"},"frontmatter":{"title":"gRPC/gRPC가 등장하기까지(REST & RPC)","tags":["gRPC"],"date":"2020-11-16T13:04:35.000Z","description":"gRPC의 등장배경을 알아봅시다.","path":"/cs/network/grpc-01/","category":"network"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"/cs/network/grpc-01/#grpc%EC%9D%98-%EB%93%B1%EC%9E%A5%EB%B0%B0%EA%B2%BD\">gRPC의 등장배경</a></p>\n<ul>\n<li><a href=\"/cs/network/grpc-01/#1-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EB%B3%80%ED%99%94\">1. 아키텍처의 변화</a></li>\n<li>\n<p><a href=\"/cs/network/grpc-01/#2-rpc%EC%9D%98-%EB%93%B1%EC%9E%A5\">2. RPC의 등장</a></p>\n<ul>\n<li><a href=\"/cs/network/grpc-01/#ipc%EC%99%80-socket\">IPC와 Socket</a></li>\n<li>\n<p><a href=\"/cs/network/grpc-01/#rpc\">RPC</a></p>\n<ul>\n<li><a href=\"/cs/network/grpc-01/#rpc%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-%EA%B0%9C%EB%85%90\">RPC에서 사용되는 개념</a></li>\n<li><a href=\"/cs/network/grpc-01/#rpc%EC%9D%98-%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95\">RPC의 통신과정</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/cs/network/grpc-01/#3-rest%EC%9D%98-%EB%93%B1%EC%9E%A5\">3. REST의 등장</a></li>\n</ul>\n</li>\n<li><a href=\"/cs/network/grpc-01/#grpc\">gRPC</a></li>\n</ul>","headings":[{"value":"gRPC의 등장배경","depth":1},{"value":"1. 아키텍처의 변화","depth":2},{"value":"2. RPC의 등장","depth":2},{"value":"IPC와 Socket","depth":3},{"value":"RPC","depth":3},{"value":"RPC에서 사용되는 개념","depth":4},{"value":"RPC의 통신과정","depth":4},{"value":"3. REST의 등장","depth":2},{"value":"gRPC","depth":1}]}},"pageContext":{"slug":"/cs/network/grpc-01/"}},"staticQueryHashes":[]}