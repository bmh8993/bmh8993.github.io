{"componentChunkName":"component---src-templates-post-template-jsx","path":"/cs/data-structure/trie","result":{"data":{"site":{"siteMetadata":{"title":"Blog by 인간지능","subtitle":"깔끔한 프로그래밍","copyright":"© All rights reserved.","author":{"name":"인간지능","twitter":"#"},"disqusShortname":"bmh8993-github-io","url":"https://bmh8993.github.io/"}},"markdownRemark":{"id":"af5c1165-5135-52bd-8ff2-0998a4be2d73","html":"<h1>Trie 구조 (문자열 검색)</h1>\n<p>Tags: tree, trie, 문자열</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/372cbeefae10ffcbb5505abd588e1f3e/0da74/Untitled.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 960px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 100.41666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADcklEQVQ4y4WUWWzVRRTGz/nfUiNuQdBgiLtGRUOUSAxqJZIW8QHBCCqRujwgwcQlRhLceGExxhATW2NiwCUpS4K097YFalupVVkUsVRNjCY0McamohUj2tTbe+fnnJl72z/F5WEyZ87M+eY75zszoi0OsdEKZus4W80uj/F76XXpjJhDUodlV8pOg40/N249euakm7J/oU3DSHMBbS5Gf27Ez8XgM1vMb/u5fJilzK40y2jQXu98cD266Gn0Y7+xp8TgAz/v9nOnH93etnPbjyPXVqGv9SDmN+A0w8DIB+pjb6C169A1zWj9l2jjEPrkZnTrL+gLTcgdy9G6I+iqrb5Wgi5ZjfrLJFXvCJj19D/yizlLkWtuQaZehtSuRd/5IQYueBzJTECum4PMfxRduib6b18WSiOnpFwGvO1+5OrZyKUzkBV16I4TyGkT0ZX1yFU3xTRfzKENP0X/hq5QqlDbk1K2Alt9qu4NQclF00lqHkGeb4pMnmlAzbYLbb1hL1JRGcE7iIRaY+oSDFN3v5/n1pLcUI0srw+ByZRp6AWXk3iGdolOuRC5+R6SzX3oFTORlz4MAmobUf3IsBhV3DZIcvZk5MaFLPkOFu78Gnm7H9nyc+y5LYPIK/tJTITtvyHzfC03HfViZQP70A2mdijq+wRVk+qHkde/oecP6P4dMv7myb4tzm93XNwFZ3bFxj/3vUHOW/wEUteLXDkLmX5rBMwVSin73DPWd9459xAMF4oMDBVY+22B/qEiB391tA4UyPb7gMY8PSPwbN1byF2ryJxxDnL6Weirh5B2e3qpTk+avVrZIgc8wI5+x32HHeCoPuC481PHnyOOh45APp9nxiXTkOdyvuY1yPU1ofFjymW5PeAEn47sdHQcc2z63rHgM8exYUdFqzW/4/DxAgV/RdtXfUhSSbLxIDL77iCU7otqy9jj94EG2OgCw20/OhZ/7sgXXaihNMLKXoODZW19oQsqXu4O7GTmPPSTfwBMjGnOMd+nV7XPC9HpeOALx8TdEXBFrwsMJ2V9wz/1LknDALquA13fibbH1kmlHNMOoFkDtgPRjr3qeNOXYeNRF/Yy9klYu7XHIS3lPkwxHFU8sHWxDFa/lrhfuav0GZuQ9txKH0v4XNIv5b9GGSxmMHZ52X/K+f8DHANzJYB/B7PxNx4y97TvvRJNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Trie/Untitled.png\"\n        title=\"\"\n        src=\"/static/372cbeefae10ffcbb5505abd588e1f3e/d9199/Untitled.png\"\n        srcset=\"/static/372cbeefae10ffcbb5505abd588e1f3e/8ff5a/Untitled.png 240w,\n/static/372cbeefae10ffcbb5505abd588e1f3e/e85cb/Untitled.png 480w,\n/static/372cbeefae10ffcbb5505abd588e1f3e/d9199/Untitled.png 960w,\n/static/372cbeefae10ffcbb5505abd588e1f3e/07a9c/Untitled.png 1440w,\n/static/372cbeefae10ffcbb5505abd588e1f3e/29114/Untitled.png 1920w,\n/static/372cbeefae10ffcbb5505abd588e1f3e/0da74/Untitled.png 2115w\"\n        sizes=\"(max-width: 960px) 100vw, 960px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2>TMI</h2>\n<p><a href=\"https://programmers.co.kr/learn/courses/30/lessons/60060\">코딩테스트 연습 - 가사 검색 | 프로그래머스</a></p>\n<p>오늘도 여김 없이 TMI부터 시작한다. 코딩 테스트 연습을 하면서 알게 된 Trie (트라이) 라는 자료 구조에 대헤 정리 한다. </p>\n<h2>Trie-트라이</h2>\n<blockquote>\n<p>문자열을 효율적으로 탐색하기 위한 자료 구조로 n 진 Tree(트리)형태로 구성되어 있다.</p>\n</blockquote>\n<p>트라이?? 발음은 Try 랑 같다. 잘 모르겠지만 일단 Try 해보자!!</p>\n<p>우리가 여러 개의 문자열을 가지고 있을 때, 어떤 문자열이 그 문자열 중 하나인지 알아내는 방법은 뭐가 있을까?단순하게 일일이 비교해보면 된다. 하지만 컴퓨터는 이러한 방법이 매우 비효율적이다. 예를 들어, 최대 길이가</p>\n<p>m인 문자열 <em>n</em>개의 집합에서 마찬가지로 최대 길이가<em>m</em>인 임의의 문자열이 그 문자열들의 집합에 포함되는지를 일일이 확인하면 사전처리는 필요 없지만, 최악의 경우O(nm)의 비교 횟수가 필요하다.</p>\n<p>이 문자열을 정렬시킨 뒤, <a href=\"https://namu.wiki/w/%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89\">이진 탐색</a> 이라는 강력한 알고리즘을 사용하면O(m log n)로 단축시킬 수 있지만, 정렬 과정 자체에 O(n m log n)의 시간이 걸리므로 사양이 안 좋은 컴퓨터라면 이것도 비효율적이다. 하지만 위의 시간 복잡도를 압도하는 알고리즘이 존재한다. 프레드킨이 이름 붙인 “Trie”라는 자료구조가 지금부터 설명할 가장 효율적인 문자열 검색법이다.</p>\n<h2>구현 코드</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TrieNode {\n    private final Map&lt;Character, TrieNode&gt; children = new HashMap&lt;&gt;();\n    private boolean endOfWord;\n    private int count;\n\n    Map&lt;Character, TrieNode&gt; getChildren() {\n        return children;\n    }\n\n    boolean isEndOfWord() {\n        return endOfWord;\n    }\n\n    void setEndOfWord(boolean endOfWord) {\n        this.endOfWord = endOfWord;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    void increaseCount() {\n        this.count++;\n    }\n}\n\npublic class Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word)1\n        TrieNode current = root;\n\n        current.increaseCount();\n        current = current.getChildren()\n                .computeIfAbsent((char) (word.length() + &#39;0&#39;), c -&gt; new TrieNode());\n\n        for (char trieWord : word.toCharArray()) {\n            current.increaseCount();\n            current = current.getChildren()\n                    .computeIfAbsent(trieWord, c -&gt; new TrieNode());\n        }\n\n        current.setEndOfWord(true);\n    }\n\n    public int countOfSearched(String word, int index) {\n        TrieNode current = root;\n\n        TrieNode wordLengthNode = current.getChildren().get((char) (word.length() + &#39;0&#39;));\n        if (wordLengthNode == null) {\n            return 0;\n        }\n        current = wordLengthNode;\n\n        for (int i = 0; i &lt; index; i++) {\n            char ch = word.charAt(i);\n            TrieNode node = current.getChildren().get(ch);\n            if (node == null) {\n                return 0;\n            }\n            current = node;\n        }\n        return current.getCount();\n    }\n}</code></pre></div>\n<h2>update 예정…</h2>","fields":{"tagSlugs":["/tags/문자열-탐색/"],"slug":"/cs/data-structure/trie"},"frontmatter":{"title":"Trie 트라이","tags":["문자열 탐색"],"date":"2019-11-14T05:06:35.750Z","description":"코딩 테스트 연습을 하면서 알게 된 Trie (트라이) 라는 자료 구조에 대헤 정리 한다.","path":"/cs/data-structure/trie","category":"data-structure"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"/cs/data-structure/trie/#trie-%EA%B5%AC%EC%A1%B0-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89\">Trie 구조 (문자열 검색)</a></p>\n<ul>\n<li><a href=\"/cs/data-structure/trie/#tmi\">TMI</a></li>\n<li><a href=\"/cs/data-structure/trie/#trie-%ED%8A%B8%EB%9D%BC%EC%9D%B4\">Trie-트라이</a></li>\n<li><a href=\"/cs/data-structure/trie/#%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C\">구현 코드</a></li>\n<li><a href=\"/cs/data-structure/trie/#update-%EC%98%88%EC%A0%95\">update 예정…</a></li>\n</ul>\n</li>\n</ul>","headings":[{"value":"Trie 구조 (문자열 검색)","depth":1},{"value":"TMI","depth":2},{"value":"Trie-트라이","depth":2},{"value":"구현 코드","depth":2},{"value":"update 예정…","depth":2}]}},"pageContext":{"slug":"/cs/data-structure/trie"}},"staticQueryHashes":[]}