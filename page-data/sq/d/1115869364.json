{"data":{"allMarkdownRemark":{"edges":[{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#02 Serializer.md","fields":{"slug":"/python/django/drf-02-serializer/","categorySlug":"/categories/django/"},"internal":{"content":"\nDRF의 serializer에 대해서 알아봅시다.\n\nDRF의 Serializer는 queryset이나 모델의 instance와 같은 복잡한 데이터를 json처럼 쉽게 사용 가능한 python data type으로 변환 시켜줍니다. 또한 validation도 검증해줍니다.<br>\n<br>\nSerializer의 의미에 대해서는 아래 포스트를 읽어보길 바랍니다.<br>\n[직렬화(serialisation)는 무엇인가](https://bmh8993.github.io/cs/network/serialization/)<br>\n<br>\n\n## 1. Article object and serializer\n```python\n# news.models.py\n\nfrom django.db import models\n\n\nclass Article(models.Model):\n    author = models.CharField(max_length=50)\n    title = models.CharField(max_length=120)\n    description = models.CharField(max_length=200)\n    body = models.TextField()\n    location = models.CharField(max_length=120)\n    publication_date = models.DateField()\n    active = models.BooleanField(default=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n```\n```python\n# news.serializers.py\n\nfrom rest_framework import serializers\nfrom .models import Article\n\n\nclass ArticleSerializer(serializers.Serializer):\n    id = serializers.IntegerField(read_only=True)\n    author = serializers.CharField()\n    title = serializers.CharField()\n    description = serializers.CharField()\n    body = serializers.CharField()\n    location = serializers.CharField()\n    publication_date = serializers.DateField()\n    active = serializers.BooleanField()\n    created_at = serializers.DateTimeField(read_only=True)\n    updated_at = serializers.DateTimeField(read_only=True)\n```\n## 2. Serializing objects\n\n- 위에서 만든 ArticleSerializer로 article을 serialize 할 수 있습니다.\n- 모델 인스턴스를 파이썬 내부 데이터 타입으로 출력한 결과\n- 미리 인스턴스를 만들고 진행했습니다.\n```shell\n>>> article_instance = Article.objects.first()\n>>> serializer = ArticleSerializer(article_instance)\n>>> serializer\nArticleSerializer(<Article: admin test_title>):\n    id = serializers.IntegerField(read_only=True)\n    author = serializers.CharField()\n    title = serializers.CharField()\n    description = serializers.CharField()\n    body = serializers.CharField()\n    location = serializers.CharField()\n    publication_date = serializers.DateField()\n    active = serializers.BooleanField()\n    created_at = serializers.DateTimeField(read_only=True)\n    updated_at = serializers.DateTimeField(read_only=True)\n>>> serializer.data\n{'id': 1, 'author': 'admin', 'title': 'test_title', 'description': 'test_description', 'body': 'test_body', 'location': 'test_location', 'publication_date': '2020-04-02', 'active': True, 'created_at': '2020-04-02T10:57:03.725817Z', 'updated_at': '2020-04-02T10:57:03.725844Z'}\n>>> type(serializer.data)\nrest_framework.utils.serializer_helpers.ReturnDict\n```\n- python datatype에서 JSON으로 출력하기 위해서 아래와 같이 렌더링을 거쳐야합니다.\n```shell\n>>> from rest_framework.renderers import JSONRenderer\n>>> json = JSONRenderer().render(serializer.data)\n>>> json\nb'{\"id\":1,\"author\":\"admin\",\"title\":\"test_title\",\"description\":\"test_description\",\"body\":\"test_body\",\"location\":\"test_location\",\"publication_date\":\"2020-04-02\",\"active\":true,\"created_at\":\"2020-04-02T10:57:03.725817Z\",\"updated_at\":\"2020-04-02T10:57:03.725844Z\"}'\n>>> type(json)\nbytes\n```\n\n## 3. Deserializing objects\n- 첫째로 파이썬 native datatype으로 변환합니다.\n```shell\n>>> import io\n>>> from rest_framework.parsers import JSONParser\n>>> stream = io.BytesIO(json)\n>>> data = JSONParser().parse(stream)\n>>> data\n{'id': 1,\n 'author': 'admin',\n 'title': 'test_title',\n 'description': 'test_description',\n 'body': 'test_body',\n 'location': 'test_location',\n 'publication_date': '2020-04-02',\n 'active': True,\n 'created_at': '2020-04-02T10:57:03.725817Z',\n 'updated_at': '2020-04-02T10:57:03.725844Z'}\n```\n- deserializing한 데이터를 사용하기 전에 항상 `is_vaild()`함수를 호출해야합니다.\n- DRF 코드를 보면 `.is_vaild()` before attempting, first, before accessing 등...기록되어져 있습니다.\n- 특히, DRF 코드를 보면 `save()`하기 이전에 `is_vaild()`를 해야한다고 써있습니다.\n```python\nclass BaseSerializer(Field):\n  ...\n\n  def save(self, **kwargs):\n    assert hasattr(self, '_errors'), (\n        'You must call `.is_valid()` before calling `.save()`.'\n    )\n  ...\n```\n- serializer에 instance를 전달하면 `update`를 실행하고, instance를 전달하지 않으면 `create`를 합니다.\n```python\n# .save() will create a new instance\nserializer = ArticleSerializer(data=data)\nserializer.save()\n# .save() will update the existing `article` instance\nserializer = ArticleSerializer(article_instance, data=data)\nserializer.save()\n```\n\n---\n\nref: [Dean's blog](https://dean-kim.github.io/rest_framework/2017/05/08/Django-REST-Framework-Serializers.html)\n"},"frontmatter":{"layout":"post","title":"Django/DRF#02 Serializer","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#01 DRF란 무엇인가?.md","fields":{"slug":"/python/django/drf-01/","categorySlug":"/categories/django/"},"internal":{"content":"DRF에 대해서 간략하게 알아봅시다.\n\n\n### DRF?\n\n공식문서에서 설명하는 DRF입니다.\n> DRF는 Web API를 만들기 위한 강력하고 유연한 툴입니다.<br>\n우리가 DRF를 써야하는 이유가 몇 가지 있습니다.\n> - Web browsable API는 개발자들에게 큰 유용성을 가져다줍니다.\n> - Serialization은 ORM과 non-ORM 데이터 소스를 모두 지원합니다.\n> - 강력한 View도 있지만 일반적인 View를 커스터마이징 해서 사용할 수 있습니다.\n> - DRF를 사용하는 많은 유저들이 있기때문에, 문서와 커뮤니티를 제공할 수 있습니다.\n> - 국제적인 기업들에서 사용하고 있습니다.\n\n<br>\n\n다른 이는 이렇게 말하기도 합니다.\n> DRF는 개발자가 만든 API들을 디버그하기 쉽게 만들어줍니다. DRF의 큰 기능은 **Models를 serializers로 변환하는 것**입니다. DRF에서 serializers는 복잡한 구조들을 이미 구성해두었습니다.\n> serializers는 모델을 전달하고, 그 모델들을 json 객체로 변환하는 것만이 전부가 아닙니다. 클라이언트로부터 백엔드에게 데이터를 전달하기도합니다. 코드를 검증하는 것도 자동으로 할 수 있습니다. 코드를 정리해서 security issues를 해결하기도 합니다.\n\n<br>\n\n많은 사람들이 설명하는 DRF는 무엇일까요?\n> Django 안에서 RESTful API 서버를 쉽게 구축할 수 있도록 도와주는 오픈소스 라이브러리입니다.\n\n### Serializer\n\n[직렬화(serialisation)는 무엇인가]()\n\n직렬화에 대한 설명은 위의 글을 읽어보길 바랍니다.<br>\n<br>\n파이썬 형식의 코드를 다른 네트워크 환경과 통신을 위해 코드를 직렬화 해야하는데,\nDRF에서 그것을 담당하는 클래스가 바로 `Serializer`입니다. DRF에서 제공하는 Serializer는\nqueryset, model instance 등의 복잡한 데이터를 JSON, XML 등의 컨텐트 타입으로 쉽게 변환 가능한\npython datatype으로 변환시켜줍니다.<br>\n\n**RESTful API와 Serializer가 DRF를 사용하는 가장 큰 장점이 아닐까 생각합니다.**\n"},"frontmatter":{"layout":"post","title":"DRF/#01 DRF란 무엇인가?","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#06 GenericAPIView and Mixins.md","fields":{"slug":"/python/django/drf-06-generic-mixins/","categorySlug":"/categories/django/"},"internal":{"content":"[Django-GenericAPIView의 공식문서](https://www.django-rest-framework.org/api-guide/generic-views/)를 보면 GenericAPIView를 다음과 같이 설명하고 있다.\n\n> Django의 GenericAPIView는 공통된 사용 패턴의 shortcut으로 개발된 것이다. 뷰 개발에서 발견되는 특정 공통 idioms와 패턴을 가져와서 추상화한 것이므로 개발자들이 반복하지 않고 일반적인 데이터에 대한 뷰를 빠르게 작성할 수 있도록 한다.\n\n> ... generic views가 API의 요구 사항에 맞지 않으면 `APIView` 클래스를 사용하거나 generic views에서 사용하는 mixins 및 base 클래스를 재사용 가능한 generic views를 작성할 수 있다.\n\n\n## GenericAPIView\n\n이 클래스는 REST framework의 APIView 클래스를 확장한 것으로, 표준 list와 detail view에 일반적으로\n필요한 동작을 추가한다. 제공되는 각각의 구체적인 generic views는 GenericAPIView를 하나 이상의\nmixin 클래스와 결합하여 만든다.\n\n- Ebook과 Review 모델이 있고, 1 : N 관계이다.\n\n```python\n# ebook/models.py\n\nfrom django.db import models\nfrom django.core.validators import MinValueValidator, MaxValueValidator\n\n\nclass Ebook(models.Model):\n    title = models.CharField(max_length=140)\n    author = models.CharField(max_length=60)\n    description = models.TextField()\n    description_date = models.DateField()\n\n    def __str__(self):\n        return self.title\n\n\nclass Review(models.Model):\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    review_author = models.CharField(max_length=8, blank=True)\n    review = models.TextField(blank=True)\n    rating = models.PositiveIntegerField(\n            validators=[\n                MinValueValidator(1),\n                MaxValueValidator(5)\n                ]\n            )\n    ebook = models.ForeignKey(\n            Ebook,\n            on_delete=models.CASCADE,\n            related_name=\"reviews\"\n            )\n\n    def __str__(self):\n        return str(self.rating)\n```\n\n```python\n# ebook/api/serializers.py\n\nfrom rest_framework import serializers\nfrom ..models import Ebook, Review\n\n\nclass ReviewSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Review\n        fields = \"__all__\"\n\nclass EbookSerializer(serializers.ModelSerializer):\n    reviews = ReviewSerializer(many=True, read_only=True)\n\n    class Meta:\n        model = Ebook\n        fields = \"__all__\"\n```\n\n- GenericAPIView과 mixin을 사용해보자. queryset 리스트와 instance를 생성하는 view이다.\n- 위에서 설명한대로 한개 이상의 mixin과 GenericAPIView를 사용했다.\n- `get` method에서 `list method`를 return 하는데, list method는 ListModelMixin에 정의된 method이다. list 메소드에 사용되는 method들은 GenericAPIView의 method이다.\n- 내부적인 소스를 까보면 `queryset`, `serializer_class`가 필요하다.(나는 개인적으로 정말 궁금해서 코드를 까보았다.)\n\n```python\n# ebook/api/views.py\n\nclass EbookListCreateAPIView(\n        mixins.ListModelMixin,\n        mixins.CreateModelMixin,\n        generics.GenericAPIView):\n    queryset = Ebook.objects.all()\n    serializer_class = EbookSerializer\n\n    def get(self, request, *args, **kwargs):\n        return self.list(request, *args, **kwargs)\n\n    def post(self, request, *args, **kwargs):\n        return self.create(request, *args, **kwargs)\n```\n\n- 위에 작성된 View를 Concrete View Classes로 바꿀 것이다.\n- Concrete View Classes는 heavily한 커스터마이징 된 동작이 필요하지 않으면 사용하면 좋다고 설명하고 있다.\n\n```python\nclass EbookListCreateAPIView(generics.ListCreateAPIView):\n    queryset = Ebook.objects.all()\n    serializer_class = EbookSerializer\n```\n\n- GenericAPIView로 작성한 views.py\n\n```python\nfrom rest_framework import generics\nfrom rest_framework import mixins\nfrom rest_framework.generics import get_object_or_404\n\nfrom ..models import Ebook, Review\nfrom ..api.serializers import EbookSerializer, ReviewSerializer\n\n\nclass EbookListCreateAPIView(generics.ListCreateAPIView):\n    queryset = Ebook.objects.all()\n    serializer_class = EbookSerializer\n\n\nclass EbookDetatilAPIView(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Ebook.objects.all()\n    serializer_class = EbookSerializer\n\n\nclass ReviewCreateAPIView(generics.CreateAPIView):\n    queryset = Review.objects.all()\n    serializer_class = ReviewSerializer\n\n    def perform_create(self, serializer):\n        ebook_pk = self.kwargs.get(\"ebook_pk\")\n        ebook = get_object_or_404(Ebook, pk=ebook_pk)\n        serializer.save(ebook=ebook)\n\n\nclass ReviewDetailAPIView(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Review.objects.all()\n    serializer_class = ReviewSerializer\n```\n\n- 모델을 다음과 같이 수정해야한다. ReviewCreateAPIView에서 `perform_create`를 선언하면서\nebook instance에 ebook을 저장하기 때문이다.(코드에서 보이는 kwargs(ebook-pk)는\nend-point에서 받는다.)\n\n```python\n# ebook/api/serializers.py\n\nclass ReviewSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Review\n        exclude = (\"ebook\",)\n```\n\n```python\n# ebook/api/urls.py\n\nfrom django.urls import path\nfrom ..api.views import (\n        EbookListCreateAPIView,\n        EbookDetatilAPIView,\n        ReviewCreateAPIView,\n        ReviewDetailAPIView\n        )\n\nurlpatterns = [\n        path(\"ebooks/\",\n            EbookListCreateAPIView.as_view(),\n            name=\"ebook-list\"),\n        path(\"ebooks/<int:pk>/\",\n            EbookDetatilAPIView.as_view(),\n            name=\"ebook-detail\"),\n        path(\"ebooks/<int:ebook_pk>/review/\",\n            ReviewCreateAPIView.as_view(),\n            name=\"ebook-review\"),\n        path(\"reviews/<int:pk>/\",\n            ReviewDetailAPIView.as_view(),\n            name=\"review-detail\"),\n        ]\n```\n\n---\n\nref: [Dean's blog](https://dean-kim.github.io/rest_framework/2017/05/24/Django-REST-Framework-GenericViews.html)<br>\nref: [SJQuant's Devlog](https://sjquant.tistory.com/34)\nref: [mixins source code](https://github.com/encode/django-rest-framework/blob/master/rest_framework/mixins.py)\n"},"frontmatter":{"layout":"post","title":"Django / DRF#06 GenericAPIView and Mixins","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#07 Permission으로.md","fields":{"slug":"/python/django/drf-07-permission/","categorySlug":"/categories/django/"},"internal":{"content":"\n# Permission\n\n- request에 access를 허용할 지 또는 거부할 지 결정\n- Permission 검사는 다른 코드가 진행되기 전에 view의 맨 처음에 항상 실행됨\n- Permission 검사는 일반적으로 들어오는 request의 허용하는지 결정하기 위해 `request.user` 및\n`request.auth`의 properies를 등록정보의 인증정보로 사용\n- 가장 간단한 permission은 `IsAuthenticated` class인데\n    - 인증된 사용자에게 access 허용\n    - 인증되지 않은 사용자에게 access 거부\n\n## 모든 View에 동일한 Permission 적용하기(전역 설정)\n\n- settings.py에 아래 코드를 입력합니다.\n- 하지만 아래와 같이 사용은 합리적이지 않습니다. 일반적으로 view마다 권한이 다르기 때문입니다.\n\n```python\nREST_FRAMEWORK = {\n    'DEFAULT_PERMISSION_CLASSES': [\n        'rest_framework.permissions.IsAuthenticatedOrReadOnly',\n    ]\n}\n```\n\n## 특정 View에 특정 Permission 지정하기\n\n- app/view.py에 다음과 같이 입력합니다.\n- APIView를 사용한 view를 작성했다면 다음과 같이 작성합니다.\n\n```python\nclass ExampleAPIView(...):\n\n    ...\n    permission_classes = [PermissionClass]\n```\n\n## Permission을 커스텀해서 사용하기(Custom permissions)\n\n- 다음과 같은 model과 serializers가 있다고 가정합니다.\n- view와 urls를 작성한 이후 permissions.py를 작성하고 permissions을 적용하고 싶은 view에\n코드를 추가적으로 작성합니다.\n- 지금 작성하려는 permissions는 리뷰를 작성한 사람이면 접근을 허락하고 아니면 읽기만 가능한\npermissions입니다.(일차적으로 읽기에 해당하는 메소드이라면 접근 허락)\n\n```python\n# ebook/models.py\n\nfrom django.db import models\nfrom django.core.validators import MinValueValidator, MaxValueValidator\n\nfrom django.contrib.auth.models import User\n\n\nclass Ebook(models.Model):\n    title = models.CharField(max_length=140)\n    author = models.CharField(max_length=60)\n    description = models.TextField()\n    description_date = models.DateField()\n\n    def __str__(self):\n        return self.title\n\n\nclass Review(models.Model):\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    review_author = models.ForeignKey(User, on_delete=models.CASCADE)\n    review = models.TextField(blank=True)\n    rating = models.PositiveIntegerField(\n            validators=[\n                MinValueValidator(1),\n                MaxValueValidator(5)\n                ]\n            )\n    ebook = models.ForeignKey(\n            Ebook,\n            on_delete=models.CASCADE,\n            related_name=\"reviews\"\n            )\n\n    def __str__(self):\n        return str(self.rating)\n```\n\n```python\n# ebook/api/serializers.py\n\nfrom rest_framework import serializers\nfrom ..models import Ebook, Review\n\n\nclass ReviewSerializer(serializers.ModelSerializer):\n\n    review_author = serializers.StringRelatedField(read_only=True)\n\n    class Meta:\n        model = Review\n        exclude = (\"ebook\",)\n\nclass EbookSerializer(serializers.ModelSerializer):\n    reviews = ReviewSerializer(many=True, read_only=True)\n\n    class Meta:\n        model = Ebook\n        fields = \"__all__\"\n```\n\n#### Custom permissions\n\n- custom permissions를 구현하려면, `BasePermission`를 상속받아서 작성합니다.\n\n```python\n# ebook/api/permissions.py\n\nfrom rest_framework import permissions\n\n\nclass IsReviewAuthorOrReadOnly(permissions.BasePermission):\n\n    def has_object_permissions(self, request, view, obj):\n        if request.method in permissions.SAFE_METHOD:\n            return True\n\n        return obj.review_author == request.user\n```\n\n- View Class에 `permissions_classes = IsReviewAuthorOrReadOnly`를 선언합니다.\n\n```python\n# ebook/api/views.py\nfrom rest_framework import generics\nfrom rest_framework import mixins\nfrom rest_framework import permissions\nfrom rest_framework.generics import get_object_or_404\nfrom rest_framework.exceptions import ValidationError\n\nfrom ebook.models import Ebook, Review\nfrom ebook.api.serializers import EbookSerializer, ReviewSerializer\nfrom ebook.api.permissions import IsReviewAuthorOrReadOnly\n...\n\nclass ReviewDetailAPIVIEW(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Review.objects.all()\n    serializer_class = ReviewSerializer\n    permissions_classes = IsReviewAuthorOrReadOnly\n```\n\n#### APIView에 사용하기(custom view에 사용하기)\n\n- 위와 같이 generic view를 사용하면 object level permissions을 검사하지만 custom view를\n작성하는 경우 object level permissions 검사를 직접해야합니다. 즉 `has_object_permission`은\n별도의 호출과정이 필요한데, `get_object`를 오버라이드 하고 함수 내에서 `check_object_permissions`\n을 통해 `has_object_permission`을 호출할 수 있습니다.\n\n```python\nclass ReviewDetailView(APIView):\n    permissions_classes = [IsReviewAuthorOrReadOnly]\n\n    def get_object(self, review_id):\n        try:\n            review = Review.objects.get(id=review_id)\n            self.check_object_permissions(self.request, review)\n            return review\n        except Review.DoewNotExist:\n            return None\n\n    def get(self, request, review_id):\n        review = self.get_object(review_id)\n        ...\n```\n---\n\nref: [Dean's blog](https://dean-kim.github.io/rest_framework/2017/05/22/Django-REST-Framework-Permissions.html)<br>\nref: [ssung.k](https://ssungkang.tistory.com/entry/Django-APIView%EC%97%90-permission-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0)\n"},"frontmatter":{"layout":"post","title":"DRF/#07 Permission으로 request의 access 다루기","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#03 validation.md","fields":{"slug":"/python/django/drf-03-validation/","categorySlug":"/categories/django/"},"internal":{"content":"\nDRF의 validation에 대해서 알아봅시다.\n\n데이터를 deserializing을 한 이후에, deserializing한 데이터를 사용하기 전에 항상 `.is_valid()`를\n호출하도록 되어져 있습니다. 만약 에러가 발생하면, `.errors`를 통해서 에러 메세지를 확인할 수 있습니다.<br>\n특별히 나눌 것은 아니라고 생각되지만 object level validation과 field level validation이 존재합니다.\n\n#### object level validation\n- 여러 필드에 대한 validation을 진행합니다. serializer 클래스에 `validate`메서드를 추가합니다.\n```python\nclass ExampleSerializer(serializers.Serializer):\n    ...\n    def validate(self, data):\n        if data[\"title\"] == data[\"description\"]:\n            raise serializers.ValidationError(\"Titile and Description must be different from one another\")\n        return data\n```\n\n#### field level validation\n- serializer 클래스에 `vailidate_{field_name}`함수를 추가해서 사용자 정의 필드 수준 유효성\n검사를 진행할 수 있습니다.\n```python\nclass ExampleSerializer(serializers.Serializer):\n    ...\n    def validate_title(self, value):\n        if len(value) < 30:\n            raise serializers.ValidationError(\"The title has to be at least 30 chars long!\")\n        return value\n```\n"},"frontmatter":{"layout":"post","title":"Django/DRF#03 validation","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#08 Paginati.md","fields":{"slug":"/python/django/drf-08-pagination/","categorySlug":"/categories/django/"},"internal":{"content":"\n# Pagination\n\n- DRF는 커스텀 가능한 페이지네이션 스타일을 제공합니다.\n- DRF에서 제공하는 pagination 기능은 두가지 입니다.\n\n#### PageNumberPagination\n\n- PageNumberPagination을 상속받아서 페이지네이션 클래스를 정의합니다.\n- `page`: 1부터 시작하고, 몇 번째 페이지인지 표시해주는 query parmeter의 이름을\n나타내는 default 문자열 value. `page_query_param`의 값을 설정하면 query parmeter 변경이 가능합니다.\n- `page_size`: 한 페이지에 몇 개의 레코드를 보여줄지 표시해주는 key.\nclient로부터 `page_size`를 받기 위해서는 `page_size_query_param = page_size`라고 정의해야합니다.\n- `end/point/?page=2&page_size=10`과 같이 호출하면 한 페이지에 10개씩 contents가 보이고 2페이지를 보는 endpoint가 완성됩니. `page_size_query_param`으로 설정하는 값은 `page_size`가 아니어도 됩니다.\n단, endpoint에서 호출할 때 사용하는 파라미터 이름은 설정 값과 동일해야 합니다.\n\n#### LimitOffsetPagination\n\n- LimitOffsetPagination을 상속받아서 페이지네이션 클래스를 정의합니다.\n- `limit_query_param`: \"limit\" query parmeter의 이름을 나타내는 문자열 value\n- `offset_query_param`: \"offset\" query parmeter의 이름을 나타내는 문자열 value\n\n## 모든 View에 동일한 Pagination 적용하기(전역 설정)\n\n- settings.py에 아래 코드를 입력합니다.\n\n```python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',\n    'PAGE_SIZE': 3\n}\n```\n\n## 특정 View에 특정 Pagination 지정하기\n\n- pagination class를 작성합니다.\n- app/api/views.py에 다음과 같이 입력합니다.\n\n```python\n#  app/api/pagination.py\n\nfrom rest_framework.pagination import PageNumberPagination\n\n\nclass SmallSetPagination(PageNumberPagination):\n    page_size = 3  # default page_size를 3이라고 설정\n    page_size_query_param = \"page_size\"  # page_size를 client로 부터 받아서 처리\n```\n\n```python\n# app/api/views.py\n\nfrom app.api.pagination import SmallSetPagination\n\n\nclass ExampleAPIView(...):\n\n    ...\n    pagenation_class = SmallSetPagination\n```\n---\n\nref: [Dean's blog](https://dean-kim.github.io/rest_framework/2017/05/12/Django-REST-Framework-Pagination.html)<br>\nref: [ssung.k](https://ssungkang.tistory.com/entry/Django-DRF-Pagination)\n"},"frontmatter":{"layout":"post","title":"DRF/#08 Pagination 처리하기","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/Django:null=True와 blank=True의 차이.md","fields":{"slug":"/python/django/difference-between-null-true-and-blank-true","categorySlug":"/categories/django/"},"internal":{"content":"django의 field option인 null=True와 blank=True에 대해서 알아봅시다.<br>\nDjango model을 검색하면 상위에 올라오는 검색어입니다.<br>\n뭔가 빈 값을 허락하냐는 옵션인데 둘 다 비슷해보입니다.\n분명 다른 것이 있으니 둘 다 제공할텐데 무엇이 다른지 차이를 알고 사용해봅시다.<br>\n\n- Null\n    DB와 관련되어 있습니다. 주어진 DB 컬럼이 null 값을 가질 것인지 아닌지를 정의합니다.\n    DB에 저장시 컬럼의 값이 NULL(데이터 없음)이 저장됩니다.\n- Blank\n    유효성과 관련되어 있습니다. `form.is_valid()`가 호출될 때 폼 유효성 검사에 사용됩니다.\n    쉽게 이야기하면, 필드가 폼(입력양식)에서 빈 채로 저장되는 것을 허용하느냐에 대한 물음으로, 허용시 \"\"(빈 스트링)이 저장됩니다.\n\n여러 글에 따르면 개발자들이 많이 실수하는 부분은 `CharField`, `TextField`와 같은 문자열 기반 필드에 `null=True`를 정의하는 것입니다.\n이 같은 실수를 피해야합니다. 그렇지 않으면 \"데이터 없음\"에 대해 두 가지 값, `None`과 `빈 문자열`을 갖게 됩니다.\n\"데이터 없음\"에 대해 두 가지 값을 갖는 것은 중복입니다.<br>\n<br>\n즉, 문자열 기반의 모델 필드를 `nullable`하게 만들고 싶다면 다음과 같이 해야합니다.\n```python\nclass Person(models.Model):\n    name = models.CharField(max_length=255)\n    introduce = models.TextField(blank=True)  # 여기서 null=True는 넣으면 안된다.\n    birth_date = models.DateField(null=True, blank=True)  # 둘 다 넣어도 괜찮다.\n```\n"},"frontmatter":{"layout":"post","title":"Django/null=True와 blank=True의 차이","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#04 ModelSerializer.md","fields":{"slug":"/python/django/drf-04-ModelSerializer/","categorySlug":"/categories/django/"},"internal":{"content":"\n## ModelSerializer와 serializer의 field를 구성하는 방법\n\n### ModelSerializer\n\n소스코드를 보면 ModelSerializer를 다음과 같이 설명하고 있습니다.\n> - ModelSerializer는 다음과 같은 경우를 제외하고 일반 Serializer에 불과합니다.\n>     - 기본 필드 집합들을 기본적으로 제공합니다.(모델을 기초로 serializer class를 자동으로 만들어줍니다.)\n>     - 기본 검증 집합들을 기본적으로 제공합니다.\n>     - `.create()`, `.update()`가 제공됩니다. (하지만 writable nested relationships는 지원하지 않으므로 필요에 따라 create 메소드를 만들어야합니다.)\n> - 모델의 필드에 기반하여 작성된 serializer의 필드 집합을 자동으로 결정하는 방식은 상당히 복잡합니다.\n> 하지만 구현하는 것을 파고들 필요는 없습니다.\n> - 'ModelSerializer' 클래스가 필요한 필드 집합을 생성하지 않는 경우, 시리얼라이저 클래스에\n> 필드를 명시적으로 선언하거나 '시리얼라이저' 클래스를 사용하십시오.\n\n#### ModelSerializer 사용방법\n이전에 serializer를 소개하는 포스팅에서 `ArticleSerializer` class를 다음과 같이 구성했었습니다.\n```python\n# news.serializers.py\n\nfrom rest_framework import serializers\nfrom .models import Article\n\n\nclass ArticleSerializer(serializers.Serializer):\n    id = serializers.IntegerField(read_only=True)\n    author = serializers.CharField()\n    title = serializers.CharField()\n    description = serializers.CharField()\n    body = serializers.CharField()\n    location = serializers.CharField()\n    publication_date = serializers.DateField()\n    active = serializers.BooleanField()\n    created_at = serializers.DateTimeField(read_only=True)\n    updated_at = serializers.DateTimeField(read_only=True)\n```\n- ModelSerializer를 사용하면 더 간편하게 가능합니다.\n\n```python\n# news.serializers.py\n\nfrom rest_framework import serializers\nfrom .models import Article\n\n\nclass ArticleSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Article\n        fields = \"__all__\"\n```\n- 모델의 모든 필드를 사용하고 싶을 때 `fields = \"__all__\"`\n- 모델의 일부 필드를 제외하고 싶을 때 `exclude = \"(field_name_1, field_name_2)\"`\n- 모델의 일부 필드만 선택적으로 사용할 때 `fields = (\"field_name_1\", \"field_name_2\")`\n\n### field 커스텀하기\n\n기본적으로 model에 등록된 필드 값들은 Meta 클래스에 추가해줌으로서 다뤄줄 수 있지만 커스텀필드를\n정의하는데 있어서는 새로운 방법이 필요합니.\n\n#### SerializerMethodField\nSerializerMethodField는 `read-only field`로 serialized된 데이터에 추가해서 사용할 수 있습니다.\n\n#### SerializerMethodField 사용법\n아래의 코드와 같이 `field_name = serializers.SerializerMethodField()`와 같이 field를 선언하고\n함수 이름을 `get_field_name`의 식으로 정의합니다.<br>\n함수 이름을 `get_field_name`의 식으로 하지 않는다면 다음과 같이 `method_name`을 지정하면됩니다.\n`SerializerMethodField(method_name=field_name_as_I_want)`\n\n```python\n# news.serializers.py\n\nfrom datetime import datetime\n\nfrom django.utils.timesince import timesince\nfrom rest_framework import serializers\nfrom .models import Article\n\n\nclass ArticleSerializer(serializers.ModelSerializer):\n\n    time_since_publication = serializers.SerializerMethodField()\n\n    class Meta:\n        model = Article\n        fields = \"__all__\"\n\n    def get_time_since_publication(self, object):\n        publication_date = object.publication_date\n        now = datetime.now()\n        time_delta = timesince(publication_date, now)\n        return time_delta\n```\n"},"frontmatter":{"layout":"post","title":"DRF/#04 ModelSerializer","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#05 DRF로 nested된 관계를.md","fields":{"slug":"/python/django/drf-05-handle-nested-relationships/","categorySlug":"/categories/django/"},"internal":{"content":"\nDRF에서 nested된 관계를 다루는 방법을 알아봅시다.\n\n관계형 데이터베이스를 사용하면 당연히 `ForiegnKey`를 사용하게 됩니다.\n그렇다면 DRF로 nested된 관계는 어떻게 다뤄야할까요<br>\nserializer와 views가 조금씩 달라질 것입니다.<br>\n\n**가정한 모델의 관계는 `Jounalist : Article = 1 : N`, 한 명의 저널리스트가 여러개의 기사를 쓸 수 있다고 가정했습니다.**\n\n<br>\n\n```python\n# news/models.py\nfrom django.db import models\n\n\nclass Journalist(models.Model):\n    first_name = models.CharField(max_length=60)\n    last_name = models.CharField(max_length=60)\n    biography = models.TextField(blank=True)\n\n    def __str__(self):\n        return f\"{self.first_name} {self.last_name}\"\n\n\nclass Article(models.Model):\n    author = models.ForeignKey(\n            Journalist,\n            on_delete=models.CASCADE,\n            related_name=\"articles\"\n            )\n    title = models.CharField(max_length=120)\n    description = models.CharField(max_length=200)\n    body = models.TextField()\n    location = models.CharField(max_length=120)\n    publication_date = models.DateField()\n    active = models.BooleanField(default=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return f\"{self.author} {self.title}\"\n```\n```python\n# news/api/serializer.py\n\nfrom rest_framework import serializers\nfrom ..models import Article, Journalist\n\n\nclass JournalistSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Journalist\n        fields = \"__all__\"\n\n\nclass ArticleSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Article\n        fields = \"__all__\"\n\n```\n```python\n# news/api/views.py\n\nclass ArticleListCreateAPIView(APIView):\n    def get(self, request):\n        articles = Article.objects.filter(active=True)\n        serializer = ArticleSerializer(articles, many=True)\n        return Response(serializer.data)\n\n    def post(self, request):\n        serializer = ArticleSerializer(data=request.data)\n\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n\nclass ArticleDetailAPIView(APIView):\n    def get_object(self, pk):\n        article = get_object_or_404(Article, pk=pk)\n        return article\n\n    def get(self, request, pk):\n        article = self.get_object(pk)\n        serializer = ArticleSerializer(article)\n        return Response(serializer.data)\n\n    def post(self, request, pk):\n        article = self.get_object(pk)\n        serializer = ArticleSerializer(article, data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n    def delete(self, request, pk):\n        article = self.get_object(pk)\n        article.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n\nclass JounalistListCreateAPIView(APIView):\n    pass\n```\n```python\n# news/api/urls.py\n\nfrom django.urls import path\nfrom news.api.views import (\n        ArticleListCreateAPIView,\n        ArticleDetailAPIView,\n        JounalistListCreateAPIView\n        )\n\nurlpatterns = [\n        path(\"articles/\", ArticleListCreateAPIView.as_view(), name=\"article-list\"),\n        path(\"articles/<int:pk>/\", ArticleDetailAPIView.as_view(), name=\"article-detail\"),\n        path(\"journalists/\", JounalistListCreateAPIView.as_view(), name=\"journalist-list\")\n        ]\n```\n\n1. 여기서 `GET /api/articles/`를 호출하면?\n    > author의 값으로 해당 `journalist_id`가 호출됩니다.\n\n```json\nGET /api/articles/\nHTTP 200 OK\nAllow: GET, POST, HEAD, OPTIONS\nContent-Type: application/json\nVary: Accept\n\n[\n    {\n        \"id\": 1,\n        \"time_since_publication\": \"13 hours, 52 minutes\",\n        \"title\": \"test title\",\n        \"description\": \"test description\",\n        \"body\": \"!!!\",\n        \"location\": \"!!!!!\",\n        \"publication_date\": \"2020-04-26\",\n        \"active\": true,\n        \"created_at\": \"2020-04-26T13:32:15.453026Z\",\n        \"updated_at\": \"2020-04-26T13:32:15.453049Z\",\n        \"author\": 1\n    }\n]\n```\n\n2. author의 detail까지 보고싶으면?\n    - ArticleSerializer에 `author = JournalistSerializer(read_only=True)`를 추가합니다.\n    - 혹시나 하는 마음에 author가 아닌 `test`라는 변수로 JournalistSerializer를 선언했더니\n    값이 안나옵니다. model에 선언된 field 이름으로 해야하는 것 같습니다. 자세한건 나중에 소스코드를\n    살펴봐야겠습니다.\n\n```python\nclass ArticleSerializer(serializers.ModelSerializer):\n\n    author = JournalistSerializer(read_only=True)\n\n    class Meta:\n        model = Article\n        fields = \"__all__\"\n```\n```json\nGET /api/articles/\nHTTP 200 OK\nAllow: GET, POST, HEAD, OPTIONS\nContent-Type: application/json\nVary: Accept\n\n[\n    {\n        \"id\": 1,\n        \"time_since_publication\": \"14 hours, 22 minutes\",\n        \"author\": {\n            \"id\": 1,\n            \"first_name\": \"bae\",\n            \"last_name\": \"mh\",\n            \"biography\": \"hi\"\n        },\n        \"title\": \"test title\",\n        \"description\": \"test description\",\n        \"body\": \"!!!\",\n        \"location\": \"!!!!!\",\n        \"publication_date\": \"2020-04-26\",\n        \"active\": true,\n        \"created_at\": \"2020-04-26T13:32:15.453026Z\",\n        \"updated_at\": \"2020-04-26T13:32:15.453049Z\"\n    }\n]\n```\n\n3. author의 `__str__`이 보고싶으면?\n    - `author = serializers.StringRelatedField()`를 선언하면 model에 정의한 `__str__`의\n    return 값이 나옵니다.\n\n4. 이번에는 journalist에 해당하는 article을 보려고 합니다.\n    - 동일하게 JournalistSerializer에 `articles = ArticleSerializer(many=True, read_only=True)`\n    를 선언하면 되고 articles는 model에서 ForiegnKey 옵션으로 지정한 related\\_name입니다.\n    - JounalistListCreateAPIView를 작성합니다.\n\n```python\n# news/api/serializers.py\nclass ArticleSerializer(serializers.ModelSerializer):\n\n    class Meta:\n        model = Article\n        fields = \"__all__\"\n\n\nclass JournalistSerializer(serializers.ModelSerializer):\n\n    articles = ArticleSerializer(many=True, read_only=True)\n\n    class Meta:\n        model = Journalist\n        fields = \"__all__\"\n```\n```python\n# news/api/views.py\nclass JounalistListCreateAPIView(APIView):\n    def get(self, request):\n        journalist = Journalist.objects.all()\n        serializer = JournalistSerializer(journalist, many=True)  # many=True는 많은 관계를 표현할 때에 passing해줘야 한다.\n        return Response(serializer.data)\n    def post(self, request):\n        serializer = JournalistSerializer(data=request.data)\n\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n```\n```json\nGET /api/journalists/\nHTTP 200 OK\nAllow: GET, POST, HEAD, OPTIONS\nContent-Type: application/json\nVary: Accept\n\n[\n    {\n        \"id\": 1,\n        \"articles\": [\n            {\n                \"id\": 1,\n                \"time_since_publication\": \"14 hours, 41 minutes\",\n                \"title\": \"test title\",\n                \"description\": \"test description\",\n                \"body\": \"!!!\",\n                \"location\": \"!!!!!\",\n                \"publication_date\": \"2020-04-26\",\n                \"active\": true,\n                \"created_at\": \"2020-04-26T13:32:15.453026Z\",\n                \"updated_at\": \"2020-04-26T13:32:15.453049Z\",\n                \"author\": 1\n            }\n        ],\n        \"first_name\": \"bae\",\n        \"last_name\": \"mh\",\n        \"biography\": \"hi\"\n    }\n]\n```\n\n5. articles의 데이터를 직접받아오는 것이 아니라 direct link를 받아오려면?\n    - `serializers.HyperlinkedRelatedField()`를 사용해야 합니다. 인자로 `view_name`은 필수이다. `view_name`은 related된 관계를 명시적으로 표시하는\n    *필수* 옵션입니다. urls.py에서 입력한 `view_name`을 가져옵니다\n    - JournalistSerializer의 옵션에 context={\"request\": request}를 넣어야합니다. 공식문서를 보면\n    `context`는 시리얼라이징 되는 객체 이외에 추가적인 내용을 제공할 때 필요한 argument입니다.\n\n```python\n# news/api/serializers.py\nclass JournalistSerializer(serializers.ModelSerializer):\n\n    articles = serializers.HyperlinkedRelatedField(many=True, read_only=True, view_name=\"article-detail\")\n\n    class Meta:\n        model = Journalist\n        fields = \"__all__\"\n```\n```python\n# news/api/views.py\nclass JounalistListCreateAPIView(APIView):\n    def get(self, request):\n        journalists = Journalist.objects.all()\n        serializer = JournalistSerializer(journalists, many=True, context={\"request\": request})\n        return Response(serializer.data)\n...\n```\n"},"frontmatter":{"layout":"post","title":"DRF/#05 DRF로 nested된 관계를 다뤄보자","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/Django:장고는 무엇이고 어떻게 일하는가?.md","fields":{"slug":"/python/django/what-is-django-and-how-to-work-it/","categorySlug":"/categories/django/"},"internal":{"content":"Django는 무엇이고 어떻게 동작하는지 알아봅시다.\n\n![django_flow_02](./images/django_flow_02.png)\n\nDjango는 현재 가장 많이 사용되는 파이썬 웹 프레임워크입니다.\n2003년 로렌스 저널-월드 신문을 만들던 웹 개발팀의 내부 프로젝트로 시작됐으며, 오픈소스 프로젝트로\n공개되었습니. 그리고 구글의 앱 엔진에서 장고를 사용하면서 많은 사람들이 사용하게 되었고, 현재는\n파이썬의 대표적인 웹 프레임워크로 자리매김하고 있습니다.\n\n장고는 MVC를 기반으로 한 프레임 워크입니다. 장고에서는 View를 Template, Controller를 view라고 부릅니다.\n\nView는 데이터를 가져오고 변형하는 컴포넌트, Template는 데이터를 사용자에게 보여주는 컴포넌트입니다.\n그래서 장고를 흔히 MTV 프레임워크라고 부르기도합니다.\n\n- Model\n    안전하게 데이터를 저장\n- View\n    데이터를 적절하게 유저에게 보여줌\n    = 데이터를 유저에게 보내줄 때 유저가 원하는 형태로 형태로 보내주는 것을 담당\n- Control, Template(Django)\n    사용자의 입력과 이벤트에 반응하여 Model과 View를 업데이트(수정)\n\n## Django 개념\n###  장고의 workflow\n![django_flow_01](./images/django_flow_01.png)\n\n\n1. 웹 브라우저에서 이벤트가 발생 (url을 클릭하거나, 어떤 form에 data를 입력 등)\n\n2. 장고 서버로 data가 들어오고 'url dispatcher'에서 user가 요청한 url을 분석하고\n    그에 적합한 view로 보내준다.\n3. view는 사용자의 요청을 받아서, DB 어디에 접근해서, 어떤 데이터를 가공해야할 지 모델에 알려주면\n4. 모델에서 실질적인 DB와 커넥션을 하고 데이터를 가져오게 된다.\n5. DB에서 모델에 다시 데이터를 보내고\n6. 모델이 뷰에 데이터를 보내주고 뷰가 실질적으로 user에게 보여줄 데이터를 템플릿에 전송\n7. 템플릿은 ui를 만들어서 웹브라우저에 넘겨주게 된다.\n\n*이렇게 복잡한 과정들이 있는 것은 특정 영역을 분리하는게 중요하기 때문!*\n\n## project와 App\n\n프로젝트 = 웹 사이트\n의미있는 하나의 기능을 app이라고 구성\n\n    $ django-admin startprojec (project name)\n\n이렇게 명령어를 입력하면\n\n    manage.py(실행파일)\n    project name(디렉토리)\n        __init__.py\n        settings.py(전체 프로젝트를 관리하는 설정파일)\n        urls.py\n        wsgi.py\n\n위와 같이 파일 구조가 생깁니다.\n\napp 생성(상위에)\n\n    $ ./manage.py startapp (app name)\n\n다양한 파일 목록이 생깁니다.\n\n    app name\n        admin.py(관리자권한을 가지는 사용자가 볼 수 있는 페이지에 대한 내용을 다룸)\n        __init__.py\n        migrations\n            __init__.py\n        models.py\n        tests.py\n        views.py(데이터를 가공)\n\n### Settings.py\n\n전체적인 프로젝트 환경 설정 파일\n\n`debug`\n에러에 대한 내용을 보고 싶을때 true로 두게 되면 변수의 상태를 확인 할 수 있습니다.\n배포를 할 때는 false(디버깅 내용을 공개하지 않기 위해서), 개발단계에서는 true\n\n`installed_apps`\n    pip로 설치한 앱 또는 본인이 만든 app를 추가\n\n`middelware_classes`\nrequest와 response 사이의 주요 기능 레이어(크게 신경 쓸 필요 없음 - 보안 기능)\n`templates`\ndjango template관련 설정, 실제 뷰(html, 변수)에서 컨트롤해서 다루게 됩니다.\n`databases`\n데이터베이스 설정 파일, 데이터베이스 엔진의 연결 설정(다양한 데이터베이스를 사용할 수 있음)\n`static_url`\n정적파일(js,img,css)들과 관련된 url이나 dict가 관련된 설정파일\n\n### Manage.py\n프로젝트 관리 명령어 모음\n\n`startapp`: 앱생성\n`runserver`: 서버 실행\n`createsuperuser`: 관리자 실행\n`makemigrations app`: app의 모델 변경 사항 체크\n`migrate`: 변경 사항을 DB에 반영\n`shell`: 쉘을 통해 데이터를 확인\n`collectstatic`: static 파일을 한 곳에 모음\n\n    ex) ./manage.py runserver 0.0.0.0:8080\n\n---\n\nref : https://www.essenceandartifact.com/2012/12/the-essence-of-mvc.html\n"},"frontmatter":{"layout":"post","title":"Django/장고는 무엇이고 어떻게 일하는가?","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/django-multi-database.md","fields":{"slug":"/python/django/multiple-db/","categorySlug":"/categories/django/"},"internal":{"content":"현재 내가 있는 회사(Dailyfunding)에서 새로운 프로젝트를 진행중이다.\n내가 담당하고 있는 백엔드는 python으로 Django 프레임워크를 사용하고 있다.\n현재 진행 중인 프로젝트에서 100여개의 크롤링 데이터를 사용해야하는데,\n크롤러가 python이 아닌 php로 개발되어져 있어서, 기존의 크롤러를 python으로 새로 만들기에는 많은 시간이 걸릴 것으로 판단했다.\n그래서 내린 결론은 Django에서 어떤 하나의 앱으로 접근했을 때에 크롤러가 쌓고 있는 데이터의 DB로 접근하도록 하는 것이다.\n찾아보니 Django 에서는 `multiple Databases` 기능을 제공한다.<br><br>\n아래 step은 공식문서를 기준을 작성 되었다.\n\n## Multiple Databases\n1. **Defining you databases**<br>\n첫번째 단계는 내가 사용할 데이터베이스에 대해서 Django에게 얘기해주는 것이다. 즉 세팅을 해야한다.\n데이터베이스에는 내가 선택한 세팅을 할 수 있는데, 주의 해야할 점이 있다면\n다른 데이터베이스가 선택되지 않은 경우에는 기본값으로 설정한 데이터베이스를 선택한다는 점이다.<br><br>\n아래의 코드는 공식문서를 참고한 내가 실제로 사용려는 코드이다 물론 db password는 진짜가 아니다.\n```python\nDATABASES = {\n    'default': {\n        'ENGINE': 'mysql.connector.django',\n        'NAME': 'db_name',\n        'USER': 'db_user',\n        'PASSWORD': 'db_password',\n        'HOST': '127.0.0.1',\n        'PORT': '3306',\n        'TEST': {\n            'CHARSET': 'utf8',\n            'COLLATION': 'utf8_general_ci',\n        },\n        'OPTIONS': {\n            'charset': 'utf8',\n            'use_pure': True\n        }\n    },\n    \"crawler\": {\n        'ENGINE': 'mysql.connector.django',\n        'NAME': 'db_name',\n        'USER': 'db_user',\n        'PASSWORD': 'db_password',\n        'HOST': '127.0.0.1',\n        'PORT': '3306',\n        'TEST': {\n            'CHARSET': 'utf8',\n            'COLLATION': 'utf8_general_ci',\n        },\n        'OPTIONS': {\n            'charset': 'utf8',\n            'use_pure': True\n        }\n\n    }\n}\n```\n이제 두가지 방법이 있다.\n#### SQL로 직접 참조\n#### ORM으로 참조\n\n아래의 방법은 ORM으로 참조하는 방법을 설명한다.\n\n## Database Routers\n2. **set up database routing scheme**<br>\nrequest를 받았을 때에 어떤 데이터베이스로 연결지어야 할지 결정을 해야하는데 이를 해주는 것이 라우터이다.\n라우터는 네가지 메소드를 제공하는 클래스이다.<br>\n`router.py`의 작성 위치는 해당 앱 하위에 생성하면 된다.\n\n```python\nclass DB_routers:\n    \"\"\"\n    데이터베이스의 연산을 제어하는 중계기\n    \"\"\"\n\n    def db_for_read(self, model, **hints):\n        \"\"\"\n        daily_lab의 모델을 조회하는 경우 daily_lab_db로 중계한다.\n        \"\"\"\n        if model._meta.app_label == \"daily_lab\":\n            return \"daily_lab_db\"\n        return None\n\n    def db_for_write(self, model, **hints):\n        \"\"\"\n        daily_lab의 모델을 기록하는 경우 daily_lab_db로 중계한다.\n        \"\"\"\n        if model._meta.app_label == \"daily_lab\":\n            return \"daily_lab_db\"\n        return None\n\n    def allow_relation(elf, obj1, obj2, **hints):\n        \"\"\"\n        daily_lab의 모델과 관련된 관계접근을 허용한다.\n        \"\"\"\n        if (obj1._meta.app_label == \"daily_lab\" or\n            obj2._meta.app_label == \"daily_lab\"):\n            return True\n        return None\n\n    def allow_migrate(self, db, app_label, model_name=None, **hints):\n        \"\"\"\n        daily_lab의 migrate_file이 daily_lab_db에만 migrate 되도록한다.\n        \"\"\"\n        if app_label == \"daily_lab\":\n            return db == \"daily_lab_db\"\n        return None\n```\n## Models\nDB_settings와 router 클래스를 모두 작성하였다면 models를 작성해야하는데,\n어짜피 이미 짜여진 테이블 구조를 가져온다면 `instpectdb`라는 기능을 통해서 models의 내용을 가져오자.\n\n```shell\npython manage.py inspectdb --database=daily_lab_db > daily_lab/models.py\n```\n\n이렇게 해서 models.py를 열어보면 작성되어져 있다. 이후 View에서 ORM을 사용해서 data를 가져오면 된다.\n<br><br>\n이번 리서치를 통해서 다시한번 느낀다. 주니어 개발자로서 어디까지 가능한지 판단하지 말고 생각하고 찾아보는 것이다.\n그리고 그 어디까지는 상상불가라는 것이다. `multiple Databases` 생각하지도 못했다. 그저 CTO님의 제안이었다.\n로직 안에서만 가능한지를 생각하지말고 전체적인 부분에서도 생각해보자. 불가능은 없다.\n\n---\nref: [django multi-db docs](https://docs.djangoproject.com/en/2.2/topics/db/multi-db)<br>\nref: [multiple databases cook book](https://django-orm-cookbook-ko.readthedocs.io/en/latest/multiple_databases.html)<br>\nref: [multiple db two settings](https://dooha.tistory.com/15)<br>\nref: [django instpectdb](https://tbang.tistory.com/65)<br>\n"},"frontmatter":{"layout":"post","title":"Django / Multiple Databases 세팅하기","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/Django:비지니스 로직 관리하기.md","fields":{"slug":"/python/django/manage-business-logic/","categorySlug":"/categories/django/"},"internal":{"content":"\ndjango를 사용할 때 비지니스 로직을 어떻게 관리하는지 알아봅시다.\n\nDjango를 사용하면서 고민되는 점이 생겼습니다. 비지니스 로직을 어떻게 관리하는게 좋을까 하는 부분입니다.\n(현재 진행하고 있는 프로젝트는 DRF를 사용하고 있습니다.)<br>\n<br>\n**views.py**는 CBV를 사용하고 있어서 최대한 간결하게 작성하고,\nserializer의 메소드를 오버라이드 하여 작성하고 있습니다. 복잡한 비지니스로직을 작성하다보니\n리팩토링의 필요성을 느꼈고, **models.py**에 모델메소드를 작성하고 있었습니다. 하지만 그마저도 너무 많아져서 fat model이 되버렸습니다.<br>\n<br>\n\n*\"비지니스 로직을 어떻게 관리했을 때 프로젝트를 관리가 편해질까\"*<br><br>\n\n이런 질문에서부터 이 글이 시작되었습니다.<br>\n\n## Fat models는 너무 많은 의존성을 만들어낸다.\n\n비지니스 로직은 어떤 하나의 큰 흐름입니다. 그래서 비지니스 로직을 작성하다보면 흐름을 시작한\nmodel 뿐만 아니라 다른 model에서의 메소드를 불러와서 호출하기도 합니다. 이런 방식은 불필요한 의존성을 만들어냅니다.<br>\n<br>\n의존성때문에 다른 모델에서의 변경이 발생하면 변경을 반영하기 위해서 흐름 안에 있는 코드를 수정해야 합니다.\n\n## Fat models는 테스트를 어렵게 한다.\n\n만약 나의 모델이 큰 흐름을 가지고 있다면, 내 테스트 코드들은 크고 많은 더미 데이터를 필요로 할 것입니다.\n\n## Fat models는 SRP를 위반한다.\n\nSRP(단일 책임 정책)은 클린 아키텍처의 5가지 원칙중의 하나로, 다음과 같은 원칙입니다. 자세한 내용은 다음에 `클린 아키텍처`라는\n책을 읽고 블로깅 할 예정입니다.\n\n- 클래스는 단 하나의 책임을 해야한다.\n- 클래스가 변경되는 이유는 단 한 개여야 한다.\n\nFat models를 작성하다보면 많은 책임을 갖게 만듭니다. 예를 들어 User 모델은 user의 DB를 관리하는데 목적이 있습니다.<br>\nUser 모델에 메일을 보내거나 알림을 보내는 메소드를 작성하게 되면 어떤 알림이나 메일을 보내는 책임이 더해지는 것입니다.\n\n## 흐름과 관련된 것이 아니라 attr을 변경하는 메소드를 작성하자\n\n- 상태(attr)을 변경하는 것은 늘 행동(메소드)를 통해서 하세요. 매우 중요합니다.\n직접 변경하게 되면 트랙킹하기가 어려울 것입니다. 사이즈가 커지면 커질수록 더욱 어렵습니다.\n- Django의 모델은 python 클래스의 일부입니다. OOP의 관점에서 객체의 상태는 행동(메소드)에 의해서 변경 되어야합니다.\n\n```python\nfrom django.db import models\n\nclass Customer(models.Model):\n    name = models.CharField(max_length=90)\n    active = models.BooleanField(default=True)\n    work_email = model.EmailField()\n    personal_email = models.EmailField(null=True, blank=True)\n```\n\n- 다음과 같이 active의 상태를 변경하는 코드를 통해서 상태가 혼잡해지는 사태를 막을 수 있게 되었습니다.\n\n```python\nfrom django.db import models\n\nclass Customer(models.Model):\n    name = models.CharField(max_length=90)\n    active = models.BooleanField(default=True)\n    work_email = model.EmailField()\n    personal_email = models.EmailField(null=True, blank=True)\n\n    def deactivate(self):\n        self.active = False\n        self.save(update_fields=[\"active\"])\n```\n\n- 어떤 상태를 저장하는 것과 더불어 validation 하고 싶다면 다음과 같이 적으면 됩니다. 물론 DRF에서 validateion은\nserializer에 validate를 오버라이드 하면 됩니다.\n\n```python\nfrom django.db import models\n\nclass Customer(models.Model):\n    name = models.CharField(max_length=90)\n    active = models.BooleanField(default=True)\n    work_email = model.EmailField()\n    personal_email = models.EmailField(null=True, blank=True)\n\n    def deactivate(self):\n        self.active = False\n        self.save(update_fields=[\"active\"])\n\n      def set_personal_email(self, email):\n          if self.work_email == email:\n              raise ValueError(\n                  \"Personal email and work email are equal\"\n              )\n          self.personal_email = email\n          self.save(update_fields=[\"personal_email\"])\n```\n\n## 의존성을 피하라\n\n- 흐름 안에 있는 모델에서 다른 모델이나 클래스의 메소드를 호출하면 안됩니다.\n- 특히나 서드파티를 이용할수록 더욱 그렇습니다. 예를들어 가입하게되었을 때에 환영 이메일을 보낸다고 가정합시다.\n객체를 생성하는 코드에서 메일을 보낼 때에 서버에 이상이 생긴다면 생성되지도 않은 유저에게 이메일을 보내는 경우가 생깁니다.\n\n## model manager를 사용해라\n\n- 모델 매니저를 사용하면 여기저기서 쿼리가 남발 되는 것을 막을 수 있습니다. 매니저를 사용하게 되면 테스트가 더욱 쉬워지고,\n한 곳에서만 변화를 만들 수 있습니다.\n\n## 결론\n\n제가 진행하고 있는 프로젝트에서는 다음과 같이 관리하기로 했습니다.\n\n1. models는 객체의 속성만 다루는 메소드를 작성한다.\n\n2. orm을 사용하여 query가 발생하는 메소드는 manager를 오버라이드하여 작성한다.\n\n3. utils(service layer) 디렉토리를 만들어 기능단위로 파일을 만들어 관리한다.\n\n    - 그중에서도 공통적으로 사용 가능한 부분은 또 따로 떼어낼 예정\n\n<br>\n\n더 참고할 포스트가 있다면 댓글로 남겨주시면 감사하겠습니다.\n\n---\n\nref: [Django model Guideline](https://medium.com/@jairvercosa/django-model-guideline-d48a96c9b38c)<br>\n"},"frontmatter":{"layout":"post","title":"Django/비지니스 로직 관리하기","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/django-media-file-imagefield.md","fields":{"slug":"/python/django/handle-media/","categorySlug":"/categories/django/"},"internal":{"content":"#### static and media\n\nDjango에서는 static과 media files를 다음과 같이 분류한다.\n- Static Files: `개발 리소스`로서의 정적인 파일(js, css etc)\n- Media Files: 이미지파일이나 유저가 업로드한 파일(image, pdf etc)\n\n---\n\n## settings.py 세팅\n\n#### Media Files 전달 및 저장(settings.py)\n\n1. view: `HttpRequest.FILES`를 통해 파일 전달\n2. view: `settings.MEDIA_ROOT` 디렉토리 하단에 파일 저장\n\n```python\n# root/project/settings.py\n\n# 각 media 파일에 대한 URL Prefix\nMEDIA_URL = '/media/'\n# 미디어 파일을 보면 이미지 url이 다음과 같이 나온다\n# http://127.0.0.1:8000/media/Screen_Shot_2020-04-29_at_17.19.25.png\n\n# 업로드된 파일을 저장할 디렉토리 경로\nMEDIA_ROOT = os.path.join(BASE_DIR, 'media')\n```\n\n#### 새롭게 세팅한 프로젝트 구조에서 `MEDIA_ROOT` 세팅하기\n\n```shell\nproject__root_dir\n├── README.rst\n├── .gitignore\n├── config\n│   ├── __init__.py\n│   ├── settings\n│   │   ├── base.py\n│   │   ├── local.py\n│   │   ├── production.py\n│   │   └── test.py\n│   ├── urls.py\n│   └── wsgi\n│       ├── local.py\n│       ├── production.py\n│       └── test.py\n├── docs\n├── manage.py\n├── project_name\n│   └── static\n│       └── image\n├── requirements\n│   ├── base.txt\n│   ├── local.txt\n│   └── production.txt\n├── .config_secret\n│   ├── base.txt\n│   ├── local.txt\n│   └── production.txt\n├── setup.cfg\n└── tags\n```\n\n- 위와 같은 프로젝트 구조를 가지고 있다면 settings에 다음과 같이 추가해야한다.\n- 아래와 같이 추가하면 `MEDIA_ROOT`는 `project_name/static/image`가 된다.\n\n```python\n# config/settigns/base.py\n\nROOT_DIR = os.path.dirname(BASE_DIR)\n...\nMEDIA_ROOT = os.path.join(ROOT_DIR, \"project__root_dir\", \"project__root_dir\", \"static\", \"image\")\n```\n\n---\n\n## ImageField(models.py)\n\n- ImageField: 이미지 저장을 지원하는 모델 필드(FileField 상속)\n\n```python\n# example_app/models.py\n\nfrom django.db import models\nfrom users.models import User\n\nclass Profile(models.Model):\n    user = models.OneToOneField(User, on_delete=models.CASCADE)\n    bio = modlels.CharField(max_length=240, blank=True)\n    city = models.CharField(max_length=30, blank=True)\n    avatar = models.ImageField(blank=True, upload=to=\"profile/avatar\")\n\n    def __str__(self):\n        return self.user.username\n```\n\n#### 파일저장 세부경로\n\nImageField에 `upload_to=경로`와 같이 설정하면\n  - 저장경로\n      - `settings.MEDIA_ROOT/파일명`경로에 저장\n      - `MEDIA_ROOT/profile/avtar/xxxx.jpg` 경로에 저장\n  - DB\n      - 파일명이 string으로 저장(추가적으로 string으로 저장되기 때문에 null=True가 아닌 blank=True)\n      - `MEDIA_ROOT/profile/avtar/xxxx.jpg` 문자열 저장\n\n#### Pillow\n\n- PIL(Python Image Library)의 일종, 파이썬으로 이미지를 처리하고 싶을 때 사용\n- Pillow는 PIL 프로젝트에서 fork 되어서 나온 라이브러리로, PIL이 python3를 지원하지\n않기 때문에 Pillow를 사용하는 추세\n- 이미지 관련 width, height, format, resize 작업을 수행\n\n```python\n$ pip install pillow\n```\n\n---\n\n## 개발환경에서의 media 파일 서빙(urls.py)\n\n지금까지의 세팅을 마치면 디렉토리에 저장하고, DB에 경로를 저장하는 작업은 가능하다.\n하지만 서빙은 불가능하다. 즉, 데이터를 받아올 수가 없다. 더 쉽게는 이미지파일을 받아올 수\n없다는 것이다.\n\n- 여기서 서빙이란 server로부터 데이터를 받아오는 것을 `serving`이라고 한다.\n\n장고는 개발 서버에서 서빙을 지원해주지 않는다. 즉, `DEBUG=True`일 때의 서빙 rule을\n추가해줘야한다. `DEBUG=False`일 때에는 빈 리스트 리턴한다.\n\n```python\n# config/urls.py\n\nfrom django.conf import settings\nfrom django.conf.urls.static import static\n\nif settings.DEBUG:\n    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\n```\n"},"frontmatter":{"layout":"post","title":"Django / 미디어 파일(Media Files)을 위한 Django 세팅 + ImageField 다루기","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/django-orm-cheat-sheet.md","fields":{"slug":"/python/django/orm-cheat-sheet/","categorySlug":"/categories/django/"},"internal":{"content":"1. [Get fields list of model](#get_fields_list_of_model)\n2. [Update-use Django Model](#update_use_django_model)\n3. [ORM filter/get tips!](#orm_filter_get_tips)\n\n##Get fields list of model<a id=\"get_fields_list_of_model\"></a>\n\n- 모델의 필드 리스트를 얻는 방법\n\n```python\nmodelname._meta.get_fields()\n```\nexample>\n```python\nProduct._meta.get_fields()\n>>>\n(<django.db.models.fields.AutoField: id>,\n <django.db.models.fields.IntegerField: status>,\n <django.db.models.fields.CharField: product_name>)\n```\nadvanced>\n```python\nfields_list = []\nfields = Product._meta.get_fields()\n\nfor field in fields:\n  fields_list.append(field.name)\n\n>>>\n['id',\n 'status',\n 'product_name']\n```\n\n##Update use Django model<a id=\"update_use_django_model\"></a>\n##ORM filter, get tips!<a id=\"orm_filter_get_tips\"></a>\n\n- `filter` 또는 `get`을 할 때에 팁!\n- 꼭 인스턴스로만 접근 가능한 것이 아니라 인스턴스의 `id`값으로도 접근 가능하다.\n- 단, 생성시에는 filter, get과 달리 `인스턴스=인스턴스`의 식으로 사용해야한다.\n\n```python\n# models.py\n\nclass House(models.Model):\n  name = models.CharField(max_length=255, primary_key=True)\n  type = models.ForeignKey(HouseType)\n\nclass HouseType(models.Model):\n  type_name = models.CharField(max_length=255)\n```\n---\n```python\napt = HouseType(\n    type_name=\"apt\"\n    )\napt.save()\n\napt.id\n>>> 1\n\nHouse.objects.create(\n    name=\"mh_house\",\n    type_id=1\n    )\n```\n---\n```python\nmh_house = House.objects.filter(type=apt)  # QuerySet\nmh_house = House.objects.filter(type_id=apt.id)  # QuerySet\nmh_house = House.objects.filter(type=apt.id)  # QuerySet\n\nmh_house = House.objects.get(type=apt)  # Instance\nmh_house = House.objects.get(type_id=apt.id)  # Instance\nmh_house = House.objects.get(type=apt.id)  # Instance\n```\n\n- DB에 컬럼 생성시 자동으로 `_id`가 붙는데 이것을 사용한 것.\n"},"frontmatter":{"layout":"post","title":"Django / ORM cheat sheet","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/django-work-flow.md","fields":{"slug":"/python/django/view-work-flow/","categorySlug":"/categories/django/"},"internal":{"content":"\nDRF를 더욱 잘 오버라이드 하기 위해서 Django의 flow를 다시 파악하려한다.\n\n전체 적인 흐름은 [다음 포스트](https://bmh8993.github.io/Django/what-is-django-and-how-to-it-works/)를 확인하길 바란다.\n\n# Django에서의 View\n\n```python\n# app/urls.py\n\nfrom django.urls import path\nfrom .views import ClassViewName\n\nurlpatterns = [\n    path(\"view/url/\", ClassViewName.as_view())\n]\n```\n\n`ClassViewName.as_view()`에서 as\\_view()의 소스 코드를 보면\n\n```python\nclass View:\n    \"\"\"\n    Intentionally simple parent class for all views. Only implements\n    dispatch-by-method and simple sanity checking.\n    \"\"\"\n\n    http_method_names = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace']\n\n    def __init__(self, **kwargs):\n        # code\n\n    @classonlymethod\n    def as_view(cls, **initkwargs):\n        # code\n\n        def view(request, *args, **kwargs):\n            self = cls(**initkwargs)\n            if hasattr(self, 'get') and not hasattr(self, 'head'):\n                self.head = self.get\n            self.setup(request, *args, **kwargs)\n            if not hasattr(self, 'request'):\n                raise AttributeError(\n                    \"%s instance has no 'request' attribute. Did you override \"\n                    \"setup() and forget to call super()?\" % cls.__name__\n                )\n            return self.dispatch(request, *args, **kwargs)\n        view.view_class = cls\n        view.view_initkwargs = initkwargs\n\n        # take name and docstring from class\n        update_wrapper(view, cls, updated=())\n\n        # and possible attributes set by decorators\n        # like csrf_exempt from dispatch\n        update_wrapper(view, cls.dispatch, assigned=())\n        return view\n\n    def setup(self, request, *args, **kwargs):\n        \"\"\"Initialize attributes shared by all view methods.\"\"\"\n        self.request = request\n        self.args = args\n        self.kwargs = kwargs\n\n    def dispatch(self, request, *args, **kwargs):\n        # Try to dispatch to the right method; if a method doesn't exist,\n        # defer to the error handler. Also defer to the error handler if the\n        # request method isn't on the approved list.\n        if request.method.lower() in self.http_method_names:\n            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)\n        else:\n            handler = self.http_method_not_allowed\n        return handler(request, *args, **kwargs)\n\n    ...\n```\n\n- as\\_view는 view를 리턴하게 된다.  view의 type을 찍어보면 <class 'function'>라고 나온다.\n- view를 실행하면 View의 메소드 `setup`에서 ViewClass의 클래스 변수에 request, args, kwargs를 추가한다.\n- 이후 dispatch 메소드를 실행하게 되는데 `dispatch`는 request의 method를 체크해서 해당 메소드를 호출하게 된다.\n\n# DRF에서의 APIView\n\nAPIView는 DRF에서 제공하는 ViewClass의 기초가 된다. APIView를 살펴보자.\n\n```python\nclass APIView(View):\n\n    ...\n\n    @classmethod\n    def as_view(cls, **initkwargs):\n        ...\n        view = super().as_view(**initkwargs)\n        view.cls = cls\n        view.initkwargs = initkwargs\n\n        return csrf_exempt(view)\n\n        ...\n\n    def dispatch(self, request, *args, **kwargs):\n        \"\"\"\n        `.dispatch()` is pretty much the same as Django's regular dispatch,\n        but with extra hooks for startup, finalize, and exception handling.\n        \"\"\"\n        self.args = args\n        self.kwargs = kwargs\n        request = self.initialize_request(request, *args, **kwargs)\n        self.request = request\n        self.headers = self.default_response_headers  # deprecate?\n\n        try:\n            self.initial(request, *args, **kwargs)\n\n            # Get the appropriate handler method\n            if request.method.lower() in self.http_method_names:\n                handler = getattr(self, request.method.lower(),\n                                  self.http_method_not_allowed)\n            else:\n                handler = self.http_method_not_allowed\n\n            response = handler(request, *args, **kwargs)\n\n        except Exception as exc:\n            response = self.handle_exception(exc)\n\n        self.response = self.finalize_response(request, response, *args, **kwargs)\n        return self.response\n\n```\n\n- APIView에서 return되는 view는 무보클래스의 as\\_view를 통해서 반환된다.\n- 부모 클래스인 view에서 `self.dispatch`를 return 하게되는데 여기서 dispatch는 APIView의\ndispatch이다. 왜냐하면 self는 APIView이기때문이다.\n- 여기서 dispatch가 확인하는 중요한 사항은 `self.initial`이다.\n\n## initial\n\nself.initial은 어떤 값을 return하지 않는다. 함수의 이름대로 initial, 시작부분이고 여기서 3가지를 확인하게 된다.\n\n```python\ndef initial(self, request, *args, **kwargs):\n    \"\"\"\n    Runs anything that needs to occur prior to calling the method handler.\n    \"\"\"\n    self.format_kwarg = self.get_format_suffix(**kwargs)\n\n    # Perform content negotiation and store the accepted info on the request\n    neg = self.perform_content_negotiation(request)\n    request.accepted_renderer, request.accepted_media_type = neg\n\n    # Determine the API version, if versioning is in use.\n    version, scheme = self.determine_version(request, *args, **kwargs)\n    request.version, request.versioning_scheme = version, scheme\n\n    # Ensure that the incoming request is permitted\n    self.perform_authentication(request)\n    self.check_permissions(request)\n    self.check_throttles(request)\n```\n\n1. perform\\_authentication\n2. check\\_permissions\n3. check\\_throttles\n\n### 1. perform\\_authentication\n\n이 함수를 실행하면 request.user를 하는데 `.user`는 getter이다. `_user`의 유무에 따라 `_authenticated`를 실행하거나 `_user`를 return한다.<br>\n`_authenticated`는 인증 클래스들을 가져와서\n\n### 2. check\\_permissions\n### 3. check\\_throttles\n"},"frontmatter":{"layout":"post","title":"Django / CBV에서 View, APIView는 어떻게 동작하는가?","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/django-performing-rqw-sql-queries.md","fields":{"slug":"/python/django/raw=queries/","categorySlug":"/categories/django/"},"internal":{"content":"며칠 전에 Django에서 제공하는 `multiple DB`를 사용했습니다.\n데이터를 가져오려고 하자 다음과 같은 에러가 발생했습니다.<br>\n`ProgramingError: Unknown column 'xxx.id' in 'field list'`<br>\n그 이유는 이렇습니다.\n> 장고는 우리가 pk를 설정하지 않아도 자동으로 id 필드를 생성합니다.\n> 우리는 복잡적인 키를 설정할 수 없습니다. 하지만 `unique_together`라는 트릭을 사용하면 장고가 id 필드가 있다고 인식하게 할 수 있습니다.\n> 데이터베이스에 id 필드가 존재하지 않기 때문에 에러를 발생시키지만, 장고는 트릭 덕분에 id 필드가 있다고 인식하는 겁니다.\n\n#### 그렇다면 어떤 방법을 사용해야할까\n\n방법은 raw queries를 사용해야 합니다.<br>\ndjango-docs를 살펴보면 raw SQL queries를 사용할 수 있는 2가지 방법을 제공한다고 합니다.\n1. Manager.raw()\n    - 인스턴스를 return\n2. execute custom SQL directly\n    - row를 여러 형태로 return 합니다 기본은 list\n\n저는 여기서 두번째 방법을 사용하려합니다. 그 이유를 설명하자면 이렇습니다.\n1. **일단 공식 문서에서 다중 데이터 베이스르 사용하면 `django.db.connections`를 통해서 db에 접근하는 것을 이야기하고 있습니다.**\n2. **Manager.raw()를 사용하면 해당하는 쿼리셋(정확히는 RawQuerySet)이 존재하는지 알 수 없습니다.**<br>\n> return하는 type이 `RawQuerySet`입니다. 제가 말하는 존재하는 지는 orm에서 exists()와 같은 것들 입니다.\n> 물론 전혀 방법이 없는 것은 아닙니다. len(list(RawQuerySet))과 같은 방법으로는 가능하지만 RawQuerySet의 갯수가 많을 경우에는 그 비용이 커서 효율적이라고 말할 수 없습니다.\n\n그렇다면 custom SQL을 사용하도록하겠습니다.\n\n```python\nfrom django.db import connections\n\nwith connections[\"default\"].cursor() as cursor:\n  cursor.execute(\"select * from products\")\n  row = cursor.fetchall()\n  print(row)\n```\n결과는 리스트 안의 튜플로 나오게 됩니다. 사용하기에는 참 불편해보입니다.\n```python\n[(id1, field1_value, field2_value....), (id2, field1_value, field2_value)...(idN, field1_value, field2_value)]\n```\n참고로 with connections[\"default\"]에서 `default`는 multipel db 세팅에서의 키값입니다.\n`connections.databases`를 찍으면 settings.py의 db 세팅을 볼 수 있습니다.\n동일한 방법으로 다른 db에 접근해서 가능하네요.<br>\n\n이번에는 사용하기 좋은 dict의 형태로 가공해보겠습니다.\n```python\nwith connections[\"daily_lab_db\"].cursor() as cursor:\n    cursor.execute(\"select * from tb_p2pnotice_header\")\n    desc = cursor.description\n    print(desc)\n```\n결과는\n```python\n[\n  ('companyNo', 3, None, None, None, None, 0, 20483),\n  ('companyName', 253, None, None, None, None, 0, 4225),\n  ('homepageUrl', 253, None, None, None, None, 0, 4225),\n  ('isAssociation', 1, None, None, None, None, 0, 1),\n  ('isMarketplace', 1, None, None, None, None, 0, 1),\n  ('isUse', 1, None, None, None, None, 0, 1),\n  ('hasError', 1, None, None, None, None, 0, 1)\n]\n```\ndict를 만들기 위해서 제가 필요한건 컬럼 이름입니다.\n```python\nwith connections[\"daily_lab_db\"].cursor() as cursor:\n    cursor.execute(\"select * from tb_p2pnotice_header\")\n    desc = cursor.description\n    columns = [col[0] for col in desc]\n    print(\n        [dict(zip(columns, row))\n        for row in cursor.fetchall()])\n```\n결과를 보자면\n```pyhon\n[{\"col1\": \"value1\"}, {\"col2\": \"value2\"}, ... {\"colN\": \"valueN\"}]\n```\nlist comprehension을 통해서 dict를 담은 리스트로 만들었습니다.<br>\n필요에 따라 함수로 만들어서 사용하면 더 좋을 것 같습니다.\n\n---\nref: [stack overflow](https://stackoverflow.com/questions/42968154/unknown-column-modelname-id-in-field-list)<br>\nref: [django-docs](https://docs.djangoproject.com/en/2.2/topics/db/sql/)\n"},"frontmatter":{"layout":"post","title":"Django / Django에서 orm이 아닌 raw SQL queries 사용하기","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/drf-difference-between-fbv-and-cbv.md","fields":{"slug":"/python/django/difference-fbv-cbv/","categorySlug":"/categories/django/"},"internal":{"content":"FBV = **Function Based View**<br>\nCBV = **Class Based View**<br>\n<br>\n- 클라이언트는url 주소를 통해서 서버에 request를 보내고, Django는 urls.py를 참고하여 해당 url에\n매핑된 뷰를 찾아 실행한다. 이때 실행되는 뷰의 종류에는 함수 기반 뷰(FBV)와 클래스 기반 뷰(CBV)가\n있다.\n- FBV와 CBV가 실행하는 것은 결국 함수이다. 자세한 내용은 아래에서 설명하겠다.\n\n<br>\nDjango가 동작하는 원리는 다음 게시물을 참고하길 바란다.<br>\n\n▶︎ [Django는 무엇이고 어떻게 일하는가](https://bmh8993.github.io/Django/what-is-django-and-how-to-it-works/)\n\n## 함수 기반 뷰(Function Based View)\n- django source code를 보면 FBV에서는 app.urls.py에서 `함수`를 호출하고 그 함수는\nrequest 객체를 받아서 각 메쏘드에 따라 처리한다.\n\n```python\n# app/views.py\nfrom django.http import HttpResponse, JsonResponse\n\n\ndef function_based_view(request):\n    if request.method == \"GET\":\n        content = \"...\"\n        return JsonResponse({\"content\": content})\n    if request.method == \"POST\":\n        ...\n        return HttpResponse(\"SUCCESS\")\n```\n\n```python\n# app/urls.py\nfrom django.urls import path\nfrom .views import function_view_name\n\nurlpatterns = [\n    path(\"view/url/\", function_view_name)\n]\n```\n\n### 장점\n- 함수로 정의하기에 읽기가 쉽고 클래스 기반 뷰보다 직관적이다\n- 작성하기가 쉽다\n\n### 단점\n- 확장과 재사용성이 클래스 기반 뷰에 비해서 강력하지 못하다\n\n## 클래스 기반 뷰(Class Based View)\n- django soruce code를 보면 CBV에서는 app.urls.py에서 클래스 메소드인\n`defined_view_class.as_view()`를 실행한다. `as_view`는 `view`함수를, `view`는 `dispatch`함수를\n호출하고, `dispatch`함수는 request.method를 확인하여 method별로 정의된 함수에 따라\nrequest를 처리한다.\n\n```python\n# app/views.py\nfrom django.http import JsonResponse, HttpResponse\nfrom django.views import View\n\n\nclass ClassBasedView(View):\n    def get(self, request):\n        content = \"...\"\n        return JsonResponse({\"content\": content})\n\n    def post(self, request):\n        ...\n        return HttpResponse(\"SUCCESS\")\n```\n\n```python\n# app/urls.py\nfrom django.urls import path\nfrom .views import ClassViewName\n\nurlpatterns = [\n    path(\"view/url/\", ClassViewName.as_view())\n]\n```\n\n### 장점\n- 코드를 확장하거나 재사용하기 쉽다.\n- mixin(다중 상속) 같은 객체지향 기술을 사용할 수 있다.\n- 내장 제네릭 클래스 기반 뷰\n\n### 단점\n- 읽기가 어렵다.\n- 직관적이지 않다.\n"},"frontmatter":{"layout":"post","title":"Django / FBV와 CBV의 차이","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/etc/algorithm/Algorithm:bubble sort.md","fields":{"slug":"/etc/algorithm/bubble-sort","categorySlug":"/categories/algorithm/"},"internal":{"content":"버블정렬에 대해서 알아봅시다.\n\n# 버블정렬의 핵심 IDEA\n\n1. 전체 elements의 개수가 n 이라면, 두 개씩 비교하게 되므로 loop의 범위를 n-1로 합니다.\n2. 비교가 끝나면 제일 큰 요소가 확정되는데, 확정된 요소를 제외하고 loop를 돌면됩니다.\n\n```python\nfor index in range(데이터 길이 - 1):  #✅1\n    for index_2 in range(데이터 길이 - loop 회수 - 1):  #✅2\n        if 앞 데이터 > 뒤 데이터:  #✅3\n            스왑  #✅4\n```\n\n> ✅1: 데이터길이-1 만큼 outer loop range를 지정한다.<br>\n> ✅2: i번 돌면 i개의 요소를 제외하고 inner loop를 진행하면 된다.<br>\n> ✅3: 조건 확인<br>\n> ✅4: swap<br>\n\n---\n\n# 추가 IDEA\n이미 정렬 되어져 있다면 = swap이 한 번도 발생하지 않았다면, 그 다음 loop를 진행하지 않아도 됩니다.<br>\n어떻게 알 수 있을까요? -> 상태를 확인하는 변수를 하나 만들자!\n\n---\n\n# 구현\n```python\ndef bubble_sort(data):\n    for i in range(len(data) - 1):\n        is_swaped = False\n        for j in range(len(data) - i - 1):\n            if data[j] > data[j + 1]:\n                data[j], data[j + 1] = data[j + 1], data[j]\n                is_swaped = True\n\n        if is_swaped is False:\n            break\n    return data\n```\n\n---\n\n# 결과\n```python\nimport random\n\ndata = random.sample(range(100),10)\nbubble_sort(data)\n\n# [3, 15, 17, 20, 28, 50, 55, 63, 70, 76]\n```\n\n## 시간 복잡도 계산\nloop 안에서 loop를 진행하므로 O(n<sup>2</sup>)<br>\n이미 정렬된 상태라면 O(n)\n"},"frontmatter":{"layout":"post","title":"Algorithm/버블 정렬(bubble sort with python)","category":"Algorithm","tags":["Algorithm","bubble-sort"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/network/About Http.md","fields":{"slug":"/cs/network/about-http/","categorySlug":"/categories/network/"},"internal":{"content":"\r\n##HTTP\r\nHyperText Transfer Protocol\r\n- 하이퍼텍스트(HTML) 문서를 교환하기 위해 만들어진 protocol(통신 규약).\r\n- 즉, HTML 문서를 주고 받을 때 원활한 소통을 위한 약속이다.\r\n    - 즉 웹상에서 네트워크로 서버끼리 통신을 할때 어떠한 형식으로 서로 통신을 하자고 규정해 놓은 \"통신 형식\" 혹은 \"통신 구조\" 라고 보면 된다.\r\n    - 프론트앤드 서버와 클라이언트간의 통신에 사용된다.\r\n    - 또한 백앤드와 프론트앤드 서버간에의 통신에도 사용된다.\r\n\r\n- HTTP는 TCP/IP 기반으로 되어있다.\r\n\r\n\r\n#HTTP 핵심요소\r\n\r\n##1. 통신 방식\r\n    - 기본적으로 request/respose 구조로 이루어져 있다.\r\n        - 클라이언트와 서버의 모든 통신이 요청과 응답으로 이루어 진다.\r\n    - HTTP는 Stateless 이다.\r\n        - 말그대로 상태를 저장하지 않는다.\r\n        - 예를 들어, 클라이언트가 요청을 보내고 응답을 받은 후, 조금 있다가 다시 요청을 보낼 때, 전에 보낸 요청/응답에 대해 알지 못한다.\r\n        - 그래서 만일 여러 요청과 응답의 진행 과정이나 데이터가 필요할 때는 쿠키나 세션 등등을 사용하게 된다.\r\n\r\n##2. HTTP request 구조\r\n\r\n```\r\n1. 메쏘드 URI HTTPversion\r\n2. Request Headers\r\n3.\r\n4.body\r\n```\r\n위와 같이 구조인데,<br>\r\n**첫째줄은 Start Line**<br>\r\n해당 request가 의도한 action/해당 request가 전송되는 목표 uri/사용되는 HTTP 버젼<br>\r\n**둘째줄은 headers**<br>\r\n해당 request에 대한 추가 정보를 담는부분이다.<br>\r\nKey:Value값으로 되어져 있다.<br>\r\nHOST: google.com => key = HOST, value = google.com<br>\r\n**셋째줄은 headers와 body를 구분**<br>\r\n**넷째줄은 body**<br>\r\n해당 request의 실제 메세지/내용\r\n```\r\n1.GET /index.html HTTP/1.1\r\n2.Host: bmh.kr\r\n3.Connection: keep-alive\r\n4.\r\n5.name=min&age=27\r\n```\r\n위의 request를 읽어보면,<br>\r\n`HTTP/1.1 버전`의 프로토콜로 `GET방식`으로 호스트가 `min.kr`인 곳의 /`index.html`을 가져와라.<br>\r\n가져오는데 `연결(connection)`은 `지속적(keep-alive)`인 방식으로 하며 `name`과 `age`라는 파라미터를 만들어서 각각 `min`과 27을 값으로 담아 같이 보내자.<br>\r\n\r\n**자주 사용되는 header 정보**<br>\r\n![headers_info](./img/headers_info.png)\r\n\r\n**Request Action**\r\n![request_method](./img/http_request_method.png)\r\n\r\n##3. HTTP request 구조\r\n```\r\n1. HTTP 버전 상태코드 설명\r\n2. Response Headers\r\n3.\r\n4.body\r\n```\r\n위와 같이 구조인데,<br>\r\n**첫째줄은 Status Line**<br>\r\n해당 response의 상태를 나타내주는데,<br>\r\nHHTP 버전/status code/status text<br>\r\n**둘째줄은 headers**<br>\r\nrequest의 header와 동일하다.<br>\r\n다만, response에서만 사용되는 header값들이 있다.<br>\r\n예를들어, `User-Agent`대신에 `Server`헤더가 사용된다.<br>\r\n**셋째줄은 headers와 body를 구분**<br>\r\n**넷째줄은 body**<br>\r\nrequest의 header와 동일하다.<br>\r\nrequest와 마찬가지로 모든 response가 body를 가지고 있지는 않다. 데이터를 전송할 필요가 없을 경우에는 body가 비어있게 된다.\r\n```\r\n1. HTTP/1.1 200 OK\r\n2. Date: Tue, 10 Jul 2012 06:50:15 GMT\r\n3. Content-Length:362\r\n4. Content-type:text/html\r\n5.\r\n6. <html>\r\n7. ...\r\n```\r\n위의 response를 읽어보면,<br>\r\n`HTTP/1.1 버전`의 프로토콜로 request에 대한 처리 결과는`200`이다. 다시말해 `OK`이다.<br>\r\n내가 전달할 메시지는 `2012년 7월 10일 화요일 6분 50분 15초`에 만들어 졌으며,<br>\r\n내용의 길이는 `362`이고 내용은 `text/html`타입이다.보낼 내용은 `<html>`...이다.\r\n<br>\r\n**자주 쓰이는 HTTP Status Code**<br>\r\n![http_status_code](./img/http_status_code.png)\r\n#그래서 왜 배우는데???\r\n##HTTP 메세지\r\nHHTP 메세지는 서버와 클라이언트 간에 데이터가 교환되는 방식이다.<br>\r\n**교환되는 방식이면서, 정보가 담겨있다. 우리는 이 정보를 처리해야하므로 HTTP가 중요하다.**<br>\r\n장고를 하면서 HTTP를 아는 것이 왜 중요한지 알게되었다.<br>\r\n공부할 것이 많다! REST API도 알아야한다!!!!!<br>\r\n이건 다음시간에\r\n"},"frontmatter":{"layout":"post","title":"About Http","category":"network","tags":["http"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/network/직렬화(serialisation)는 무엇인가.md","fields":{"slug":"/cs/network/serialization/","categorySlug":"/categories/network/"},"internal":{"content":"### 데이터 직렬화\n\n![](./image/serialization.png)\n\n**위키에서 설명하는 직렬화는 아래와 같습니다.**\n> 직렬화 또는 시리얼라이제이션(serialization)은 컴퓨터 과학의 데이터 스토리지 문맥에서 데이터 구조나 오브젝트 상태를 동일하거나 다른 컴퓨터 환경에 저장(이를테면 파일이나 메모리 버퍼에서, 또는 네트워크 연결 링크 간 전송)하고 나중에 재구성할 수 있는 포맷으로 변환하는 과정이다.<br>\n반대로, 일련의 바이트로부터 데이터 구조를 추출하는 일은 역직렬화 또는 디시리얼라이제이션(deserialization)이라고 한다.\n\nPC-**A**에서 구조체 데이터를 인터넷 너머에 있는 PC-**B**로 보낸다고 가정해봅시다. 네트워크 데이터는 연속된 바이트의 흐름일 뿐입니다. 따라서 구조체를 바이트 배열로 만들어야하는데, 이를 직렬화라고 합니다. 직선으로 쭉 나열한다 라는 의미로 보면 됩니다. 직렬화된 데이터를 받는 측에서는 사용하기 위해서 다시 구조체를 만들어야합니다. 이를 역직렬화라고 합니다.<br>\n<br>\n데이터를 직렬화 하고 역직렬화 하려면, 데이터 포맷을 알고 있어야 합니다. JSON, XML, YAML과 같은 문서 포맷이 주로 직렬화의 대상이 됩니다.<br>\n<br>\nIP, TCP, UDP는 네트워크를 가로지르는 메세지들의 데이터 타입이나, 의미를 찾을 수가 없습니다. 그저 단순한 바이트의 흐름으로 볼 뿐입니다. 따라서 응용 프로그램들은 바이트 흐름을 판독에 적합한 데이터로 `직렬화`하고, 반대로 바이트의 흐름으로 만들어주는 `비직렬화` 작업을 수행해야합니다.<br>\n<br>\n직렬화 되는 방법과 비직렬화 되는 방법이 `동일`해야 다른 환경과 데이터를 주고 받을 수 있습니다.\n"},"frontmatter":{"layout":"post","title":"직렬화(serialisation)는 무엇인가","category":"network","tags":["serialization"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/network/gRPC:gRPC가 등장하기까지(REST & RPC).md","fields":{"slug":"/cs/network/grpc-01/","categorySlug":"/categories/network/"},"internal":{"content":"gRPC를 공부하려고 많은 글들을 찾아보다가 네이버 클라우드 플랫폼 블로그에서 좋은 글을 찾아 하나씩 써내려가면서 정독해보겠습니다.좋은 글 감사합니다.\n\n# gRPC의 등장배경\n## 1. 아키텍처의 변화\n_**Monolithic >>> Microservice**_\n1970년대 IBM에서 개인용컴퓨터를 생산한 이후 PC라는 개념이 생겼고 하나의 메인 프레임 워크에서 동작하는 `Monolithic구조`로 설계되었습니다.\n시간이 흐르고 기술이 발전하면서 우리가 익히 알고있는 `Server-Client`의 구조를 가지게 되었고, 하나의 메인 프레임워크에서 프로그램이 동작하는 Monolithic 구조에서는 크게 중요하지 않았던 네트워크의 개념이 정리되기 시작합니다.\n\n그렇게 서버 간 혹은 서버와 개인 PC간 네트워크 연결/통신이 중요해지면서 IOS 7 layer, TCP/IP 등 네트워크 계층 구조가 정의되고 발전하기 시작합니다.\n\n## 2. RPC의 등장\n### IPC와 Socket\n실행되고 있는 컴퓨터 프로그램을 말하는 프로세스는 기본적으로 상호독립적입니다. 즉, 메모리를 공유하지않고 서로 간섭을 하지 않습니다. 하지만 필요에 따라 프로세스간 정보를 교환해야하는 경우가 있습니다. 이때 별도 수단을 이용하여 프로세스 간 통신하는 방법론을 IPC(Iner Process Communication)이라고 합니다.\n\nIPC기법에는 여러가지가 있지만 Socket에 대해서 살펴보겠습니다.\nSocket이란, 앞서 언급한 OSI 7 layer 구조의 L7계층(Application Layer)에서 L4계층(Transport Port)의 TCP 또는 UDP를 이용하기 위한 수단입니다. 일종의 창구라고 생각하면 됩니다. 우리는 온라인을 PC와 PC의 네트워크 통신이라고 알고 있지만, 조금 더 정확히 이야기하면 출발지 프로세스와 도착지 프로세스가 통신을 하는 IPC방법으로 통신한다고 이야기 하는게 정확합니다.\n\nSocket을 통해서 무언가를 개발 해 본 분들은 알겠지만 언어에서 지원해주는 API가 있어서 쉬운 것처럼 보이지만 client-server 통신과정을 직접구현해야하는 어려움을 가지고 있습니다. 통신 장애와 같은 많은 부분들이 개발자의 능력과 직결됩니다. 서비스가 고도화 될 수록 많은 데이터가 돌아다니게 될텐데, 이에 따라 data formatting을 하는 것도 점점 어려워지게 됩니다.\n\n### RPC\nsocket의 어려움을 극복하기 위해 RPC(Remote Procedure Call)라는 기술이 등장합니다. 이름 그대로 네트워크로 연결된 서버 상의 프로시저(함수, 메서드 등)를 원격으로 호출할 수 있는 기능입니다.\nRPC의 목적은 통신에 신경쓰지 않고, 원격지의 자원을 사용하는데에 있습니다.\n\n#### RPC에서 사용되는 개념\n- IDL(Interface Definication Laguage)\n: 서로 다른 언어로 작성된 여러 서비스들 사이에서 공통된 인터페이스를 정의하기 위한 중간 인터페이스 정의 언어\n- stub\n: 서버와 클라이언트는 서로 다른 주소 공간을 사용하므로, 함수 호출에 사용된 매개 변수를 꼭 변화해주어야 합니다. 그렇지 않으면 메모리 매개변수에 대한 포인터가 다른 데이터를 가리키게 됩니다. 이러한 변환을 담당하는게 stub입니다.\n\n> `client stub의 역할`\n함수 호출에 사용된 파라미터의 변환(Mashalling) 및 함수 실행 후 서버에서 전달 된 결과의 반환\n> `server stub의 역할`\n클라이언트가 전달한 매개 변수의 역변환(Unmashalling) 및 함수 실행 결과 변환을 담당\n\n#### RPC의 통신과정\n1. IDL(Interface Definition Language)을 사용하여 호출 규약을 정의합니다.\n함수명, 인자, 반환값에 대한 데이터형이 정의된 IDL 파일을 rpcgen으로 컴파일하면 stub code가 자동으로 생성됩니다.\n2. Stub Code에 명시된 함수는 원시코드의 형태로, 상세 기능은 server에서 구현됩니다.\n만들어진 stub 코드는 클라이언트/서버에 함께 빌드합니다.\n\n3. client에서 stub 에 정의된 함수를 사용할 때,\n4. client stub은 RPC runtime을 통해 함수 호출하고\n5. server는 수신된 procedure 호출에 대한 처리 후 결과 값을 반환합니다.\n6. 최종적으로 Client는 Server의 결과 값을 반환받고, 함수를 Local에 있는 것 처럼 사용할 수 있습니다.\n\n생각보다 통신과정이 복잡합니다. 많은 이점이 있지만 결국 구현이 어렵고, 지원 기능의 한계 등으로 제대로 활용되지 못했습니다. 그러다 Web을 활용해보려는 시도가 이어졌고 `REST`가 등장하게 됩니다\n\n## 3. REST의 등장\nREST(REpresentational State Transfer)는 HTTP/1.1을 기반으로 URI를 통해 모든 자원(Resource)을 명시하고 HTTP Method를 통해 처리하는 아키텍처입니다.\nHTTP Method와 payload의 합은 매우 명시적이고 쉽게 사용할 수 있다는 장점이 있어서 보편화된 방식입니다.\n하지만 REST에도 한계는 존재합니다.REST는 일종의 스타일이지 표준이 아니기 때문에 parameter와 응답 값이 명시적이지 않습니다. 또한 HTTP 메소드의 형태가 제한적이기 때문에 세부 기능 구현에는 제약이 있습니다.\n덧붙여 웹 데이터 전달 format으로 json을 많이 사용합니다. 간결한 `key-value` 구조를 기반으로 동작하고 사람이 읽기 좋은 string이기 때문입니다. 하지만 제공되는 자료형의 한계로 파싱 후 추가 형변환을 하는 작업이 필요한 경우가 많다는 점, string의 형태이기 때문에 데이터 통신/처리를 위한 serialize과정이 빠질 수 없다는 단점이 있습니다.\n\n# gRPC\ngRPC는 google사에서 개발한 오픈소스 RPC(Remote Procedure Call) 프레임워크입니다. 이전까지는 RPC 기능은 지원하지 않고, 메세지(JSON 등)을 Serialize할 수 있는 프레임워크인 PB(Protocol Buffer)만을 제공해왔는데, PB기반 Serializer에 HTTP/2를 결합하여 PRC 프레임워크를 탄생시켰습니다.\n\n**(HTTP/2와 PB에 대한 설명은 다른 포스트에서 설명하도록 하겠습니다)**\n\n여기까지가 gRPC가 탄생하게된 배경과 gRPC에 대한 소개입니다.\n다음 포스트에서는 gRPC에 대해 더 자세히 이야기하도록 하겠습니다.\n\n---\n참고: https://blog.naver.com/n_cloudplatform/221751268831\n"},"frontmatter":{"layout":"post","title":"gRPC/gRPC가 등장하기까지(REST & RPC)","category":"network","tags":["gRPC"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/db-sql/sql-큰-그림에서-작은-그림으로.md","fields":{"slug":"/cs/db-sql/sql-03/","categorySlug":"/categories/db-sql/"},"internal":{"content":"지난 포스트에서 설명한 내용을 가져오겠습니다.<br><br>\n\n`순위`는 `누적 대출액`을 기준으로 내림차순 정렬할 예정입니다. 순위는 없는 컬럼이므로 만들어야 할 것 같습니다.<br>\n`순위 변동`이라는 데이터는 말 그대로 변동을 나타내기 때문에 **오늘과 어제**처럼 차이가 필요합니다.<br>\n여기서 중요한 것은 `어제와 오늘` 테이블 `두 개`가 필요하고, 두 개의 테이블은 관계가 필요하다는 말이 됩니다.<br>\n`회사이름`, `누적 대출액`, `누적 상환액`은 Item 테이블에서 가져올 수 있는 데이터 입니다.<br>\n`순수 대출액`은 하나의 테이블, 예를 들면 오늘의 테이블 안에서 계산할 수 있는 데이터 입니다.<br><br>\n\n조건을 살펴보면 필터 조건이 있습니다. 그런데 문제가 있습니다.\n`Header`테이블과 `Item`테이블은 서로 전혀 다른 데이터를 가지고 있습니다.\n`Header`테이블은 조건을, `Item`테이블은 정보를 가지고 있습니다. 두 테이블의 연결고리는 `company_no`뿐입니다.\n\n---\n이해를 위해 `단계`라는 표현을 그림으로 표현했었는데 이제부터는 `단계`라고 표시하겠습니다.\n또한 `약속`을 하나 하자면 가장 상위 단계의 테이블을 `A`, 그 다음을 `B`, 그 다음을 `C`라고 표시하고\n같은 단계에서 존재하는 서로 다른 테이블은 `1, 2, 3..`과 같이 표시하겠습니다.<br>\n**이렇게 표시하는 점이 생각보다 중요합니다.** 하지만 약속일 뿐 스스로 정해도 좋습니다.<br>\n(SQL의 기본적인 부분은 학습이 되어져 있다고 가정하겠습니다.)\n\n---\n### A단계\n```sql\nSelect A1.순위, ifnull(A2.순위 - A1.순위, \"new\"), A1.회사 이름, A1.누적 대출액, A1.기타 데이터\nFrom 오늘 A1\nLeft Outer Join 어제 A2\nOn A1.companyNo = A2.companyNo\n```\n이렇게 제일 큰 단계의 쿼리가 완성 되었습니다.<br>\n`Inner Join`이 아닌 `Left Outer Join`을 한 이유는 어제는 없던 회사가 오늘 생겼을 수가 있기 때문입니다.\n- `Inner Join`은 `매칭 조건(On)`이 두 개의 테이블에 완전히 매칭되는 로우만 보여줍니다.\n- 하지만 `Left Outer Join`은 `매칭 조건(On)`을 기본으로 매칭하지만, 매칭되지 않는 로우도 `함께` 보여줍니다. 그래서 `ifnull`을 사용했습니다.\n\n나머지는 모두 오늘(A1)에서 가져올 수 있는 데이터 입니다. 다음 하위 단계(B)를 작성해보겠습니다.\n\n---\n### B단계\n```sql\nSelect B2.@num1:=@num1+1 as 순위, B1.회사 이름, B1.누적 대출액, B1.기타 데이터\nFrom 순위를 제외한 데이터를 가지고 있는 테이블 B1\nInner Join (Select @num1:=0) B2\nOn 1 = 1\nOrder By 정렬 조건(조건 2번 + 5번)\n```\n`B`단계의 쿼리로 `오늘(A1)`에 해당하는 쿼리입니다.<br>\n위에서 설명 했듯이 `순위`는 없는 컬럼입니다. 없는 컬럼은 `Inner Join`의 대상이 되는 테이블 안에서 변수를 통해 만들어줍니다.\n그리고 순위를 제외한 데이터를 가지고 있는 테이블과 `Join` 합니다. `Outer Join`도 무관해 보입니다. 어짜피 Join 조건은 없으니까요.<br>\n이후에 정렬을 진행합니다. 5번 조건에 해당하는 정렬은 Order By 뒤로 넣어줍니다.<br>\n<br>\n**여기서 잠깐, 오늘과 어제의 차이는 무엇일까요?**<br>\nB1에서 날짜 조건을 통해 차이가 생깁니다. 즉, B1과 B2는 구조가 동일하다는 이야기가 됩니다.\n다음 하위 단계(C)를 작성해보겠습니다.\n\n---\n### C단계\n```sql\nSelect C1.회사 이름, C2.누적 대출액, C2.기타 데이터\nFrom Header C1\nInner Join Item C2\nOn C1.companyNo = C2.companyNo\nWhere 데이터의 생성 날짜 = (D단계)(조건 4번)\nAnd C1.isUse = 1(조건 1번)\nAnd 추가 필터 조건(조건 3번)\nOrder By 정렬 조건(조건 2번 + 5번)\n```\n`오늘(A1)`에 해당하는 C단계 입니다.<br>\nB단계에서 회사 이름을 가져오고 여러 조건들을 통해 필터를 진행하기 위해서 `Inner Join`이 필요합니다.<br>\n거의 마지막 단계에서 필터 조건이나 정렬 조건이 사용됩니다.<br>\n마지막 D단계 입니다.\n\n---\n### D단계\n```sql\nSelect stdDate\nFrom Item\nWhere stdDate <= DATE_FORMAT(now(), \"%Y-%m-%d\")\nOrder By stdDate Desc\nLimin 0, 1\n```\nC단계의 Where에 들어갈 서브쿼리 입니다. 어제 날짜를 구하려면 `<=`가 아닌 `<`로 바꿔주시면 됩니다.<br>\n하나씩 차분히 하다보면 생각보다 어렵지 않습니다.<br>\n<br>\n전체 쿼리를 작성해보겠습니다.\n```sql\nSelect A1.순위, ifnull(A2.순위 - A1.순위, \"new\"), A1.회사 이름, A1.누적 대출액, A1.기타 데이터\nFrom (\n    Select B2.@num1:=@num1+1 as 순위, B1.회사 이름, B1.누적 대출액, B1.기타 데이터\n    From (\n      Select C1.회사 이름, C2.누적 대출액, C2.기타 데이터\n      From Header C1\n      Inner Join Item C2\n      On C1.companyNo = C2.companyNo\n      Where 데이터의 생성 날짜 = (\n        Select stdDate\n        From Item\n        Where stdDate <= DATE_FORMAT(now(), \"%Y-%m-%d\")\n        Order By stdDate Desc\n        Limin 0, 1\n        )\n      And C1.isUse = 1\n      And 추가 필터 조건\n      Order By 정렬 조건\n      ) B1\n    Inner Join (Select @num1:=0) B2\n    On 1 = 1\n    Order By 정렬 조건\n    ) A1\nLeft Outer Join (\n    Select B2.@num2:=@num2+1 as 순위, B1.회사 이름, B1.누적 대출액, B1.기타 데이터\n    From (\n      Select C1.회사 이름, C2.누적 대출액, C2.기타 데이터\n      From Header C1\n      Inner Join Item C2\n      On C1.companyNo = C2.companyNo\n      Where 데이터의 생성 날짜 = (\n        Select stdDate\n        From Item\n        Where stdDate < DATE_FORMAT(now(), \"%Y-%m-%d\")\n        Order By stdDate Desc\n        Limin 0, 1\n        )\n      And C1.isUse = 1\n      And 추가 필터 조건\n      Order By 정렬 조건\n      ) B1\n    Inner Join (Select @num2:=0) B2\n    On 1 = 1\n    Order By 정렬 조건\n    ) A2\nOn A1.companyNo = A2.companyNo\n```\n모두 합치기만 하면 됩니다.<br>\n이렇게 정리하고보니 생각보다 수월해보입니다. 여러 테이블을 가지고 연습하시면 좋을 것 같습니다.<br>\n기본서를 추천해 드리자면 `SQL 첫걸음`을 추천드립니다.<br>\n추천하는 이유는 일단 `mysql`을 베이스로 하고 있으며, 직접 다룰 수 있도록 예제 파일과 예제가 준비되어 있습니다.<br>\n\n### 지극히 주관적인 블로그를 읽어주셔서 감사합니다!\n"},"frontmatter":{"layout":"post","title":"SQL#03//sql 큰 그림에서 작은 그림으로","category":"DB&SQL","tags":["sql"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/db-sql/sql-짜기-전에-흐름을-파악하자..md","fields":{"slug":"/cs/db-sql/sql-01/","categorySlug":"/categories/db-sql/"},"internal":{"content":"sql이 아닌 django의 orm으로 데이터를 추출하는 것에 익숙한 저는\nraw query를 사용해야하는 일이 생겼습니다.\n```python\nfrom django.db import models\n\n\nclass Header(models.Model):\n    company_no = models.IntegerField(db_column='companyNo', primary_key=True)\n    company_name = models.CharField(db_column='companyName', max_length=100)\n    is_association = models.IntegerField(db_column='isAssociation')\n    is_use = models.IntegerField(db_column='isUse')\n\n    class Meta:\n        managed = False\n        db_table = 'header'\n\n\nclass Item(models.Model):\n    std_date = models.DateField(db_column='stdDate')\n    company_no = models.IntegerField(db_column='companyNo')\n    loan = models.BigIntegerField(blank=True, null=True)\n    repay = models.BigIntegerField(blank=True, null=True)\n    balance = models.BigIntegerField(blank=True, null=True)\n    profit_rate = models.DecimalField(db_column='profitRate', max_digits=5, decimal_places=2, blank=True, null=True)\n    loss_rate = models.DecimalField(db_column='lossRate', max_digits=5, decimal_places=2, blank=True, null=True)\n    overdue_rate = models.DecimalField(db_column='overdueRate', max_digits=5, decimal_places=2, blank=True, null=True)\n    company_std_date = models.DateField(db_column='companyStdDate', blank=True, null=True)\n    create_date = models.DateTimeField(db_column='createDate')\n    update_date = models.DateTimeField(db_column='updateDate')\n\n    class Meta:\n        managed = False\n        db_table = 'item'\n        unique_together = (('std_date', 'company_no'),)\n```\n위의 데이터 구조는 `inspectdb`를 통해서 자동으로 작성된 `models.py`입니다.<br>\n`Header`테이블은 새로운 회사가 유입되지 않는 이상 변화가 없습니다.<br>\n`Item`테이블은 매일 새로운 데이터로 업데이트 됩니다.\n\n####1편에서는 sql에 대한 설명은 아닙니다.\n\n저는 django의 orm을 통해서 데이터를 가져오는 것에 익숙했습니다.\n그런 상태로 sql을 접하니 알 것 같으면서 모르겠다고 느껴졌습니다.\n그 이유는 django의 `직관적인 orm` 때문이라고 생각됩니다.\norm을 사용하면서 어디서 어떤 조건으로 데이터를 가져와야 하는지 흐름을 이해했습니다. 예를 들면 `filter`와 같은 것이 있습니다.<br><br>\n하지만 sql은 where 조건을 사용하게 되는데 간단하게는 `true`나 `false`로, 더 나아가서는 서브쿼리로 조건을 사용하게 됩니다.\n서브쿼리가 보여지는 방식은 orm보다는 다소 불편합니다. 그래서 더 어렵게 보여졌다봅니다.<br><br>\n제가 이해하는 방식은 오로지 제 기준입니다. 나름 정리해 본 순서를 적어보겠습니다.\n\n### 1. 추출하고자 하는 데이터를 설정한다.\n이어질 포스트들을 한 가지 목표를 가지고 진행이 될 예정입니다.<br>\n제가 가져올 데이터들은 다음과 같습니다.\n\n1. 순위\n2. 순위 변동(기준일자와 기준일자의 하루 전데이터의 비교)\n3. 회사 이름\n4. 누적 대출액\n5. 기타 데이터\n\n### 2. 조건이 있다면 조건을 정리하고, 계산을 해야하는 데이터를 구분한다.\n두 번째로 할 일은 정리하는 시간을 갖는 겁니다.<br>\n\n- 조건을 먼저 정리해보겠습니다.\n  1. is\\_use = True\n  2. `누적 대출액`을 기준으로 내림차순 정렬을 진행합니다.\n  3. is\\_association의 값이 `True` or `False` 혹은 `True와 False 모두` 이렇게 첫번째 필터 조건이 있습니다.\n  4. 기준 일자를 설정합니다.\n  5. 기타 컬럼들로 정렬이 가능해야합니다.\n<br><br>\n- 다음으로는 계산을 해야하는 데이터를 구분합니다. 구분 할 때에는 두 가지로 분류합니다.\n\n  1. 새로운 컬럼을 만들어야하는 데이터\n        - 위의 예시에서 1번에 해당하는 것은 `순위`입니다.\n  2. 두개 이상의 테이블에서 계산이 이루어져서 만들어지는 데이터\n        - 2번에 해당하는 것은 `순위 변동`입니다. 순위 변동은 오늘의 데이터 테이블과 어제의 데이터 테이블에서 순위를 각각 가져와 계산을 해야합니다.\n\n\n### 3. 데이터 추출을 위해 테이블 간에 관계가 필요하다면 어떤 관계로 이루어 져야 할지 정리한다.\n세 번째는 테이블 간의 관계를 정하는 일입니다.<br>\n관계를 정리하고 큰 그림의 sql문을 작성합니다.\n\norm을 사용하면서 데이터를 가져오는 흐름에 익숙하신 분들은 조금만 생각해보시면\n금방 sql을 사용할 수 있으실거라 생각합니다.\n[다음 포스트](https://bmh8993.github.io/DATABASE&SQL/sql-%ED%81%B0-%EA%B7%B8%EB%A6%BC%EC%9D%84-%EA%B7%B8%EB%A0%A4%EB%B3%B4%EC%9E%90/) 로 이어집니다\n"},"frontmatter":{"layout":"post","title":"SQL#01//sql 짜기 전에 흐름을 파악하자","category":"DB&SQL","tags":["sql"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/db-sql/sql-최적화의-기본-원리.md","fields":{"slug":"/cs/db-sql/optimization/","categorySlug":"/categories/db-sql/"},"internal":{"content":"\n## 1. 옵티마이저와 실행계획\n\n### 1-1. 옵티마이저\n\n- 옵티마이저는 사용자가 질의한 SQL문에 대해 최적의 실행 방법을 결정하는 역할을 한다.\n- 이를 통해 개발자가 SQL이 동작하는 과정을 직접 코딩 할 필요가 없어졌다.\n- 이전에는 테이블을 기준 테이블을 select하고 fetch하고, 반대편 테이블에서 조인 레코드를\nseek하는 과정을 loop하는 이 과정을 직접 개발했어야했다.\n- DBMS의 핵심기능이다.\n\n#### 옵티마이저의 최적화 수행 단계를 요약하면 아래와 같다.\n\n1. 사용자가 던진 쿼리 수행을 위해 후보군이 될만한 실행계획들을 찾아냄\n2. 데이터 딕셔너리에 미리 수집해 놓은 오브젝트 통계 및 시스템 통계정보를 이용해\n각 실행 단계의 예상비용을 산정\n3. 각 실행계획의 비용을 비교해서 최소비용을 갖는 하나를 선택\n\n### 1-2. 실행 계획(Execution Plan)\n\n- **조인순서**: 논리적으로 가능한 순서는 n! 개\n- **조인 기법**: NL Join / Hash Join / Sort Merge Join\n- **액세스 기법**: 인덱스 스캔 / 전체 테이블 스캔\n- **최적화 정보**: 비용기반최적화-Cost / Card / Bytes (통계정보를 바탕으로 한 예상치)\n- **연산** : 조인기법, 액세스기법, 필터, 정렬(order by), 집계, 뷰 등 다양함\n\n## 2. 인덱스\n\n- **목적**: 검색 성능의 최적화\n- 인덱스는 테이블을 기반으로 선택적으로 생성할 수 있는 구조\n- 인덱스는 데이블에 생성하지 않아도 되고 여러 개 생성해도 된다.\n- 인덱스 칼럼 순서는 질의 성능에 중요한 영향을 미치는 요소이다.\n- 트리기반 인덱스에는 B-트리 인덱스, 비트맵 인덱스, 리버스 키 인덱스. 함수기반 인덱스 등 존재한다\n\n## 3. 조인수행원리\n\n- 두 개 이상의 테이블을 하나의 집합으로 만드는 연산을 조인이라고 한다.\n- FROM절에 두 개 이상의 테이블이 나열된 경우 조인이 수행된다.\n- 조인 단계별로 다른 조인 기법을 사용할 수 있다.\n\n---\n\nref: [SQL 최적화 기본원리 : 옵티마이저와 실행계획 / 인덱스 / 조인수행원리](https://m.blog.naver.com/0325han/221225506802)<br>\nref: [DBMS 아키텍처](https://cornswrold.tistory.com/120)<br>\nref: [SQL 파싱 처리 과정과 성능 향상 포인트 최적화!](https://jeong-pro.tistory.com/157)\n"},"frontmatter":{"layout":"post","title":"SQL 최적화의 기본 원리(옵티마이저와 실행계획/인덱스/조인수행원리)","category":"DB&SQL","tags":["database"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/db-sql/postgresql-db-backup(+스케줄-작업).md","fields":{"slug":"/cs/db-sql/postgresql-backup-restore/","categorySlug":"/categories/db-sql/"},"internal":{"content":"\n서버 배포 이후 매일 DB backup 파일일 만들어야 한다. CLI로 어떻게 진행이 가능한지 남기려한다.\n\n# Backup\n\nPostgreSQL에서는 DB Backup을 위해 pg\\_dump와 pg\\_dumpall 프로그램을 제공한다.\n\n1. dg\\_dump는 단일 Database를 요청한 Format으로 Bakup을 만든다.\n2. pg\\_dumpall는 전체 Database Cluster를 SQL script로 Backup 한다.\n\n해당 글에서는 pg\\_dump에 관해서만 다룰 예정이다. pg\\_dump의 사용 방법은 서버에서 `db_dump --help`를 입력하면 옵션에 대해 자세히 확인 가능하다.\n\n아래 옵션 및 인자들이 자주 사용하는 것들이다.\n```\n-d, --dbname : Backup할 Database 명.\n-h, --host : Database 주소.\n-U, --username : Database 접속 시 User ID\n-F, --format : Backup Format. 필자는 주로 tar 파일로 backup하기 때문에 't'를 사용한다.\n-f, --file : Backup File Name\n-t, --table : 특정 Table만 Backup하려할 때 대상이 되는 Table 명\n-j, --jobs : Backup 시 병렬 처리 여부와 그 정도.\n-v, --verbose : 진행 과정 표시.\n```\n\n### 사용 예\n\n- `holaplan` DB를 `tar` 형식으로\n- `/root/project/db_backup` 아래에\n- `특정이름`으로 backup\n\n```shell\n$ pg_dump -d {DB_이름} -h {DB_주소} -U {DB_유저} -F t > {위치와 이름}\n$ pg_dump -d holaplan -h xx.xx.xxx.xxx -U postgres -F t > /root/project/db_backup/test.tar\n```\n\n이렇게 하면 패스워드를 요구한다. 그래서 그냥 패스워드도 커맨드에 넣어버려야지 생각하고 옵션을 사용했으나 너무 많은 옵션이 사용되었다는 메세지를\n받았다.<br>\n그래서 찾아본 것이 `.pgpass`<br>\n\n### pgpass\n\npg\\_hba.conf에서 DB에 접근을 제한하도록 설정하면(접근할 때 패스워드를 요구하는 방식으로) postgres를 command line으로 로그인을 하려면 다음과\n같은 명령어를 사용해야한다.\n\n```shell\n$ psql -U {유저} -d {접근하려는 DB}\n$ psql -U postgres -d postgres\n```\n\n그리고 패스워드를 물어보면 패스워드를 입력하고 접근이 가능하다. 그러나 shell script를 사용하게 되면 위와 같은 문제를 비롯한 귀찮은 일들이\n발생한다. 이럴때 자동으로 로그인이 가능하도록 하는 것이 `.pgpass` 이다.\n\n#### 생성\n\n생성하는 위치는 root 디렉토리이다.\n\n```shell\n$ touch ~/.pgpass\n```\n안에 들어가는 내용은 다음과 같다.\n\n```shell\nhostname:port:database_name:user_name:password\n*:*:*:user_name:password\n```\n\n앞의 세가지는 \\*(와일드카드)를 사용하여 입력할 수 있다. 하지만 주의 할 부분이 있는데 db\\_name에 \\*를 사용하면 서버와 연결된 모든 DB를 대상으로\n하게 된다.<br>\n그래서 나는 db\\_name은 특정 db를 지정하도록한다.\n\n모두 작성하면 권한설정을 해준다.\n\n```shell\nchmod 600 ~/.pgpass\n```\n\n소유자에게 읽기와 쓰기권한을 부여하고 그룹소유자와 일반 사용자에게는 어떠한 권한도 부여하지 않겠다는 의미이다.\n\n# cronjob setting\n\ncronjob 리스트를 확인하고 `크론잡으로 등록`해주면된다.<br>\n\n```shell\n$ crontab -e  # 해당 옵션으로 등록된 크론탭리스트를 수정할 수 있다.\n```\n해당 파일에 크론을 등록해주도록 한다.\n\n기타 여러가지 방법이 있기다 pg\\_cron 이라는 extension도 존재한다. 하지만 하려는 작업에 적합하지 않은 것 같아서\n어느정도 읽어보고 넘어갔다.\n\n# Restore\n\npg\\_restore는 pg\\_dump를 이용해서 만들어진 DB backup file을 restore 할 때 사용한다.<br>\n단, pg\\_dumpall로 만들어진 backup file은 sql script라 pg\\_store를 사용할 수는 없다.<br>\n<br>\npg\\_restore의 사용 방법은 서버에서 `db_restore --help`를 입력하면 옵션에 대해 자세히 확인 가능하다.\n\n아래 옵션 및 인자들이 자주 사용하는 것들이다.\n```\n-d, --dbname : Restore하는 Database 명.\n-h, --host : Database 주소.\n-U, --username : Database 접속 시 User ID\n-F, --format : Restore File의 Format.\n-t, --table : 특정 Table만 Restore하려할 때 대상이 되는 Table 명\n-j, --jobs : Restore 시 병렬 처리 여부와 그 정도.\n-v, --verbose : 진행 과정 표시\n-C, --create : Target DB를 새로 만들면서 Restoration 진행.\n-c, --clean : Restoration 시에 같은 이름의 Database Object가 발견되면 Drop 후에 Create하게 함.\n-O, --no-owner : 원본 DB의 Owner가 복구할 위치에 존재하지 않을 경우 복구 시 다량의 에러가 발생한다. 이를 막기 위해  DB 복구시 OWNER를 명시하지 않고 진행하게 함.\n```\n\n#### TAG\n\n`postgres`, `cronjob`, `linux-permission`, `pgpass`, `pg_hba`\n\n---\n\nREF: [PostgreSQL DB Backup 및 Restore](https://browndwarf.tistory.com/12)<br>\nREF: [An Overview of Job Scheduling Tools for PostgreSQL(cronjob 설정하기)](https://severalnines.com/database-blog/overview-job-scheduling-tools-postgresql)<br>\nREF: [PostgreSQL Job Scheduler](https://sqlbackupandftp.com/blog/postgresql-job-scheduler)<br>\nREF: [리눅스 퍼미션 chmod 600](https://securityspecialist.tistory.com/40)<br>\nREF: [pgpass stack-overflow](https://stackoverflow.com/questions/50404041/pg-dumpall-without-prompting-password)<br>\nREF: [how to use cron](https://www.cyberciti.biz/faq/how-do-i-add-jobs-to-cron-under-linux-or-unix-oses/)\n\n---\n\n#### 추가 사항\n\n### 리눅스 tar.gz\n\n리눅스(Linux)에서의 파일 압축 개념은 윈도우즈(Windows)에서의 파일 압축 개념에 비해 세분화 되어있다.\n윈도우즈에서는 보통 압축을 한다하면, zip 등의 방식으로 선택된 파일이나 폴더들을 묶으면서 동시에 압축(compress)을 하는 것을 의미한다.\n`반면` 리눅스에서는 파일이나 폴더들을 묶는 것(archive)과 실제로 압축(compress)하는 기능이 나뉘어져있다.\n\n- 묶는다 = archive\n- 압축한다 = compress\n\n리눅스에서 여러 파일을 한 파일로 묶은 것을 아카이브(archive)라 하며 확장자는 `.tar` 이다.<br>\n일반적으로 tar로 묶인 아카이브를 gunzip을 사용해서 .tar.gz 의 확장자를 가지는 압축 아카이브로 많이 사용한다.\n\nREF: [리눅스 tar.gz와 압축/해제 명령어](http://sarghis.com/blog/468/)<br>\nREF: [왜 단일 파일을 tar합니까?](https://qastack.kr/unix/277793/why-would-i-tar-a-single-file)\n"},"frontmatter":{"layout":"post","title":"Postgresql DB backup / restore(+스케줄 작업)","category":"DB&SQL","tags":["postgresql"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/db-sql/sql-큰-그림을-그려보자.md","fields":{"slug":"/cs/db-sql/sql-02/","categorySlug":"/categories/db-sql/"},"internal":{"content":"지난 포스트에서 설명한 것을 제목만 나열해 보겠습니다.\n\n#### 1. 추출하고자 하는 데이터를 설정한다.\n#### 2. 조건이 있다면 조건을 정리하고, 계산을 해야하는 데이터를 구분한다.\n#### 3. 데이터 추출을 위해 테이블 간에 관계가 필요하다면 어떤 관게로 이루어 져야 할지 정리한다.\n\n---\n\n큰 흐름은 이렇습니다. 1번과 2번은 [지난 포스트](https://bmh8993.github.io/DATABASE&SQL/sql-%EC%A7%9C%EA%B8%B0-%EC%A0%84%EC%97%90-%ED%9D%90%EB%A6%84%EC%9D%84-%ED%8C%8C%EC%95%85%ED%95%98%EC%9E%90./)에서 예시로 정리를 했으니 넘어가도록 하겠습니다.<br><br>\n먼저 추출하고자 하는 데이터와 조건들을 살펴보겠습니다.<br>\n\n- **가져오고자 하는 데이터**\n    1. 순위\n    2. 순위 변동(기준일자와 기준일자의 하루 전데이터의 비교)\n    3. 회사 이름\n    4. 누적 대출액\n    5. 기타 데이터\n\n- **조건**\n    1. is\\_use = True\n    2. `누적 대출액`을 기준으로 내림차순 정렬을 진행합니다.\n    3. is\\_association의 값이 `True` or `False` 혹은 `True와 False 모두` 이렇게 첫번째 필터 조건이 있습니다.\n    4. 기준 일자를 설정합니다.\n    5. 기타 컬럼들로 정렬이 가능해야합니다.\n\n---\n정리한 내용을 가지고 하나씩 살펴보겠습니다.<br>\n5번 조건을 잠시 제외하고 생각하겠습니다.<br>\n`순위`는 `누적 대출액`을 기준으로 내림차순 정렬할 예정입니다. 순위는 없는 컬럼이므로 만들어야 할 것 같습니다.<br>\n`순위 변동`이라는 데이터는 말 그대로 변동을 나타내기 때문에 **오늘과 어제**처럼 차이가 필요합니다.\n여기서 중요한 것은 `어제와 오늘` 테이블 `두 개`가 필요하고, 두 개의 테이블은 관계가 필요하다는 말이 됩니다.<br>\n`회사이름`, `누적 대출액`, `기타 데이터`는 Item 테이블에서 가져올 수 있는 데이터 입니다.<br>\n\n조건을 살펴보면 필터 조건이 있습니다. 그런데 문제가 있습니다.\n`Header`테이블과 `Item`테이블은 서로 전혀 다른 데이터를 가지고 있습니다.\n`Header`테이블은 조건을, `Item`테이블은 정보를 가지고 있습니다. 두 테이블의 연결고리는 `company_no`뿐입니다.\n\n---\n일단 이 이렇게 큰 그림을 그려보는 것이 중요합니다. 이 정리한 내용을 가지고 SQL을 작성해보겠습니다.\n[다음 포스트](https://bmh8993.github.io/DATABASE&SQL/sql-%ED%81%B0-%EA%B7%B8%EB%A6%BC%EC%97%90%EC%84%9C-%EC%9E%91%EC%9D%80-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C/)로 이어집니다.\n"},"frontmatter":{"layout":"post","title":"SQL#02//sql 큰 그림을 그려보자","category":"DB&SQL","tags":["sql"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/Django:select_related와 prefetch_related를.md","fields":{"slug":"/python/django/select-related-and-prefetch_related/","categorySlug":"/categories/django/"},"internal":{"content":"select_related와 prefetch_related를 알아봅시다.\n\n\nDjango의 유저라면 select\\_related와 prefetch\\_related를 모를 수 없을 것입니다. 하지만 얼마나 잘\n사용하고 있는지는 의문점을 가져봐야 합니다. 저 또한 그런 의문이 들었기에 이번 포스트를 작성하게\n되었습니다.<br>\n<br>\n설명을 위한 모델은 다음과 같습니다.\n\n```python\n# app/models.py\n\nfrom django.db import models\n\n\nclass Publisher(models.Model):\n    name = models.CharField(max_length=255)\n\n    def __str__(self):\n        return self.name\n\n\nclass Book(models.Model):\n    name = models.CharField(max_length=255)\n    price = models.IntegerField(default=0)\n    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE, related_name='books')\n\n    def __str__(self):\n        return self.name\n\n\nclass Store(models.Model):\n    name = models.CharField(max_length=255)\n    books = models.ManyToManyField(Book, related_name='stores')\n\n    def __str__(self):\n        return self.name\n```\n\n설명을 위한 데이터를 다음 조건에 맞춰서 만들 것입니다.<br>\n<br>\n100개의 book이 있고, 5개의 publisher는 각 publisher당 20개씩 출판했습니다. 그리고\n10개의 매장에서 10개씩 판매중 입니다. custom command를 통해서 데이터를 insert 할 예정입니다.\n`python manage.py insert`\n\n```python\n# app/management/commands/insert.py\n\nimport random\n\nfrom django.core.management.base import BaseCommand\n\nfrom ...models import Publisher, Store, Book\n\n\nclass Command(BaseCommand):\n    \"\"\"\n    이 커맨드는 5개의 Publisher, 100개의 books와 10개의 Stores를 DB에 insert합니다.\n    \"\"\"\n\n    def handle(self, *args, **options):\n        Publisher.objects.all().delete()\n        Book.objects.all().delete()\n        Store.objects.all().delete()\n\n        # create 5 publishers\n        publishers = [Publisher(name=f\"Publisher{index}\") for index in range(1, 6)]\n        Publisher.objects.bulk_create(publishers)\n\n        # create 20 books for every publishers\n        counter = 0\n        books = []\n        for publisher in Publisher.objects.all():\n            for i in range(20):\n                counter = counter + 1\n                books.append(Book(name=f\"Book{counter}\", price=random.randint(50, 300), publisher=publisher))\n\n        Book.objects.bulk_create(books)\n\n        # create 10 stores and insert 10 books in every store\n        books = list(Book.objects.all())\n        for i in range(10):\n            temp_books = [books.pop(0) for i in range(10)]\n            store = Store.objects.create(name=f\"Store{i+1}\")\n            store.books.set(temp_books)\n            store.save()\n```\n\n그리고 보기 좋게 정리하기 위한 데코레이터를 작성합니다.\n```python\nimport time\nimport functools\n\nfrom django.db import connection, reset_queries\n\n\ndef query_debugger(func):\n\n    @functools.wraps(func)\n    def inner_func(*args, **kwargs):\n\n        reset_queries()\n\n        start_queries = len(connection.queries)\n\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        end = time.perf_counter()\n\n        end_queries = len(connection.queries)\n\n        print(f\"Function : {func.__name__}\")\n        print(f\"Number of Queries : {end_queries - start_queries}\")\n        print(f\"Finished in : {(end - start):.2f}s\")\n        return result\n\n    return inner_func\n```\n\n\n\n# select\\_related\n`select_related`는 관련된 단일객체를 가져오는데, 정참조일 때에는 `ForeignKey, OneToOne`, 역참조 일때에는 `OneToOne`일 때에 사용합니다.<br>\n<br>\n`select_related`를 SQL로 풀어보면 `Inner Join`을 하여 관련 개체의 필드를 `Select` 문에 포함시켜서 관련 개체를 얻습니다.\n\n## bad\n\n```python\nfrom query_debugger import query_debugger\n\n@query_debugger\ndef book_list():\n\n    queryset = Book.objects.all()\n\n    books = []\n    for book in queryset:  # queryset 평가\n        books.append({\n            'id': book.id,\n            'name': book.name,\n            'publisher': book.publisher.name\n            }\n        )\n    # book.publisher에 접근, 캐싱되지 않은 데이터이므로 query 발생\n\n    return books\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : book_list\nNumber of Queries : 101\nFinished in : 0.05s\n```\n\n하나의 쿼리가 모든 책에 접근하고 반복하는 동안 ForeignKey로 연결된 `Publisher`에 각각 접근하여 쿼리가 실행됩니다.<br>\n<br>\n실제로 sql을 보면\n\n1. book에 접근하는 쿼리 1\n2. book에 해당하는 publisher에 접근하는 쿼리 100개\n\n`총 101개`의 쿼리가 실행됩니다.\n\n## good\n\n`select_related`를 사용해서 결과를 확인해 봅시다.\n\n```python\n@query_debugger\ndef book_list():\n\n    queryset = Book.objects.select_related(\"publisher\").all()\n\n    books = []\n    for book in queryset:  # queryset 평가\n        books.append({\n            'id': book.id,\n            'name': book.name,\n            'publisher': book.publisher.name\n            }\n        )\n\n    return books\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : book_list\nNumber of Queries : 1\nFinished in : 0.00s\n```\n\nPublisher를 Inner Join으로 하나의 쿼리로 가져온결과, 101개 에서 1개로 쿼리가 줄었습니다!\n\n# 정참조에서의 prefetch\\_related(ManyToMany)\n\n## Example1\n`prefetch_related`는 두개의 테이블을 가져와서 **Python에서 Join을 합니다.**\n정참조일 때에는 `ManyToMany` 역참조일 때에는 `ForeignKey, ManyToMany`일 때에 사용합니다.<br>\n\n## bad\n\n```python\n@query_debugger\ndef store_list():\n\n    queryset = Store.objects.all()\n\n    stores = []\n    for store in queryset:  # 쿼리셋 평가\n        books = [book.name for book in store.books.all()]  # 각 store마다 books로 접근, 쿼리 발생\n        stores.append({\n            'id': store.id,\n            'name': store.name,\n            'books': books\n            }\n        )\n\n    return stores\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : store_list\nNumber of Queries : 11\nFinished in : 0.01s\n```\n\nSQL은 다음과 같습니다.\n\n```sql\nSELECT \"bookstore_store\".\"id\", \"bookstore_store\".\"name\"\nFROM \"bookstore_store\"\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE \"bookstore_store_books\".\"store_id\" = 1\n\n...\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE \"bookstore_store_books\".\"store_id\" = 10\n```\n\n데이터베이스 내에는 10개의 상점이 있고 각각 10권의 책을 가지고 있습니다. 쿼리가 어떻게 되었는지 살펴보면\n일단 하나의 쿼리로 모든 상점들을 fetch해오고 반복문을 돌면서 하나의 상점에서 각각 쿼리를 발생시켜 books에 접근을 했습니다.\n그래서 1 + 10 과같은 결과를 가져온 것입니다.\n\n## good\n\n`prefetch_related`를 사용하여 결과를 살펴봅시다\n\n```python\n@query_debugger\ndef store_list():\n\n    queryset = Store.objects.prefetch_related(\"books\").all()\n\n    stores = []\n    for store in queryset:\n        books = [book.name for book in store.books.all()]\n        stores.append({'id': store.id, 'name': store.name, 'books': books})\n\n    return stores\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : store_list\nNumber of Queries : 2\nFinished in : 0.01s\n```\n\nSQL은 다음과 같습니다.\n\n`prefetch_related`를 사용한 결과는 SQL을 살펴보면 조금 더 빠르게 이해할 수 있을 것 같습니다.\n\n```sql\nSELECT \"bookstore_store\".\"id\", \"bookstore_store\".\"name\"\nFROM \"bookstore_store\"\n\nSELECT (\"bookstore_store_books\".\"store_id\") AS \"_prefetch_related_val_store_id\", \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE \"bookstore_store_books\".\"store_id\"\nIN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)'\n```\n\n`prefetch_related`를 사용하지 않았을 때와 다른 점은 두번째 쿼리에서 store의 id 값들을 가져와서 In을 사용한다는 것입니다. 이것을 통해서 여러번\n매칭 하였던 것을 한 번으로 줄여서 1 + 1과 같은 결과를 가져왔습니다.\n\n## Example2\n\n이번에는 필터를 사용한 결과를 살펴봅시다.\n\n## bad\n\n```python\n@query_debugger\ndef store_list():\n\n    queryset = Store.objects.prefetch_related(\"books\").all()\n\n    stores = []\n    for store in queryset:\n        books = [book.name for book in store.books.filter(price__range=(250,300))]\n        stores.append({'id': store.id, 'name': store.name, 'books': books})\n\n    return stores\n```\n\n결과는 다음과 같습니다\n\n```\nFunction : store_list\nNumber of Queries : 12\nFinished in : 0.01s\n```\n\nSQL은 다음과 같습니다\n\n```sql\nSELECT \"bookstore_store\".\"id\", \"bookstore_store\".\"name\"\nFROM \"bookstore_store\"\n\nSELECT (\"bookstore_store_books\".\"store_id\") AS \"_prefetch_related_val_store_id\", \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE \"bookstore_store_books\".\"store_id\" IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)'\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE (\"bookstore_store_books\".\"store_id\" = 1 AND \"bookstore_book\".\"price\" BETWEEN 250 AND 300)\n\n...\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE (\"bookstore_store_books\".\"store_id\" = 10 AND \"bookstore_book\".\"price\" BETWEEN 250 AND 300)\n```\n\n조건이 추가되자 조건을 필터링하는 구문을 포함한 쿼리가 추가로 실행되었습니다.\n1 + 1 + 10 총 12개의 쿼리가 발생했습니다.\n\n## good\n\nPrefetch를 사용하여 다시 작성해보도록 합시다\n\n```python\n@query_debugger\ndef store_list():\n\n    queryset = Store.objects.prefetch_related(\n        Prefetch(\"books\", queryset=Book.objects.filter(price__range=(250, 300))))\n\n    stores = []\n    for store in queryset:\n        books = [book.name for book in store.books.all()]\n        stores.append({'id': store.id, 'name': store.name, 'books': books})\n\n    return stores\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : store_list\nNumber of Queries : 2\nFinished in : 0.00s\n```\n\nSQL은 다음과 같습니다.\n\n```sql\nSELECT \"bookstore_store\".\"id\", \"bookstore_store\".\"name\"\nFROM \"bookstore_store\"\n\nSELECT (\"bookstore_store_books\".\"store_id\") AS \"_prefetch_related_val_store_id\", \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE (\"bookstore_book\".\"price\" BETWEEN 250 AND 300 AND \"bookstore_store_books\".\"store_id\" IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n```\n\nPrefetch를 사용하니까 별도의 쿼리를 작성했던 WHERE를 AND로 묶어서 하나의 쿼리를 생성했습니다.\n\n# 역참조에서의 prefetch\\_related\n\n## Example1\n\n**부모와 관련된 자식 데이터를 가져올 때**<br>\n<br>\n이번에는 역참조입니다. 지금까지 사용한 관계에서 예를 들면 Publisher가 출간한 book들을 조회할 때에 사용할 수 있습니다.\n\n## bad\n\n```python\n@query_debugger\ndef publisher_list():\n\n    queryset = Publisher.objects.all()\n\n    publishers = []\n    for publisher in queryset:\n        books = [book.name for book in publisher.books.all()]\n        publishers.append({'id': publisher.id, 'name': publisher.name, 'books': books})\n\n    return publishers\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : publisher_list\nNumber of Queries : 6\nFinished in : 0.00s\n```\n\nSQL은 다음과 같습니다.\n\n```sql\nSELECT \"bookstore_publisher\".\"id\", \"bookstore_publisher\".\"name\"\nFROM \"bookstore_publisher\"\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nWHERE \"bookstore_book\".\"publisher_id\" = 1\n\n...\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nWHERE \"bookstore_book\".\"publisher_id\" = 5\n```\n\n일단 Publisher를 가져오는 쿼리 1개, book중에서 publisher의 id와 동일한 book을 가져오는 쿼리 5개(1~5까지)\n총 6개입니다.\n\n## good\n\n역참조에서 `prefetch_related`를 사용해봅시다.\n\n```python\n@query_debugger\ndef publisher_list():\n\n    queryset = Publisher.objects.prefetch_related(\"books\")\n\n    publishers = []\n    for publisher in queryset:\n        books = [book.name for book in publisher.books.all()]\n        publishers.append({'id': publisher.id, 'name': publisher.name, 'books': books})\n\n    return publishers\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : publisher_list\nNumber of Queries : 2\nFinished in : 0.00s\n```\n\nSQL은 다음과 같습니다.\n\n```sql\nSELECT \"bookstore_publisher\".\"id\", \"bookstore_publisher\".\"name\"\nFROM \"bookstore_publisher\"\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nWHERE \"bookstore_book\".\"publisher_id\" IN (1, 2, 3, 4, 5)\n```\n\n동일하게 Publisher를 가져오는 쿼리 1개, 위 와다르게 book에 WHERE ~ IN을 사용한 쿼리 1개로 총 2개가 되었습니다.\n\n## Example2\n\n**자식 테이블에 조건을 걸어서 조건에 해당하는 부모객체를 가져올 때**<br>\n<br>\n250~300에 출간한 책들을 가지고 있는 출판사 데이터를 가져와봅시다. 배운바에 의하면 역참조를 위해\n`prefetch_related`를 사용하고 필터를 걸어야합니다.\n\n## bad\n\n```python\n@query_debugger\ndef publisher_list():\n\n    queryset = Publisher.objects.prefetch_related(\"books\").filter(books__price__range=(250,3 00))\n\n    publishers = []\n    for publisher in queryset:\n        publishers.append({'id': publisher.id, 'name': publisher.name})\n\n    return publishers\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : publisher_list\nNumber of Queries : 2\nFinished in : 0.01s\n```\n\nSQL 다음과 같습니다.\n- 첫번째 SQL은 publisher에 book을 inner join 해서 가져옵니다. 그리고\n그 book의 조건은 250~300사이의 가격을 형성하고 있다는 것 입니다. 해당하는 publisher들을 가져옵니다.\n- 두번째 SLQ은 book을 가져오는데 여기서 in 조건에 들어간 id들은 첫번째 sql에서 나온 결과에 해당하는\npublisher의 id입니다. 해당 publisher에게 속해있는 모든 책들을 가져옵니다.\n\n```sql\nSELECT \"bookstore_publisher\".\"id\", \"bookstore_publisher\".\"name\"\nFROM \"bookstore_publisher\"\nINNER JOIN \"bookstore_book\"\nON (\"bookstore_publisher\".\"id\" = \"bookstore_book\".\"publisher_id\")\nWHERE \"bookstore_book\".\"price\" BETWEEN 250 AND 300\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nWHERE \"bookstore_book\".\"publisher_id\" IN (1, 2, 4, 5)\n```\n\n## good\n\n```python\n@query_debugger\ndef publisher_list():\n\n    queryset = Publisher.objects.filter(books__price__range=(250,300))\n\n    publishers = []\n    for publisher in queryset:\n        publishers.append({'id': publisher.id, 'name': publisher.name})\n\n    return publishers\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : publisher_list\nNumber of Queries : 1\nFinished in : 0.00s\n```\n\nsql을 살펴보면 이전의 첫번째 sql과 동일합니다. 어떻게 된 일일까요\n\n```sql\nSELECT `bookstore_publisher`.`id`, `bookstore_publisher`.`name`\nFROM `bookstore_publisher`\nINNER JOIN `bookstore_book`\nON (`bookstore_publisher`.`id` = `bookstore_book`.`publisher_id`)\nWHERE `bookstore_book`.`price` BETWEEN 250 AND 300\n```\n\ndjango의 query 소스코드를 봅시다.\n\n```python\ndef demote_joins(self, aliases):\n    \"\"\"\n    Change join type from LOUTER to INNER for all joins in aliases.\n\n    Similarly to promote_joins(), this method must ensure no join chains\n    containing first an outer, then an inner join are generated. If we\n    are demoting b->c join in chain a LOUTER b LOUTER c then we must\n    demote a->b automatically, or otherwise the demotion of b->c doesn't\n    actually change anything in the query results. .\n    \"\"\"\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type == LOUTER:\n            self.alias_map[alias] = self.alias_map[alias].demote()\n            parent_alias = self.alias_map[alias].parent_alias\n            if self.alias_map[parent_alias].join_type == INNER:\n                aliases.append(parent_alias)\n```\n\n소스 코드를 보면 chain join이 없으면 inner join으로 쿼리를 하도록 강제하고 있기 때문입니다.<br>\n<br>\n많은 블로그 내용들을 하나로 모아보았습니다. 귀한 내용을 공유해주신 개발자님들께 다시한번 감사를 드립니다.\n\n---\n\nref: [Django 나만의 Management Command 만들어보기](https://blog.myungseokang.dev/posts/make-django-custom-command/)<br>\nref: [Python decorator에 @wraps를 사용해야 하는 이유](https://cjh5414.github.io/wraps-with-decorator/)<br>\nref: [Django select_related and prefetch_related](https://medium.com/better-programming/django-select-related-and-prefetch-related-f23043fd635d)<br>\nref: [당신이 몰랐던 Django Prefetch.](https://medium.com/chrisjune-13837/%EB%8B%B9%EC%8B%A0%EC%9D%B4-%EB%AA%B0%EB%9E%90%EB%8D%98-django-prefetch-5d7dd0bd7e15)\n"},"frontmatter":{"layout":"post","title":"Django/select_related와 prefetch_related를 정복해보자","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/database-access-optimization.md","fields":{"slug":"/python/django/database-optimization/","categorySlug":"/categories/django/"},"internal":{"content":"\nDjango를 사용하다보면 DB 최적화를 자연스럽게 접하게 된다. 알고는 있지만 정리가 안된 내용을\n이번 블로깅을 통해 진행해보려한다.\n<br>\n얼마전부터 `django-debug-toolbar`를 사용하여 프로젝트의 쿼리를 최적화하기 시작했다.\n나름 고민하며 ORM을 작성했다고 생각했는데 여전히 중복되거나 최적화를 필요로하는 부분이 많았다.\n어찌보면 대략적으로, 그저 표면적으로만 알고있는 지식을 통해 최적화를 진행했다고 생각하여\n공식문서를 바탕으로 이런 글을 쓰게 되었다.\n\n## 1. 기본적으로 제공하는 DB 최적화 기술을 사용해라\n\n이 부분은 SQL 최적화 기본 원리를 알아야하는데 [다음 포스트](https://bmh8993.github.io/SQL/sql-최적화의-기본-원리/)를 참고하기를 바란다.\n즉, 기본적인 DB 최적화를 먼저 해야한다는 이야기이다.\n\n- 1-1. 인덱싱\n> 인덱싱은 최우선적으로 고려되는 부분이다. Field의 옵션으로 `db_index=True`를 세팅하면된다.\n혹은 Meta class에 `indexes`를 추가한다. 두 옵션의 동작은 동일하다. 추가하게되면 검색속도를\n높일 수 있다.<br>\n<br>\n그렇다면 어떤 필드에 추가해야할까. `filter()`, `exclude()`, `order_by()`를 자주 쿼리하는 필드에\n추가하도록하자\n\n<br>\n\n- 1-2. 적절한 필드타입 사용하기\n\n## 2. QuerySets 이해하기\n\n#### *쿼리셋을 이해하는 것은 좋은 퍼포먼스를 만들어낼 때 매우 중요하다.*\n\nQuerySet에 대한 내용은 [다음 포스트](https://kimdoky.github.io/django/2020/02/03/django-queryset-api/)를 참고하기를 바란다.\n\n### 2-1. 쿼리셋 평가 이해하기\n\n- 쿼리셋은 매우 게으르다.\n    - 코드로 queryset을 생성하는 작업은 DB에 아무런 작업을 하지 않는다. DB의 query는 실제로\n    queryset이 결과값이 평가되기 전까지 실행되지 않는다. 예를들어 filter를 아무리 많이\n    하더라도 DB query는 일어나지 않는다.\n\n- 쿼리셋 평가되는 시점\n    - 반복, 슬라이싱, Pickling/Caching, repr(), len(), list(), bool()\n\n- 데이터를 메모리에 저장하는 방법\n    - 각 queryset에는 데이터베이스 접근을 최소화하기 위한 cache를 포함하고 있다.\n        1. 새로운 queryset을 만들면 cache는 비어있는 상태이다.\n        2. 데이터베이스 쿼리가 발생해서 쿼리셋이 평가되는데, Django는 query 결과를 queryset의 캐시에 저장한다. 그리고 요청사항에 따른 결과를 리턴한다.\n    - 해당 queryset을 재사용하면 캐시된 결과를 가져와서 사용한다.\n\n#### *Cache 활성화*\n\nQuerySet에서 cache를 사용하려면 QuerySet을 변수에 저장하여 재사용하면 된다.\n\n- 다음과 같은 코드는 캐싱하지 않았으므로 재사용이 불가능한 queryset이다\n\n```python\nprint([e.headline for e in Entry.objects.all()])\nprint([e.pub_date for e in Entry.objects.all()])\n```\n\n- 아래 코드는 queryset이라는 변수에 QuerySet을 할당했다\n\n```python\n>>> queryset = Entry.objects.all()\n>>> print([p.headline for p in queryset]) # QuerySet이 평가됨\n>>> print([p.pub_date for p in queryset]) # 이미 평가가 되었으므로 캐시로 재사용한다.\n```\n\n#### *queryset이 평가되지 않을 때*\n\n쿼리셋은 항상 그 결과를 캐싱하지는 않는다. 다음 코드를 보면서 이해해보자\n\n```python\n>>> queryset = Entry.objects.all()\n>>> print(queryset[5]) # queryset이 평가되지 않았으므로 쿼리를 실행한다.\n>>> print(queryset[5]) # queryset이 평가되지 않았으므로 쿼리를 실행한다.\n```\n\n```python\n>>> queryset = Entry.objects.all()\n>>> [entry for entry in queryset] # 리스트컴프리헨션을 사용해서 queryset이 평가되었다.\n>>> print(queryset[5]) # 평가가 발생했기 때문에 캐시를 사용한다.\n>>> print(queryset[10]) # 평가가 발생했기 때문에 캐시를 사용한다.\n```\n\n### 2-2. 캐시된 속성 이해하기\n\n전체 쿼리셋을 캐싱할 뿐만 아니라, ORM 객체의 속성 또한 캐싱이 가능하다. 일반적으로 호출할 수 없는 속성은 캐시된다.\n\n```python\n>>> entry = Entry.objects.get(id=1)\n>>> entry.blog   # 이때 blog가 연결된 어떠한 instance라면 쿼리가 발생하고 그것을 캐싱, 그게 아니라 어떠한 속성이라면 속성 값을 캐싱\n>>> entry.blog   # instance라면 쿼리가 발생하지 않고 캐싱된 값을 가져온다. 속성이여도 캐싱된 값을 가져온다.\n```\n\n- 호출 가능한 속성은 캐싱되지 않고 DB에 접근한다.\n\n```python\n>>> entry = Entry.objects.get(id=1)\n>>> entry.authors.all()   # 캐싱되지 않아서 쿼리가 발생한다.\n>>> entry.authors.all()   # 캐싱되지 않아서 쿼리가 발생한다.\n```\n\n❌사용자가 정의한 속성은 주의를 해야한다. 캐싱이 필요하다면 `cached_property` 데코레이터를 사용해야한다.\n[다음 포스트](https://americanopeople.tistory.com/317)를 참고하자.\n\n### 2-3. iterator()를 사용해라\n\n많은 양의 객체를 가져오게 될 때 쿼리셋의 캐싱하는 행위로 인해 많은 양의 메모리가 사용될 수 있다. 이때 `iterator()`를 사용하자\n\n## 3. 파이썬으로 가져와서 처리하기보다 DB에서 결과를 처리하도록 하라\n\n- F, aggregate를 사용하면 파이썬으로 가져오지 않고 DB에서 결과를 처리할 수 가 있는데 다음 포스트를 참고하자.\n\n- [Django 공식문서](https://docs.djangoproject.com/en/3.0/topics/db/aggregation/#aggregation)\n- [Django에서 F() 객체 알아보기](https://blog.myungseokang.dev/posts/django-f-class/)\n\n## 4. 인덱스나 유니크한 값으로 조회해라\n\nget()을 사용하여 단일 객체를 조회할 때 `unique` 또는 `db_index`열을 사용하는 데는\n두 가지 이유가 있다.\n\n1. 데이터베이스 인덱스로 인해 여러 쿼리 속도가 빨라진다.\n2. 두번째 조회는 단 하나의 객체가 반환될 것이라고 보장하지 않는다.\n\n## 5. 필요한 정보들을 알고 있다면 한 번에 싹 가져와라\n\n- `select_related`와 `prefetch_related`를 통해서 적은 쿼리를 동작시키는 것이 효율적이다. 필요한 데이터가 무엇인지\n알고 있으면서 여러번 데이터베이스를 hitting하는 것은 효율적이지 못하다.\n- view 코드 혹은 다른 레이어에서 필요에 따라 prefetch\\_related\\_objects()를 사용해라.\n- `select_related`와 `prefetch_related`에 대한 자세한 내용은 다음 포스트를 참고하라.\n\n## 6. 필요없는 항목은 검색하지 마라\n\n#### QuerySet.values() 및 values\\_list()를 사용하기\n\ndict 또는 list 값을 원할 때, ORM 모델 객체가 필요하지 않은 경우에는 values()를 적절하게\n사용하라\n\n#### QuerySet.`defer()` 및 `only()`를 사용하기\n\n대부분 모든 데이터가 필요하지는 않을 것이다. 모든 컬럼이 로드되지 않도록 하려면 defer()와\nonly()를 사용하라<br>\n하지만 잘못 사용하면 별도의 쿼리로 데이터를 가져와야 하므로 더 나빠질 수도 있다.<br>\n<br>\n또한 지연된 필드(deferred fields)가 있는 모델을 생성할 때, Django 내부에서 발생하는\n약간의 오버 헤드가 있음에 유의하라. defer() 및 only() 메서드는 많은 텍스트 데이터를\n로드하지 않거나 Python으로 다시 변환하기 위해 많은 처리가 필요한 필드의 경우\n가장 유용하다. 항상 그렇듯이 먼저 프로파일링을 한 다음 최적화하라.\n\n#### QuerySet.count()를 사용하라\n\nlen(queryset)을 사용하는 것보다 낫다.\n\n#### QuerySet.exists()를 사용하라\n\n적어도 하나가 있는지 확인하기 위해서는 if queryset을 사용하기보다 exists()를 사용하라\n\n#### QuerySet.update()와 delete()를 사용하라\n\n단일객체를 검색하고 일부를 변경하고 저장하지마라, bulk SQL UPDATE를 사용하라 또한 bulk delete\n를 사용해도 좋다.\n\n#### foreign key values를 직접 사용하라\n\n`entry.blog.id` 보다 `entry.blog_id` 를 사용해라\n\n#### 상관 없다면 결과를 정렬하지 말 것\n\nodering은 비용이 안드는 작업이 아니다. 데이터베이스가 반드시 수행해야하는 작업이다.<br>\n데이터베이스에 인덱스를 추가하면 정렬성능을 향상 시키는데 도움이 될 수 있다.\n\n## 7. bulk를 사용하라\n\n`bulk_create()`를 사용하면 query를 줄일 수 있다. 이런 방법은 ManyToMany에서도 동일하다.\n\n```python\n# bad\nmy_band.members.add(me)\nmy_band.members.add(my_friend)\n```\n\n```python\nmy_band.members.add(me, my_friend)\n```\n\n---\n\nref [django - QuerySets Evaluation and Caching](https://kimdoky.github.io/django/2020/03/11/django-querysets-cashing-eval/)\n"},"frontmatter":{"layout":"post","title":"Django / 데이터베이스 접근 최적화에 대해서","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/django-split-settings.md","fields":{"slug":"/python/django/split-setting/","categorySlug":"/categories/django/"},"internal":{"content":"아래 내용은 `Two Scoops of Django`를 바탕으로 작성된 글입니다.\n\n#### Two Scoops of Django\n\n- 3장 프로젝트 구성\n    - 쿠키커터\n        - Two Scoops of Django에서는 쿠키커터를 추천한다. 하지만 모든 옵션들을 다 이해할 수 없는\n        상태에서 사용하려니 매우 과하게 느껴진다.\n        - 구조만 따라하고 추후에 따라 필요한 것들 부가적으로 추가하고자 한다.\n\n- 4장 장고 앱 디자인의 기본\n    - 한 번에 한 가지 일을 하고 그 한 가지 일을 매우 충실히 하는 프로그램을 짜는 것\n\n- 5장 settings와 requirements 파일\n    - 개발환경, 배포환경, 테스트환경처럼 때에 따라 필요한 설정값과 변경 또는 추가해주어야하는 설정이 존재할 수 있음\n    - 때마다 변경, 수정하는 번거로움 또는 누락 가능성으로 파일을 분리할 필요성이 생김\n    - 마찬가지로 필요한 package도 다를 수 있기 때문에 requirements도 분리를 해야한다.\n\n이번 포스팅에서는 프로젝트 구성과 함께 settings/requirements를 분리해보자\n\n---\n\n### 세팅하려는 프로젝트 구성\n\n```shell\nPROJECT_DIR\n├── README.rst\n├── config\n│   ├── __init__.py\n│   ├── settings\n│   │   ├── base.py\n│   │   ├── local_bmh.py\n│   │   ├── production.py\n│   │   └── test.py\n│   ├── urls.py\n│   └── wsgi\n│       ├── local.py\n│       ├── production.py\n│       └── test.py\n├── .config_secret\n│   ├── base.py\n│   ├── local.py\n│   ├── production.py\n│   └── test.py\n├── docs\n├── manage.py\n├── project_name\n├── requirements\n│   ├── base.txt\n│   ├── local.txt\n│   └── production.txt\n├── .gitignore\n└── setup.cfg\n```\n\n---\n\n### 세팅하기 이전에 몇 가지 중요사항들\n- 세팅 변화에 대한 기록이 반드시 문서화 되어야하기 때문에 버전 컨트롤 시스템으로 모든 설정 파일을 관리해야한다.\n- 반복되는 설정들을 없애야한다. 기본 세팅 파일로부터 상속을 통해 이용해야한다.\n- 암호나 비밀키 등은 안전하게 보관해야한다. 보안 관련 사항은 버전관리 시스템에서 제외해야한다.\n\n---\n\n### config: 여러 개의 settings 파일 이용하기\n\n#### settings 디렉터리를 사용하라\n```shell\nconfig/\n  settings/\n    __init__.py\n    base.py       # 프로젝트의 모든 인스턴스에 적용되는 공용 세팅 파일\n    local.py      # 로컬 환경에서 작업할 때 쓰이는 파일. 디버그 모드, 로그 레벨,\n                  # django-debug-toolbar은 도구 활성화 등이 설정되어 있는 개발 전용\n                  # 로컬 파일이다. dev.py라고도 한다.\n                  # 운영 환경으로 코드가 완전히 이전되기 전에 관리자들이 확인을 위한\n                  # 서버에 사용\n    production.py # 운영서버에서 실제로 운영되는 세팅 파일. 이 파일에는 운영서버에서만\n                  # 필요한 설정들이 들어있다. prod.py라고도 한다.\n    test.py       # 테스트 러너(test runner), 인메모리 데이터베이스 정의, 로그세팅등을\n                  # 포함한 테스트를 위한 세팅\n```\n#### 나누어진 setting 파일은 어떻게 실행할까?\n```shell\npython manage.py runserver --settings=config.settings.local_bmh\n```\n- shell, makemigrations, migrate과 같은 다른 명령은 runserver 자리에 넣어서 동일하게 실행한다.\n- django 공식문서에서는 여러개의 settings를 사용하면 django-admin을 사용하는 것을 권한다.\n- `.zshrc`에 다음과 같이 선언하면 매번 길에 입력해야하는 귀찮은 일을 줄일 수 있다.\n```shell\nDJANGO_SETTINGS_MODULE=config.settings.local_bmh\n```\n\n#### 다중 개발 환경 세팅\n- 개발자마다 자기만의 환경이 필요한 경우가 있다.\n- 이럴 경우 하나의 local.py 세팅을 공유해서 사용하는 것에 어려움이 있을 수 있다.\n- 이럴 때는 버전 컨트롤 시스템에서 공유가 가능하며 관리가 가능하도록 `local_developer_name.py`\n과 같은 식으로 관리하면 편리하다. 이렇게 하면 잘못된 세팅을 했을 경우 동료 개발자가 체크할 수 있다.\n\n#### wsgi 분리하기\n- settings가 분리되면서 wsgi도 나누어야하는데 특별한 설정은 없고 위의 tree처럼 나눈 후 아래와 같이 수정하자\n    ```python\n    import os\n\n    from django.core.wsgi import get_wsgi_application\n\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"config.settings.local_bmh\")\n    # 실행하는 settings을 1번째 인자로 설정하면된다.\n\n    application = get_wsgi_application()\n    ```\n\n---\n\n### .config_secret: 코드에서 비밀키 분리하기\n세팅파일은 분리했는데 이제 특별하게 설정된 비밀키를 어딘가에 저장해서 사용해야한다.\n\n#### 비밀키 보호를 위한 방법\n- 버전 컨트롤 시스템에서 제외한다.\n- 각 환경마다 비밀 정보가 다를 수 있다.(ex> DB정보, 사용하는 모듈의 비밀키) 그렇기때문에 공통된 객체로부터 상속받아 각 환경마다\n다른 세팅 파일로 나누어 버전 컨트롤 시스템에서 관리하는 것이다.\n\n#### 비밀키를 어딘가에 저장해서 사용해야한다.\n- 버전컨트롤 시스템에 추가하면 안된다.\n- 코드 수정이 없어야한다.\n- 세팅 파일을 버번관리 시스템에 추가할 수 있어야한다. 세팅파일을 포함하여 모든 파이썬 파일은 버전 컨트롤 시스템에서 관리해야한다.\n- 두 가지 방법이 있다.\n\n<br>\n\n1. 환경 변수로 관리하기\n    - 위키=> 환경변수란 프로세스가 컴퓨터에서 동작하는 방식에 영향을 미치는, 동적인 값들의 모임\n    - 시스템의 실행파일이 놓여 있는 디렉토리의 지정 등 OS상에서 동작하는 응용소프트웨어가 참조하기 위한 설정이 기록된다.\n    - 환경변수를 세팅하기 위해서 `.bashrc, .bash_profile, .profile, .zshrc` 파일에 추가하면 된다.\n    - zsh를 사용하는 나는 `.zshrc`에 다음과 같은 구문을 넣는다.\n    ```shell\n    export SOME_SECRET_KEY=secret_key\n    ```\n    - 세팅 파일에서 환경 변수에 접근하는 방법\n    ```python\n    import os\n    SOME_SECRET_KEY = os.environ[\"SOME_SECRET_KEY\"]\n    ```\n    - 비밀키가 존재하지 않을 때 예외처리하기\n        - 비밀키가 존재하지 않으면 `KeyError`를 일으킬 수 있다.\n        - 프로젝트가 시작되지 않는 문제보다 더 큰 문제는 그 원인을 알 수 없다는 것이다.\n        - 디버그를 위한 에러메세지를 받아야한다.\n        - 아래와 같은 함수를 선언하고 함수로 환경변수를 가져온다\n\n      ```python\n      import os\n\n      # 일반적으로 장고로부터 직접 무언가를 설정 파일로 임포트해 올 일은 없을 것이며 또한 해서도 안된다.\n      # 단 ImproperlyConfigured는 예외다\n      from django.core.exceptions import ImproperlyConfigured\n\n      def get_env_variable(var_name):\n        \"\"\"환경 변수를 가져오거나 예외를 반환한다.\"\"\"\n          try:\n              return os.environ[var_name]\n          except KeyError:\n              error_msg = f\"Set the {var_name} environment variable\"\n              raise improperlyConfigured(error_msg)\n      ```\n2. 비밀파일로 관리하기\n    - 환경 변수로 관리하는 방법은 때에 따라 적용되지 않을 수 있다. 책에서는 아파치를 웹 서버로 이용하는 경우라고 이야기하고 있다.\n    아파치가 독립적인 환경 변수 시스템을 가지고 있기 때문이다.\n    - 이런 경우에는 json 파일에 비밀 정보를 입력하고 참조할 수 있도록 세팅해야한다.\n    - `.config_secret` 디렉토리를 만들고 json파일 안에 비밀 키를 넣는다.\n    - `.config_secret`은 .gitignore에 추가해야한다.\n    - .config_secret/base.json\n\n    ```json\n    {\n      \"SECRET_KEY\": {\n        \"SECRET_KEY\": \"secret_key\"\n      }\n    }\n    ```\n    - `BASE_DIR, ROOT_DIR, CONFIG_SECRET_DIR`의 path를 설정해서 json 파일을 읽어오도록 한다.\n    - config/settings/base.py\n\n    ```python\n    # config/settings/base.py\n    import os\n    import json\n\n\n    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    ROOT_DIR = os.path.dirname(BASE_DIR)\n    CONFIG_SECRET_DIR = os.path.join(ROOT_DIR, \".config_secret\")\n    CONFIG_SECRET_BASE_FILE = os.path.join(CONFIG_SECRET_DIR, \"base.json\")\n    CONFIG_SECRET_LOCAL_FILE = os.path.join(CONFIG_SECRET_DIR, \"local.json\")\n    CONFIG_SECRET_PRODUCTION_FILE = os.path.join(CONFIG_SECRET_DIR, \"production.json\")\n    CONFIG_SECRET_TEST_FILE = os.path.join(CONFIG_SECRET_DIR, \"test.json\")\n\n    config_secret_base = json.loads(open(CONFIG_SECRET_BASE_FILE).read())\n\n    # SECRET_KEY\n    SECRET_KEY = config_secret_base[\"SECRET_KEY\"][\"SECRET_KEY\"]\n\n    # APPS\n    DJANGO_APPS = [\n        'django.contrib.admin',\n        \"django.contrib.auth\",\n        \"django.contrib.contenttypes\",\n        \"django.contrib.sessions\",\n        \"django.contrib.messages\",\n        \"django.contrib.staticfiles\",\n    ]\n\n    THIRD_PARTY_APPS = []\n\n    LOCAL_APPS = []\n\n    INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS\n\n    ...\n    ```\n\n    - local 세팅은 다음과 같다.\n    - .config_secret/local.json\n\n    ```json\n    {\n      \"DATABASES\": {\n        \"default\": {\n          \"ENGINE\": \"django.db.backends.mysql\",\n          \"NAME\": \"name\",\n          \"USER\": \"user\",\n          \"PASSWORD\": \"password\",\n          \"HOST\": \"127.0.0.1\",\n          \"PORT\": \"3306\",\n          \"TEST\": {\n            \"CHARSET\": \"utf8mb4\",\n            \"COLLATION\": \"utf8mb4_general_ci\"\n          },\n          \"OPTIONS\": {\n            \"charset\": \"utf8mb4\"\n          }\n        }\n      },\n      \"ALLOWED_HOSTS\": [\"*\"]\n    }\n    ```\n    - config/settings/local_bmh.py\n\n    ```python\n    import json\n\n    from .base import *\n\n\n    # GENERAL\n    config_secret_local = json.loads(open(CONFIG_SECRET_LOCAL_FILE).read())\n    DEBUG = True\n\n    # URLS\n    WSGI_APPLICATION = \"config.wsgi.local.application\"  # olaplan.wsgi.application\n    ALLOWED_HOSTS = config_secret_local[\"ALLOWED_HOSTS\"]\n\n    # APPS\n    INSTALLED_APPS += (\"django_extensions\", \"drf_yasg\")\n\n    # DATABASES\n    DATABASES = config_secret_local[\"DATABASES\"]\n    ```\n\n---\n\n### docs: 프로젝트 관련 문서 관리하기\n\n---\n\n### project_name: app 관리\n\n---\n\n### requirements: 개발 환경에 따라 필요한 package관리하기\n```shell\nrequirements/\n\tbase.txt\n\tlocal.txt\n\tstaging.txt\n\tproduction.txt\n```\n\n- base.txt에는 공통적인 package를 넣어준다.\n    ```\n    Django=2.2.1\n    djangorestframework=3.1.1\n    ...\n    ```\n- 다른 환경에서 필요한 패키지는 base를 기본으로 추가적으로 입력한다.\n- 예시로 local.txt이다.\n    ```\n    -r base.txt\n    django-debug-toolbar==1.3.0\n    ...\n    ```\n\n---\n\n### setup.cfg\n\n- package관련 세팅을 setup.cfg에 입력하면된다.\n- 예를들어 flkae8을 사용하는 나는 아래와 같이 세팅했다.\n    ```\n    [flkae8]\n    max-line-length = 88\n    select = C,E,F,W,B,B950\n    ignore = E203, E501, W503\n    ```\n"},"frontmatter":{"layout":"post","title":"Django / settings 분리하기(프로젝트 구성하기)","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/network/127.0.0.1-vs-localhost.md","fields":{"slug":"/cs/network/diff-127001-localhost/","categorySlug":"/categories/network/"},"internal":{"content":"사건은 이러하다.<br>\n\n1. 잘 되던 블로그에 댓글 기능을 추가하려고 플러그인을 설치했다.\n2. 생각보다 진행이 잘 안되서 플러그인 삭제\n3. 블로그가 실행이 안됨\n4. node랑 react는 내가 아는 영역이 아니라 그냥 다시 설치하자는 마음으로 노드를 완벽삭제\n5. 재설치 후 `yarn develop`을 하면 `localhost:8000`으로 로컬서버를 띄우게 되는데 계속 refresh\n6. 역시 갓구글 검색. 검색어: `run yarn develop in gatsby and constant refresh page`\n7. 나와 동일한 [이슈](https://github.com/gatsbyjs/gatsby/issues/18226)를 만난 사람이 있었음.\n8. 그 중 어느 한 사람이 자신도 동일한 이슈를 겪었으며, 가상 윈도우에서 동일한 페이지를 열면 문제가 없다고 이야기함.\n9. 그래서 어떤 사람이 방법을 제시함\n10. To use `http://127.0.0.1:8000` instead of `http://localhost:8000`.\n\n##What is the difference between 127.0.0.1 and localhost?\n\n###1. Basic knowledge\n\nEven when every network device is disconnected, your computer can still\ncommunicate over a kind of network. Known as a “loopback,” a Unix machine\ncan send and receive network communications from itself and to itself over a\nvirtual network device. Your computer can send messages from itself to itself,\npermitting network-style communications without the need for a functioning network.\n\n> 모든 통신 장비가 분리되어도 컴퓨터는 여전히 네트워크를 통해서 통신할 수 있다.\n> `loopback`이라고 불리는 유닉스 기계는 가상 네트워크 장비를 통해서 자신이 자신에게\n> 네트워크통신을 주고 받을 수 있다. 컴퓨터는 기능을 수행하는 네트워크 없이 `network-\n> style` 통신을 허락한다면 메세지를 자기자신에게 보낼 수 있다.\n\n###2. What is 127.0.0.1?\n127.0.0.1 is the most commonly-used loopback IP address. It’s part of the\nreserved block of more than sixteen million IP addresses that are used\nspecifically for loopback functionality. A loopback allows your computer to\ncommunicate with itself while using networking connection protocols.\n\n> 127.0.0.1은 일반적으로 사용되는 루프백 IP 주소이다. 그것은 루프백 기능에 특별히\n> 사용되는 1600만개의 IP 주소를 대신하는 블록의 일부분이다. 루프백은 컴퓨터가 네트워크\n> 통신 프로토콜을 사용하는 동안 자신과 통신할 수 있게 해준다.\n\n![](./image/difference-localhost-127-0-0-1-ipconfig-lo.jpg)\n\nIn broad abstraction, a loopback is a virtual networking device that creates\na network connection with only one endpoint, meaning that it begins and ends\nat the same device:your computer. In fact, the loopback device even shows up\nin ipconfig with the name lo, as seen above. The loopback addresses are\nprimarily used for troubleshooting (it’s similar to looking in a mirror) or\nto access local resources over a network interface.\n\n> 넓은 추상화에서 루프백은 하나의 엔드포인트로만 네트워크 연결을 만드는 가상 네트워크\n> 장치로, 당신의 컴퓨터처럼 하나의 장비 안에서 시작하고 종료된다는 것을 의미한다.\n> 실제로 루프백 장치는 위에서 보여지는 것처럼 `lo`라는 이름을 가진 `ipconfig`안에서 나타나기도\n> 한다. 루프백 주소는 주로 문제해결(거을 안을 보는 것처럼)을 위해 사용되거나 로컬 리소스를\n> 네트워크에 띄워서 확인하는 데 사용된다.\n\n###3. What is localhost?\n“localhost” describes a communication port that connects to the originating\nserver. It allows a network connection to “loop back” on itself, permitting you\nto emulate network connections when no such network is present or available.\nIn practice, localhost is treated as synonymous with 127.0.0.1 for usage and\ndiscussion. However, it’s important to remember that they are not strictly\nidentical.\n\n> `localhost`는 원래서버와 통신하는 통신 포트로 설명됩니다. 로컬호스트는 네트워크\n> 연결이 스스로 \"loop back\"을 할 수 있도록 하고, 네트워크가 없거나 사용 가능할 때 네트워크\n> 통신이 동작하는 것처럼 해줍니다. 실제로 `localhost`는 이야기 하거나 사용할 때에\n> `127.0.0.1`과 동의어로 사용합니다. 그러나 그 둘은 엄격히 다르다는 것을\n> 기억해야 합니다.\n\nBefore making a DNS request to translate the text string typed by the user into\na navigable IP address, the operating system checks the HOSTS file for any\naliases or redirect rules. On a system configured to standard defaults,\n“localhost” in a URI will resolve to 127.0.0.1 under IPv4 or ::1 for IPv6. There are\nfar more loopback addresses than just those two, however. The block of IP\naddresses reserved for loopback addresses stretches from 127.0.0.0 to\n127.255.255.255.\n\n> 사용자가 입력한 문자열을 탐색가능한 IP주소로 변경하는 DNS 요청을 하기 전에는,\n> 운영체제가 HOSTS 파일에서 any aliases or redirect rules를 검사했다. 기본값으로 설계된\n> 시스템에서는 URL의 \"localhost\"는 IP4에서는 127.0.0.1로, IP6에서는 ::1로 해결된다.\n> 하지만 이 두개의 루프백 주소보다 더 많은 루프백 주소가 존재한다. 루브백을 위해 준비된 IP\n> 주소의 일부는 127.0.0.1부터 127.255.255.255로 확장된다.\n\nIn most all cases localhost will resolve to 127.0.0.1, thanks to a redirect rule in\nthe HOSTS file, as mentioned above. But in some cases, localhost may be\nmapped to a different IP address. So, localhost could be pointed to any IP\naddress in that block, and it would function identically.\n\n> 대부분의 경우에 로컬호스는 위에서 이야기한대로 HOSTS 파일의 redirect rules 덕분에\n> 127.0.0.1로 해결된다. 그러나 경우에 따라서는, localhost는 다른 IP주소와 매칭될 수\n> 있다. 그래서 localhost는 어떤 IP주소를 가리키기도 하고, 동일하게 동작할 수 있다.\n\n###4. Conclusion: What’s the Difference Between localhost and 127.0.0.1?\n\nOn most machines localhost and 127.0.0.1 are functionally identical. But\nlocalhost is a label for the IP address and not the address itself. Localhost\ncould be pointed at different IP addresses. In fact, it could be pointed at any IP\naddress, even one outside the reserved address block. The HOSTS file doesn’t\ncare and won’t stop you. However, it will break significant functionality on\nyour system and crash any app that relies on a localhost connection.\n\n> 대부분의 시스템에서 localhost와 127.0.0.1은 기능적으로 동일하다. 그러나 localhost는\n> IP 주소의 일부를 나타내는 정도이지 주소자체는 아니다. localhost는 다른 주소를 가리킬\n> 수 있다. 실제로, 그것은 준비된 주소 블록 밖에 있는 다른 주소를 가리킬 수 있다. HOSTS\n> 파일은 이런 현상들을 확인해주거나 멈추어주지 않는다. 그러나 잘못된 연결은 시스템의 중요한\n> 기능을 손상시키고 localhost 연결에 의존성이 있는 다른 모든 앱과 충돌이 발생할 것이다.\n\nThe 127 block of addresses was chosen for the loopback address block\nbecause it was the last block of Class A addresses, which run from the binary\naddress value 00000001 to 01111111. In IPv6, the loopback address is the first\naddress, 0:0:0:0:0:0:0:1, most frequently expressed in its truncated form as ::1.\n\n> 주소들이 뭉쳐진 127 블록은 2진수 주소 값 00000001에서 01111111까지 실행되는\n> Class A 주소들이 뭉쳐진 마지막 블록이기때문에 loopback 주소 블록으로 선택되었다.\n> IPv6에서 루프백 주소는 첫번째 주소인 0:0:0:0:0:0:0:1인데, 주로 ::1로 줄여서 표현된다.\n\n정리하자면 루프백은 자기자신과 통신할 수 있는 유닉스 장치입니다. 127.0.0.1은 그러한\n루프백의 IP주소입니다. 로컬호스트는 컴퓨터 스스로가 루프백을 할 수 있도록 도와줍니다.\n두 개는기능적으로는 동일하지만 localhost에서 DNS를 통한 request가 다른 블록을 가리게 되는 경우가 생깁니다.\n<br>\n제게 발생한 문제도 동일한 경우가 아닐까 싶습니다. 지금 해보니 또\nlocalhost:8000으로 문제 없이 동작하네요.\n\n\n\nref: [https://github.com/gatsbyjs/gatsby/issues/18226](https://github.com/gatsbyjs/gatsby/issues/18226)<br>\nref: [https://www.maketecheasier.com/localhost-and-127-0-0-1/](https://www.maketecheasier.com/localhost-and-127-0-0-1/)\n"},"frontmatter":{"layout":"post","title":"127.0.0.1 VS localhost 어떤 차이가 있을까?","category":"network","tags":["localhost"]}}}]}}}