{"data":{"allMarkdownRemark":{"edges":[{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#01 DRF란 무엇인가?.md","fields":{"slug":"/python/django/drf-01/","categorySlug":"/categories/django/"},"internal":{"content":"DRF에 대해서 간략하게 알아봅시다.\n\n\n### DRF?\n\n공식문서에서 설명하는 DRF입니다.\n> DRF는 Web API를 만들기 위한 강력하고 유연한 툴입니다.<br>\n우리가 DRF를 써야하는 이유가 몇 가지 있습니다.\n> - Web browsable API는 개발자들에게 큰 유용성을 가져다줍니다.\n> - Serialization은 ORM과 non-ORM 데이터 소스를 모두 지원합니다.\n> - 강력한 View도 있지만 일반적인 View를 커스터마이징 해서 사용할 수 있습니다.\n> - DRF를 사용하는 많은 유저들이 있기때문에, 문서와 커뮤니티를 제공할 수 있습니다.\n> - 국제적인 기업들에서 사용하고 있습니다.\n\n<br>\n\n다른 이는 이렇게 말하기도 합니다.\n> DRF는 개발자가 만든 API들을 디버그하기 쉽게 만들어줍니다. DRF의 큰 기능은 **Models를 serializers로 변환하는 것**입니다. DRF에서 serializers는 복잡한 구조들을 이미 구성해두었습니다.\n> serializers는 모델을 전달하고, 그 모델들을 json 객체로 변환하는 것만이 전부가 아닙니다. 클라이언트로부터 백엔드에게 데이터를 전달하기도합니다. 코드를 검증하는 것도 자동으로 할 수 있습니다. 코드를 정리해서 security issues를 해결하기도 합니다.\n\n<br>\n\n많은 사람들이 설명하는 DRF는 무엇일까요?\n> Django 안에서 RESTful API 서버를 쉽게 구축할 수 있도록 도와주는 오픈소스 라이브러리입니다.\n\n### Serializer\n\n[직렬화(serialisation)는 무엇인가]()\n\n직렬화에 대한 설명은 위의 글을 읽어보길 바랍니다.<br>\n<br>\n파이썬 형식의 코드를 다른 네트워크 환경과 통신을 위해 코드를 직렬화 해야하는데,\nDRF에서 그것을 담당하는 클래스가 바로 `Serializer`입니다. DRF에서 제공하는 Serializer는\nqueryset, model instance 등의 복잡한 데이터를 JSON, XML 등의 컨텐트 타입으로 쉽게 변환 가능한\npython datatype으로 변환시켜줍니다.<br>\n\n#### RESTful API와 Serializer가 DRF를 사용하는 가장 큰 장점이 아닐까 생각합니다.\n"},"frontmatter":{"layout":"post","title":"DRF/#01 DRF란 무엇인가?","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/Django:장고는 무엇이고 어떻게 일하는가?.md","fields":{"slug":"/python/django/what-is-django-and-how-to-work-it/","categorySlug":"/categories/django/"},"internal":{"content":"Django는 무엇이고 어떻게 동작하는지 알아봅시다.\n\n![django_flow_02](./images/django_flow_02.png)\n\nDjango는 현재 가장 많이 사용되는 파이썬 웹 프레임워크입니다.\n2003년 로렌스 저널-월드 신문을 만들던 웹 개발팀의 내부 프로젝트로 시작됐으며, 오픈소스 프로젝트로\n공개되었습니. 그리고 구글의 앱 엔진에서 장고를 사용하면서 많은 사람들이 사용하게 되었고, 현재는\n파이썬의 대표적인 웹 프레임워크로 자리매김하고 있습니다.\n\n장고는 MVC를 기반으로 한 프레임 워크입니다. 장고에서는 View를 Template, Controller를 view라고 부릅니다.\n\nView는 데이터를 가져오고 변형하는 컴포넌트, Template는 데이터를 사용자에게 보여주는 컴포넌트입니다.\n그래서 장고를 흔히 MTV 프레임워크라고 부르기도합니다.\n\n- Model\n    안전하게 데이터를 저장\n- View\n    데이터를 적절하게 유저에게 보여줌\n    = 데이터를 유저에게 보내줄 때 유저가 원하는 형태로 형태로 보내주는 것을 담당\n- Control, Template(Django)\n    사용자의 입력과 이벤트에 반응하여 Model과 View를 업데이트(수정)\n\n## Django 개념\n###  장고의 workflow\n![django_flow_01](./images/django_flow_01.png)\n\n\n1. 웹 브라우저에서 이벤트가 발생 (url을 클릭하거나, 어떤 form에 data를 입력 등)\n\n2. 장고 서버로 data가 들어오고 'url dispatcher'에서 user가 요청한 url을 분석하고\n    그에 적합한 view로 보내준다.\n3. view는 사용자의 요청을 받아서, DB 어디에 접근해서, 어떤 데이터를 가공해야할 지 모델에 알려주면\n4. 모델에서 실질적인 DB와 커넥션을 하고 데이터를 가져오게 된다.\n5. DB에서 모델에 다시 데이터를 보내고\n6. 모델이 뷰에 데이터를 보내주고 뷰가 실질적으로 user에게 보여줄 데이터를 템플릿에 전송\n7. 템플릿은 ui를 만들어서 웹브라우저에 넘겨주게 된다.\n\n*이렇게 복잡한 과정들이 있는 것은 특정 영역을 분리하는게 중요하기 때문!*\n\n## project와 App\n\n프로젝트 = 웹 사이트\n의미있는 하나의 기능을 app이라고 구성\n\n    $ django-admin startprojec (project name)\n\n이렇게 명령어를 입력하면\n\n    manage.py(실행파일)\n    project name(디렉토리)\n        __init__.py\n        settings.py(전체 프로젝트를 관리하는 설정파일)\n        urls.py\n        wsgi.py\n\n위와 같이 파일 구조가 생깁니다.\n\napp 생성(상위에)\n\n    $ ./manage.py startapp (app name)\n\n다양한 파일 목록이 생깁니다.\n\n    app name\n        admin.py(관리자권한을 가지는 사용자가 볼 수 있는 페이지에 대한 내용을 다룸)\n        __init__.py\n        migrations\n            __init__.py\n        models.py\n        tests.py\n        views.py(데이터를 가공)\n\n### Settings.py\n\n전체적인 프로젝트 환경 설정 파일\n\n`debug`\n에러에 대한 내용을 보고 싶을때 true로 두게 되면 변수의 상태를 확인 할 수 있습니다.\n배포를 할 때는 false(디버깅 내용을 공개하지 않기 위해서), 개발단계에서는 true\n\n`installed_apps`\n    pip로 설치한 앱 또는 본인이 만든 app를 추가\n\n`middelware_classes`\nrequest와 response 사이의 주요 기능 레이어(크게 신경 쓸 필요 없음 - 보안 기능)\n`templates`\ndjango template관련 설정, 실제 뷰(html, 변수)에서 컨트롤해서 다루게 됩니다.\n`databases`\n데이터베이스 설정 파일, 데이터베이스 엔진의 연결 설정(다양한 데이터베이스를 사용할 수 있음)\n`static_url`\n정적파일(js,img,css)들과 관련된 url이나 dict가 관련된 설정파일\n\n### Manage.py\n프로젝트 관리 명령어 모음\n\n`startapp`: 앱생성\n`runserver`: 서버 실행\n`createsuperuser`: 관리자 실행\n`makemigrations app`: app의 모델 변경 사항 체크\n`migrate`: 변경 사항을 DB에 반영\n`shell`: 쉘을 통해 데이터를 확인\n`collectstatic`: static 파일을 한 곳에 모음\n\n    ex) ./manage.py runserver 0.0.0.0:8080\n\n---\n\nref : https://www.essenceandartifact.com/2012/12/the-essence-of-mvc.html\n"},"frontmatter":{"layout":"post","title":"Django/장고는 무엇이고 어떻게 일하는가?","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/data-structure/2019-11-14---DataStructure-Trie/index.md","fields":{"slug":"/cs/data-structure/trie","categorySlug":"/categories/data-structure/"},"internal":{"content":"\n# Trie 구조 (문자열 검색)\n\nTags: tree, trie, 문자열\n\n![Trie/Untitled.png](Trie/Untitled.png)\n\n## TMI\n\n[코딩테스트 연습 - 가사 검색 | 프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/60060)\n\n오늘도 여김 없이 TMI부터 시작한다. 코딩 테스트 연습을 하면서 알게 된 Trie (트라이) 라는 자료 구조에 대헤 정리 한다. \n\n## Trie-트라이\n\n> 문자열을 효율적으로 탐색하기 위한 자료 구조로 n 진 Tree(트리)형태로 구성되어 있다.\n\n트라이?? 발음은 Try 랑 같다. 잘 모르겠지만 일단 Try 해보자!!\n\n우리가 여러 개의 문자열을 가지고 있을 때, 어떤 문자열이 그 문자열 중 하나인지 알아내는 방법은 뭐가 있을까?단순하게 일일이 비교해보면 된다. 하지만 컴퓨터는 이러한 방법이 매우 비효율적이다. 예를 들어, 최대 길이가\n\nm인 문자열 *n*개의 집합에서 마찬가지로 최대 길이가*m*인 임의의 문자열이 그 문자열들의 집합에 포함되는지를 일일이 확인하면 사전처리는 필요 없지만, 최악의 경우O(nm)의 비교 횟수가 필요하다.\n\n이 문자열을 정렬시킨 뒤, [이진 탐색](https://namu.wiki/w/%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89) 이라는 강력한 알고리즘을 사용하면O(m log n)로 단축시킬 수 있지만, 정렬 과정 자체에 O(n m log n)의 시간이 걸리므로 사양이 안 좋은 컴퓨터라면 이것도 비효율적이다. 하지만 위의 시간 복잡도를 압도하는 알고리즘이 존재한다. 프레드킨이 이름 붙인 \"Trie\"라는 자료구조가 지금부터 설명할 가장 효율적인 문자열 검색법이다.\n\n## 구현 코드\n\n    public class TrieNode {\n        private final Map<Character, TrieNode> children = new HashMap<>();\n        private boolean endOfWord;\n        private int count;\n    \n        Map<Character, TrieNode> getChildren() {\n            return children;\n        }\n    \n        boolean isEndOfWord() {\n            return endOfWord;\n        }\n    \n        void setEndOfWord(boolean endOfWord) {\n            this.endOfWord = endOfWord;\n        }\n    \n        public int getCount() {\n            return count;\n        }\n    \n        void increaseCount() {\n            this.count++;\n        }\n    }\n\n    public class Trie {\n        private TrieNode root;\n    \n        public Trie() {\n            root = new TrieNode();\n        }\n    \n        public void insert(String word)1\n            TrieNode current = root;\n    \n            current.increaseCount();\n            current = current.getChildren()\n                    .computeIfAbsent((char) (word.length() + '0'), c -> new TrieNode());\n    \n            for (char trieWord : word.toCharArray()) {\n                current.increaseCount();\n                current = current.getChildren()\n                        .computeIfAbsent(trieWord, c -> new TrieNode());\n            }\n    \n            current.setEndOfWord(true);\n        }\n    \n        public int countOfSearched(String word, int index) {\n            TrieNode current = root;\n    \n            TrieNode wordLengthNode = current.getChildren().get((char) (word.length() + '0'));\n            if (wordLengthNode == null) {\n                return 0;\n            }\n            current = wordLengthNode;\n    \n            for (int i = 0; i < index; i++) {\n                char ch = word.charAt(i);\n                TrieNode node = current.getChildren().get(ch);\n                if (node == null) {\n                    return 0;\n                }\n                current = node;\n            }\n            return current.getCount();\n        }\n    }\n\n## update 예정..."},"frontmatter":{"layout":"post","title":"Trie 트라이","category":"data-structure","tags":["문자열 탐색"]}}}]}}}