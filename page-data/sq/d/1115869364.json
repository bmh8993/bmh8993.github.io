{"data":{"allMarkdownRemark":{"edges":[{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#01 DRF란 무엇인가?.md","fields":{"slug":"/python/django/drf-01/","categorySlug":"/categories/django/"},"internal":{"content":"DRF에 대해서 간략하게 알아봅시다.\n\n\n### DRF?\n\n공식문서에서 설명하는 DRF입니다.\n> DRF는 Web API를 만들기 위한 강력하고 유연한 툴입니다.<br>\n우리가 DRF를 써야하는 이유가 몇 가지 있습니다.\n> - Web browsable API는 개발자들에게 큰 유용성을 가져다줍니다.\n> - Serialization은 ORM과 non-ORM 데이터 소스를 모두 지원합니다.\n> - 강력한 View도 있지만 일반적인 View를 커스터마이징 해서 사용할 수 있습니다.\n> - DRF를 사용하는 많은 유저들이 있기때문에, 문서와 커뮤니티를 제공할 수 있습니다.\n> - 국제적인 기업들에서 사용하고 있습니다.\n\n<br>\n\n다른 이는 이렇게 말하기도 합니다.\n> DRF는 개발자가 만든 API들을 디버그하기 쉽게 만들어줍니다. DRF의 큰 기능은 **Models를 serializers로 변환하는 것**입니다. DRF에서 serializers는 복잡한 구조들을 이미 구성해두었습니다.\n> serializers는 모델을 전달하고, 그 모델들을 json 객체로 변환하는 것만이 전부가 아닙니다. 클라이언트로부터 백엔드에게 데이터를 전달하기도합니다. 코드를 검증하는 것도 자동으로 할 수 있습니다. 코드를 정리해서 security issues를 해결하기도 합니다.\n\n<br>\n\n많은 사람들이 설명하는 DRF는 무엇일까요?\n> Django 안에서 RESTful API 서버를 쉽게 구축할 수 있도록 도와주는 오픈소스 라이브러리입니다.\n\n### Serializer\n\n[직렬화(serialisation)는 무엇인가]()\n\n직렬화에 대한 설명은 위의 글을 읽어보길 바랍니다.<br>\n<br>\n파이썬 형식의 코드를 다른 네트워크 환경과 통신을 위해 코드를 직렬화 해야하는데,\nDRF에서 그것을 담당하는 클래스가 바로 `Serializer`입니다. DRF에서 제공하는 Serializer는\nqueryset, model instance 등의 복잡한 데이터를 JSON, XML 등의 컨텐트 타입으로 쉽게 변환 가능한\npython datatype으로 변환시켜줍니다.<br>\n\n**RESTful API와 Serializer가 DRF를 사용하는 가장 큰 장점이 아닐까 생각합니다.**\n"},"frontmatter":{"layout":"post","title":"DRF/#01 DRF란 무엇인가?","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/Django:null=True와 blank=True의 차이.md","fields":{"slug":"/python/django/difference-between-null-true-and-blank-true","categorySlug":"/categories/django/"},"internal":{"content":"django의 field option인 null=True와 blank=True에 대해서 알아봅시다.<br>\nDjango model을 검색하면 상위에 올라오는 검색어입니다.<br>\n뭔가 빈 값을 허락하냐는 옵션인데 둘 다 비슷해보입니다.\n분명 다른 것이 있으니 둘 다 제공할텐데 무엇이 다른지 차이를 알고 사용해봅시다.<br>\n\n- Null\n    DB와 관련되어 있습니다. 주어진 DB 컬럼이 null 값을 가질 것인지 아닌지를 정의합니다.\n    DB에 저장시 컬럼의 값이 NULL(데이터 없음)이 저장됩니다.\n- Blank\n    유효성과 관련되어 있습니다. `form.is_valid()`가 호출될 때 폼 유효성 검사에 사용됩니다.\n    쉽게 이야기하면, 필드가 폼(입력양식)에서 빈 채로 저장되는 것을 허용하느냐에 대한 물음으로, 허용시 \"\"(빈 스트링)이 저장됩니다.\n\n여러 글에 따르면 개발자들이 많이 실수하는 부분은 `CharField`, `TextField`와 같은 문자열 기반 필드에 `null=True`를 정의하는 것입니다.\n이 같은 실수를 피해야합니다. 그렇지 않으면 \"데이터 없음\"에 대해 두 가지 값, `None`과 `빈 문자열`을 갖게 됩니다.\n\"데이터 없음\"에 대해 두 가지 값을 갖는 것은 중복입니다.<br>\n<br>\n즉, 문자열 기반의 모델 필드를 `nullable`하게 만들고 싶다면 다음과 같이 해야합니다.\n```python\nclass Person(models.Model):\n    name = models.CharField(max_length=255)\n    introduce = models.TextField(blank=True)  # 여기서 null=True는 넣으면 안된다.\n    birth_date = models.DateField(null=True, blank=True)  # 둘 다 넣어도 괜찮다.\n```\n"},"frontmatter":{"layout":"post","title":"Django/null=True와 blank=True의 차이","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/Django:비지니스 로직 관리하기.md","fields":{"slug":"/python/django/manage-business-logic/","categorySlug":"/categories/django/"},"internal":{"content":"\ndjango를 사용할 때 비지니스 로직을 어떻게 관리하는지 알아봅시다.\n\nDjango를 사용하면서 고민되는 점이 생겼습니다. 비지니스 로직을 어떻게 관리하는게 좋을까 하는 부분입니다.\n(현재 진행하고 있는 프로젝트는 DRF를 사용하고 있습니다.)<br>\n<br>\n**views.py**는 CBV를 사용하고 있어서 최대한 간결하게 작성하고,\nserializer의 메소드를 오버라이드 하여 작성하고 있습니다. 복잡한 비지니스로직을 작성하다보니\n리팩토링의 필요성을 느꼈고, **models.py**에 모델메소드를 작성하고 있었습니다. 하지만 그마저도 너무 많아져서 fat model이 되버렸습니다.<br>\n<br>\n\n*\"비지니스 로직을 어떻게 관리했을 때 프로젝트를 관리가 편해질까\"*<br><br>\n\n이런 질문에서부터 이 글이 시작되었습니다.<br>\n\n## Fat models는 너무 많은 의존성을 만들어낸다.\n\n비지니스 로직은 어떤 하나의 큰 흐름입니다. 그래서 비지니스 로직을 작성하다보면 흐름을 시작한\nmodel 뿐만 아니라 다른 model에서의 메소드를 불러와서 호출하기도 합니다. 이런 방식은 불필요한 의존성을 만들어냅니다.<br>\n<br>\n의존성때문에 다른 모델에서의 변경이 발생하면 변경을 반영하기 위해서 흐름 안에 있는 코드를 수정해야 합니다.\n\n## Fat models는 테스트를 어렵게 한다.\n\n만약 나의 모델이 큰 흐름을 가지고 있다면, 내 테스트 코드들은 크고 많은 더미 데이터를 필요로 할 것입니다.\n\n## Fat models는 SRP를 위반한다.\n\nSRP(단일 책임 정책)은 클린 아키텍처의 5가지 원칙중의 하나로, 다음과 같은 원칙입니다. 자세한 내용은 다음에 `클린 아키텍처`라는\n책을 읽고 블로깅 할 예정입니다.\n\n- 클래스는 단 하나의 책임을 해야한다.\n- 클래스가 변경되는 이유는 단 한 개여야 한다.\n\nFat models를 작성하다보면 많은 책임을 갖게 만듭니다. 예를 들어 User 모델은 user의 DB를 관리하는데 목적이 있습니다.<br>\nUser 모델에 메일을 보내거나 알림을 보내는 메소드를 작성하게 되면 어떤 알림이나 메일을 보내는 책임이 더해지는 것입니다.\n\n## 흐름과 관련된 것이 아니라 attr을 변경하는 메소드를 작성하자\n\n- 상태(attr)을 변경하는 것은 늘 행동(메소드)를 통해서 하세요. 매우 중요합니다.\n직접 변경하게 되면 트랙킹하기가 어려울 것입니다. 사이즈가 커지면 커질수록 더욱 어렵습니다.\n- Django의 모델은 python 클래스의 일부입니다. OOP의 관점에서 객체의 상태는 행동(메소드)에 의해서 변경 되어야합니다.\n\n```python\nfrom django.db import models\n\nclass Customer(models.Model):\n    name = models.CharField(max_length=90)\n    active = models.BooleanField(default=True)\n    work_email = model.EmailField()\n    personal_email = models.EmailField(null=True, blank=True)\n```\n\n- 다음과 같이 active의 상태를 변경하는 코드를 통해서 상태가 혼잡해지는 사태를 막을 수 있게 되었습니다.\n\n```python\nfrom django.db import models\n\nclass Customer(models.Model):\n    name = models.CharField(max_length=90)\n    active = models.BooleanField(default=True)\n    work_email = model.EmailField()\n    personal_email = models.EmailField(null=True, blank=True)\n\n    def deactivate(self):\n        self.active = False\n        self.save(update_fields=[\"active\"])\n```\n\n- 어떤 상태를 저장하는 것과 더불어 validation 하고 싶다면 다음과 같이 적으면 됩니다. 물론 DRF에서 validateion은\nserializer에 validate를 오버라이드 하면 됩니다.\n\n```python\nfrom django.db import models\n\nclass Customer(models.Model):\n    name = models.CharField(max_length=90)\n    active = models.BooleanField(default=True)\n    work_email = model.EmailField()\n    personal_email = models.EmailField(null=True, blank=True)\n\n    def deactivate(self):\n        self.active = False\n        self.save(update_fields=[\"active\"])\n\n      def set_personal_email(self, email):\n          if self.work_email == email:\n              raise ValueError(\n                  \"Personal email and work email are equal\"\n              )\n          self.personal_email = email\n          self.save(update_fields=[\"personal_email\"])\n```\n\n## 의존성을 피하라\n\n- 흐름 안에 있는 모델에서 다른 모델이나 클래스의 메소드를 호출하면 안됩니다.\n- 특히나 서드파티를 이용할수록 더욱 그렇습니다. 예를들어 가입하게되었을 때에 환영 이메일을 보낸다고 가정합시다.\n객체를 생성하는 코드에서 메일을 보낼 때에 서버에 이상이 생긴다면 생성되지도 않은 유저에게 이메일을 보내는 경우가 생깁니다.\n\n## model manager를 사용해라\n\n- 모델 매니저를 사용하면 여기저기서 쿼리가 남발 되는 것을 막을 수 있습니다. 매니저를 사용하게 되면 테스트가 더욱 쉬워지고,\n한 곳에서만 변화를 만들 수 있습니다.\n\n## 결론\n\n제가 진행하고 있는 프로젝트에서는 다음과 같이 관리하기로 했습니다.\n\n1. models는 객체의 속성만 다루는 메소드를 작성한다.\n\n2. orm을 사용하여 query가 발생하는 메소드는 manager를 오버라이드하여 작성한다.\n\n3. utils(service layer) 디렉토리를 만들어 기능단위로 파일을 만들어 관리한다.\n\n    - 그중에서도 공통적으로 사용 가능한 부분은 또 따로 떼어낼 예정\n\n<br>\n\n더 참고할 포스트가 있다면 댓글로 남겨주시면 감사하겠습니다.\n\n---\n\nref: [Django model Guideline](https://medium.com/@jairvercosa/django-model-guideline-d48a96c9b38c)<br>\n"},"frontmatter":{"layout":"post","title":"Django/비지니스 로직 관리하기","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/Django:장고는 무엇이고 어떻게 일하는가?.md","fields":{"slug":"/python/django/what-is-django-and-how-to-work-it/","categorySlug":"/categories/django/"},"internal":{"content":"Django는 무엇이고 어떻게 동작하는지 알아봅시다.\n\n![django_flow_02](./images/django_flow_02.png)\n\nDjango는 현재 가장 많이 사용되는 파이썬 웹 프레임워크입니다.\n2003년 로렌스 저널-월드 신문을 만들던 웹 개발팀의 내부 프로젝트로 시작됐으며, 오픈소스 프로젝트로\n공개되었습니. 그리고 구글의 앱 엔진에서 장고를 사용하면서 많은 사람들이 사용하게 되었고, 현재는\n파이썬의 대표적인 웹 프레임워크로 자리매김하고 있습니다.\n\n장고는 MVC를 기반으로 한 프레임 워크입니다. 장고에서는 View를 Template, Controller를 view라고 부릅니다.\n\nView는 데이터를 가져오고 변형하는 컴포넌트, Template는 데이터를 사용자에게 보여주는 컴포넌트입니다.\n그래서 장고를 흔히 MTV 프레임워크라고 부르기도합니다.\n\n- Model\n    안전하게 데이터를 저장\n- View\n    데이터를 적절하게 유저에게 보여줌\n    = 데이터를 유저에게 보내줄 때 유저가 원하는 형태로 형태로 보내주는 것을 담당\n- Control, Template(Django)\n    사용자의 입력과 이벤트에 반응하여 Model과 View를 업데이트(수정)\n\n## Django 개념\n###  장고의 workflow\n![django_flow_01](./images/django_flow_01.png)\n\n\n1. 웹 브라우저에서 이벤트가 발생 (url을 클릭하거나, 어떤 form에 data를 입력 등)\n\n2. 장고 서버로 data가 들어오고 'url dispatcher'에서 user가 요청한 url을 분석하고\n    그에 적합한 view로 보내준다.\n3. view는 사용자의 요청을 받아서, DB 어디에 접근해서, 어떤 데이터를 가공해야할 지 모델에 알려주면\n4. 모델에서 실질적인 DB와 커넥션을 하고 데이터를 가져오게 된다.\n5. DB에서 모델에 다시 데이터를 보내고\n6. 모델이 뷰에 데이터를 보내주고 뷰가 실질적으로 user에게 보여줄 데이터를 템플릿에 전송\n7. 템플릿은 ui를 만들어서 웹브라우저에 넘겨주게 된다.\n\n*이렇게 복잡한 과정들이 있는 것은 특정 영역을 분리하는게 중요하기 때문!*\n\n## project와 App\n\n프로젝트 = 웹 사이트\n의미있는 하나의 기능을 app이라고 구성\n\n    $ django-admin startprojec (project name)\n\n이렇게 명령어를 입력하면\n\n    manage.py(실행파일)\n    project name(디렉토리)\n        __init__.py\n        settings.py(전체 프로젝트를 관리하는 설정파일)\n        urls.py\n        wsgi.py\n\n위와 같이 파일 구조가 생깁니다.\n\napp 생성(상위에)\n\n    $ ./manage.py startapp (app name)\n\n다양한 파일 목록이 생깁니다.\n\n    app name\n        admin.py(관리자권한을 가지는 사용자가 볼 수 있는 페이지에 대한 내용을 다룸)\n        __init__.py\n        migrations\n            __init__.py\n        models.py\n        tests.py\n        views.py(데이터를 가공)\n\n### Settings.py\n\n전체적인 프로젝트 환경 설정 파일\n\n`debug`\n에러에 대한 내용을 보고 싶을때 true로 두게 되면 변수의 상태를 확인 할 수 있습니다.\n배포를 할 때는 false(디버깅 내용을 공개하지 않기 위해서), 개발단계에서는 true\n\n`installed_apps`\n    pip로 설치한 앱 또는 본인이 만든 app를 추가\n\n`middelware_classes`\nrequest와 response 사이의 주요 기능 레이어(크게 신경 쓸 필요 없음 - 보안 기능)\n`templates`\ndjango template관련 설정, 실제 뷰(html, 변수)에서 컨트롤해서 다루게 됩니다.\n`databases`\n데이터베이스 설정 파일, 데이터베이스 엔진의 연결 설정(다양한 데이터베이스를 사용할 수 있음)\n`static_url`\n정적파일(js,img,css)들과 관련된 url이나 dict가 관련된 설정파일\n\n### Manage.py\n프로젝트 관리 명령어 모음\n\n`startapp`: 앱생성\n`runserver`: 서버 실행\n`createsuperuser`: 관리자 실행\n`makemigrations app`: app의 모델 변경 사항 체크\n`migrate`: 변경 사항을 DB에 반영\n`shell`: 쉘을 통해 데이터를 확인\n`collectstatic`: static 파일을 한 곳에 모음\n\n    ex) ./manage.py runserver 0.0.0.0:8080\n\n---\n\nref : https://www.essenceandartifact.com/2012/12/the-essence-of-mvc.html\n"},"frontmatter":{"layout":"post","title":"Django/장고는 무엇이고 어떻게 일하는가?","category":"Django","tags":["django"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/network/gRPC:gRPC가 등장하기까지(REST & RPC).md","fields":{"slug":"/cs/network/grpc-01/","categorySlug":"/categories/network/"},"internal":{"content":"gRPC를 공부하려고 많은 글들을 찾아보다가 네이버 클라우드 플랫폼 블로그에서 좋은 글을 찾아 하나씩 써내려가면서 정독해보겠습니다.좋은 글 감사합니다.\n\n# gRPC의 등장배경\n## 1. 아키텍처의 변화\n_**Monolithic >>> Microservice**_\n1970년대 IBM에서 개인용컴퓨터를 생산한 이후 PC라는 개념이 생겼고 하나의 메인 프레임 워크에서 동작하는 `Monolithic구조`로 설계되었습니다.\n시간이 흐르고 기술이 발전하면서 우리가 익히 알고있는 `Server-Client`의 구조를 가지게 되었고, 하나의 메인 프레임워크에서 프로그램이 동작하는 Monolithic 구조에서는 크게 중요하지 않았던 네트워크의 개념이 정리되기 시작합니다.\n\n그렇게 서버 간 혹은 서버와 개인 PC간 네트워크 연결/통신이 중요해지면서 IOS 7 layer, TCP/IP 등 네트워크 계층 구조가 정의되고 발전하기 시작합니다.\n\n## 2. RPC의 등장\n### IPC와 Socket\n실행되고 있는 컴퓨터 프로그램을 말하는 프로세스는 기본적으로 상호독립적입니다. 즉, 메모리를 공유하지않고 서로 간섭을 하지 않습니다. 하지만 필요에 따라 프로세스간 정보를 교환해야하는 경우가 있습니다. 이때 별도 수단을 이용하여 프로세스 간 통신하는 방법론을 IPC(Iner Process Communication)이라고 합니다.\n\nIPC기법에는 여러가지가 있지만 Socket에 대해서 살펴보겠습니다.\nSocket이란, 앞서 언급한 OSI 7 layer 구조의 L7계층(Application Layer)에서 L4계층(Transport Port)의 TCP 또는 UDP를 이용하기 위한 수단입니다. 일종의 창구라고 생각하면 됩니다. 우리는 온라인을 PC와 PC의 네트워크 통신이라고 알고 있지만, 조금 더 정확히 이야기하면 출발지 프로세스와 도착지 프로세스가 통신을 하는 IPC방법으로 통신한다고 이야기 하는게 정확합니다.\n\nSocket을 통해서 무언가를 개발 해 본 분들은 알겠지만 언어에서 지원해주는 API가 있어서 쉬운 것처럼 보이지만 client-server 통신과정을 직접구현해야하는 어려움을 가지고 있습니다. 통신 장애와 같은 많은 부분들이 개발자의 능력과 직결됩니다. 서비스가 고도화 될 수록 많은 데이터가 돌아다니게 될텐데, 이에 따라 data formatting을 하는 것도 점점 어려워지게 됩니다.\n\n### RPC\nsocket의 어려움을 극복하기 위해 RPC(Remote Procedure Call)라는 기술이 등장합니다. 이름 그대로 네트워크로 연결된 서버 상의 프로시저(함수, 메서드 등)를 원격으로 호출할 수 있는 기능입니다.\nRPC의 목적은 통신에 신경쓰지 않고, 원격지의 자원을 사용하는데에 있습니다.\n\n#### RPC에서 사용되는 개념\n- IDL(Interface Definication Laguage)\n: 서로 다른 언어로 작성된 여러 서비스들 사이에서 공통된 인터페이스를 정의하기 위한 중간 인터페이스 정의 언어\n- stub\n: 서버와 클라이언트는 서로 다른 주소 공간을 사용하므로, 함수 호출에 사용된 매개 변수를 꼭 변화해주어야 합니다. 그렇지 않으면 메모리 매개변수에 대한 포인터가 다른 데이터를 가리키게 됩니다. 이러한 변환을 담당하는게 stub입니다.\n\n> `client stub의 역할`\n함수 호출에 사용된 파라미터의 변환(Mashalling) 및 함수 실행 후 서버에서 전달 된 결과의 반환\n> `server stub의 역할`\n클라이언트가 전달한 매개 변수의 역변환(Unmashalling) 및 함수 실행 결과 변환을 담당\n\n#### RPC의 통신과정\n1. IDL(Interface Definition Language)을 사용하여 호출 규약을 정의합니다.\n함수명, 인자, 반환값에 대한 데이터형이 정의된 IDL 파일을 rpcgen으로 컴파일하면 stub code가 자동으로 생성됩니다.\n2. Stub Code에 명시된 함수는 원시코드의 형태로, 상세 기능은 server에서 구현됩니다.\n만들어진 stub 코드는 클라이언트/서버에 함께 빌드합니다.\n\n3. client에서 stub 에 정의된 함수를 사용할 때,\n4. client stub은 RPC runtime을 통해 함수 호출하고\n5. server는 수신된 procedure 호출에 대한 처리 후 결과 값을 반환합니다.\n6. 최종적으로 Client는 Server의 결과 값을 반환받고, 함수를 Local에 있는 것 처럼 사용할 수 있습니다.\n\n생각보다 통신과정이 복잡합니다. 많은 이점이 있지만 결국 구현이 어렵고, 지원 기능의 한계 등으로 제대로 활용되지 못했습니다. 그러다 Web을 활용해보려는 시도가 이어졌고 `REST`가 등장하게 됩니다\n\n## 3. REST의 등장\nREST(REpresentational State Transfer)는 HTTP/1.1을 기반으로 URI를 통해 모든 자원(Resource)을 명시하고 HTTP Method를 통해 처리하는 아키텍처입니다.\nHTTP Method와 payload의 합은 매우 명시적이고 쉽게 사용할 수 있다는 장점이 있어서 보편화된 방식입니다.\n하지만 REST에도 한계는 존재합니다.REST는 일종의 스타일이지 표준이 아니기 때문에 parameter와 응답 값이 명시적이지 않습니다. 또한 HTTP 메소드의 형태가 제한적이기 때문에 세부 기능 구현에는 제약이 있습니다.\n덧붙여 웹 데이터 전달 format으로 json을 많이 사용합니다. 간결한 `key-value` 구조를 기반으로 동작하고 사람이 읽기 좋은 string이기 때문입니다. 하지만 제공되는 자료형의 한계로 파싱 후 추가 형변환을 하는 작업이 필요한 경우가 많다는 점, string의 형태이기 때문에 데이터 통신/처리를 위한 serialize과정이 빠질 수 없다는 단점이 있습니다.\n\n# gRPC\ngRPC는 google사에서 개발한 오픈소스 RPC(Remote Procedure Call) 프레임워크입니다. 이전까지는 RPC 기능은 지원하지 않고, 메세지(JSON 등)을 Serialize할 수 있는 프레임워크인 PB(Protocol Buffer)만을 제공해왔는데, PB기반 Serializer에 HTTP/2를 결합하여 PRC 프레임워크를 탄생시켰습니다.\n\n**(HTTP/2와 PB에 대한 설명은 다른 포스트에서 설명하도록 하겠습니다)**\n\n여기까지가 gRPC가 탄생하게된 배경과 gRPC에 대한 소개입니다.\n다음 포스트에서는 gRPC에 대해 더 자세히 이야기하도록 하겠습니다.\n\n---\n참고: https://blog.naver.com/n_cloudplatform/221751268831\n"},"frontmatter":{"layout":"post","title":"gRPC/gRPC가 등장하기까지(REST & RPC)","category":"network","tags":["gRPC"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/etc/algorithm/Algorithm:bubble sort.md","fields":{"slug":"/etc/algorithm/bubble-sort","categorySlug":"/categories/algorithm/"},"internal":{"content":"버블정렬에 대해서 알아봅시다.\n\n# 버블정렬의 핵심 IDEA\n\n1. 전체 elements의 개수가 n 이라면, 두 개씩 비교하게 되므로 loop의 범위를 n-1로 합니다.\n2. 비교가 끝나면 제일 큰 요소가 확정되는데, 확정된 요소를 제외하고 loop를 돌면됩니다.\n\n```python\nfor index in range(데이터 길이 - 1):  #✅1\n    for index_2 in range(데이터 길이 - loop 회수 - 1):  #✅2\n        if 앞 데이터 > 뒤 데이터:  #✅3\n            스왑  #✅4\n```\n\n> ✅1: 데이터길이-1 만큼 outer loop range를 지정한다.<br>\n> ✅2: i번 돌면 i개의 요소를 제외하고 inner loop를 진행하면 된다.<br>\n> ✅3: 조건 확인<br>\n> ✅4: swap<br>\n\n---\n\n# 추가 IDEA\n이미 정렬 되어져 있다면 = swap이 한 번도 발생하지 않았다면, 그 다음 loop를 진행하지 않아도 됩니다.<br>\n어떻게 알 수 있을까요? -> 상태를 확인하는 변수를 하나 만들자!\n\n---\n\n# 구현\n```python\ndef bubble_sort(data):\n    for i in range(len(data) - 1):\n        is_swaped = False\n        for j in range(len(data) - i - 1):\n            if data[j] > data[j + 1]:\n                data[j], data[j + 1] = data[j + 1], data[j]\n                is_swaped = True\n\n        if is_swaped is False:\n            break\n    return data\n```\n\n---\n\n# 결과\n```python\nimport random\n\ndata = random.sample(range(100),10)\nbubble_sort(data)\n\n# [3, 15, 17, 20, 28, 50, 55, 63, 70, 76]\n```\n\n## 시간 복잡도 계산\nloop 안에서 loop를 진행하므로 O(n<sup>2</sup>)<br>\n이미 정렬된 상태라면 O(n)\n"},"frontmatter":{"layout":"post","title":"Algorithm/버블 정렬(bubble sort with python)","category":"Algorithm","tags":["Algorithm","bubble-sort"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/Django:select_related와 prefetch_related를.md","fields":{"slug":"/python/django/select-related-and-prefetch_related/","categorySlug":"/categories/django/"},"internal":{"content":"select_related와 prefetch_related를 알아봅시다.\n\n\nDjango의 유저라면 select\\_related와 prefetch\\_related를 모를 수 없을 것입니다. 하지만 얼마나 잘\n사용하고 있는지는 의문점을 가져봐야 합니다. 저 또한 그런 의문이 들었기에 이번 포스트를 작성하게\n되었습니다.<br>\n<br>\n설명을 위한 모델은 다음과 같습니다.\n\n```python\n# app/models.py\n\nfrom django.db import models\n\n\nclass Publisher(models.Model):\n    name = models.CharField(max_length=255)\n\n    def __str__(self):\n        return self.name\n\n\nclass Book(models.Model):\n    name = models.CharField(max_length=255)\n    price = models.IntegerField(default=0)\n    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE, related_name='books')\n\n    def __str__(self):\n        return self.name\n\n\nclass Store(models.Model):\n    name = models.CharField(max_length=255)\n    books = models.ManyToManyField(Book, related_name='stores')\n\n    def __str__(self):\n        return self.name\n```\n\n설명을 위한 데이터를 다음 조건에 맞춰서 만들 것입니다.<br>\n<br>\n100개의 book이 있고, 5개의 publisher는 각 publisher당 20개씩 출판했습니다. 그리고\n10개의 매장에서 10개씩 판매중 입니다. custom command를 통해서 데이터를 insert 할 예정입니다.\n`python manage.py insert`\n\n```python\n# app/management/commands/insert.py\n\nimport random\n\nfrom django.core.management.base import BaseCommand\n\nfrom ...models import Publisher, Store, Book\n\n\nclass Command(BaseCommand):\n    \"\"\"\n    이 커맨드는 5개의 Publisher, 100개의 books와 10개의 Stores를 DB에 insert합니다.\n    \"\"\"\n\n    def handle(self, *args, **options):\n        Publisher.objects.all().delete()\n        Book.objects.all().delete()\n        Store.objects.all().delete()\n\n        # create 5 publishers\n        publishers = [Publisher(name=f\"Publisher{index}\") for index in range(1, 6)]\n        Publisher.objects.bulk_create(publishers)\n\n        # create 20 books for every publishers\n        counter = 0\n        books = []\n        for publisher in Publisher.objects.all():\n            for i in range(20):\n                counter = counter + 1\n                books.append(Book(name=f\"Book{counter}\", price=random.randint(50, 300), publisher=publisher))\n\n        Book.objects.bulk_create(books)\n\n        # create 10 stores and insert 10 books in every store\n        books = list(Book.objects.all())\n        for i in range(10):\n            temp_books = [books.pop(0) for i in range(10)]\n            store = Store.objects.create(name=f\"Store{i+1}\")\n            store.books.set(temp_books)\n            store.save()\n```\n\n그리고 보기 좋게 정리하기 위한 데코레이터를 작성합니다.\n```python\nimport time\nimport functools\n\nfrom django.db import connection, reset_queries\n\n\ndef query_debugger(func):\n\n    @functools.wraps(func)\n    def inner_func(*args, **kwargs):\n\n        reset_queries()\n\n        start_queries = len(connection.queries)\n\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        end = time.perf_counter()\n\n        end_queries = len(connection.queries)\n\n        print(f\"Function : {func.__name__}\")\n        print(f\"Number of Queries : {end_queries - start_queries}\")\n        print(f\"Finished in : {(end - start):.2f}s\")\n        return result\n\n    return inner_func\n```\n\n\n\n# select\\_related\n`select_related`는 관련된 단일객체를 가져오는데, 정참조일 때에는 `ForeignKey, OneToOne`, 역참조 일때에는 `OneToOne`일 때에 사용합니다.<br>\n<br>\n`select_related`를 SQL로 풀어보면 `Inner Join`을 하여 관련 개체의 필드를 `Select` 문에 포함시켜서 관련 개체를 얻습니다.\n\n## bad\n\n```python\nfrom query_debugger import query_debugger\n\n@query_debugger\ndef book_list():\n\n    queryset = Book.objects.all()\n\n    books = []\n    for book in queryset:  # queryset 평가\n        books.append({\n            'id': book.id,\n            'name': book.name,\n            'publisher': book.publisher.name\n            }\n        )\n    # book.publisher에 접근, 캐싱되지 않은 데이터이므로 query 발생\n\n    return books\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : book_list\nNumber of Queries : 101\nFinished in : 0.05s\n```\n\n하나의 쿼리가 모든 책에 접근하고 반복하는 동안 ForeignKey로 연결된 `Publisher`에 각각 접근하여 쿼리가 실행됩니다.<br>\n<br>\n실제로 sql을 보면\n\n1. book에 접근하는 쿼리 1\n2. book에 해당하는 publisher에 접근하는 쿼리 100개\n\n`총 101개`의 쿼리가 실행됩니다.\n\n## good\n\n`select_related`를 사용해서 결과를 확인해 봅시다.\n\n```python\n@query_debugger\ndef book_list():\n\n    queryset = Book.objects.select_related(\"publisher\").all()\n\n    books = []\n    for book in queryset:  # queryset 평가\n        books.append({\n            'id': book.id,\n            'name': book.name,\n            'publisher': book.publisher.name\n            }\n        )\n\n    return books\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : book_list\nNumber of Queries : 1\nFinished in : 0.00s\n```\n\nPublisher를 Inner Join으로 하나의 쿼리로 가져온결과, 101개 에서 1개로 쿼리가 줄었습니다!\n\n# 정참조에서의 prefetch\\_related(ManyToMany)\n\n## Example1\n`prefetch_related`는 두개의 테이블을 가져와서 **Python에서 Join을 합니다.**\n정참조일 때에는 `ManyToMany` 역참조일 때에는 `ForeignKey, ManyToMany`일 때에 사용합니다.<br>\n\n## bad\n\n```python\n@query_debugger\ndef store_list():\n\n    queryset = Store.objects.all()\n\n    stores = []\n    for store in queryset:  # 쿼리셋 평가\n        books = [book.name for book in store.books.all()]  # 각 store마다 books로 접근, 쿼리 발생\n        stores.append({\n            'id': store.id,\n            'name': store.name,\n            'books': books\n            }\n        )\n\n    return stores\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : store_list\nNumber of Queries : 11\nFinished in : 0.01s\n```\n\nSQL은 다음과 같습니다.\n\n```sql\nSELECT \"bookstore_store\".\"id\", \"bookstore_store\".\"name\"\nFROM \"bookstore_store\"\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE \"bookstore_store_books\".\"store_id\" = 1\n\n...\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE \"bookstore_store_books\".\"store_id\" = 10\n```\n\n데이터베이스 내에는 10개의 상점이 있고 각각 10권의 책을 가지고 있습니다. 쿼리가 어떻게 되었는지 살펴보면\n일단 하나의 쿼리로 모든 상점들을 fetch해오고 반복문을 돌면서 하나의 상점에서 각각 쿼리를 발생시켜 books에 접근을 했습니다.\n그래서 1 + 10 과같은 결과를 가져온 것입니다.\n\n## good\n\n`prefetch_related`를 사용하여 결과를 살펴봅시다\n\n```python\n@query_debugger\ndef store_list():\n\n    queryset = Store.objects.prefetch_related(\"books\").all()\n\n    stores = []\n    for store in queryset:\n        books = [book.name for book in store.books.all()]\n        stores.append({'id': store.id, 'name': store.name, 'books': books})\n\n    return stores\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : store_list\nNumber of Queries : 2\nFinished in : 0.01s\n```\n\nSQL은 다음과 같습니다.\n\n`prefetch_related`를 사용한 결과는 SQL을 살펴보면 조금 더 빠르게 이해할 수 있을 것 같습니다.\n\n```sql\nSELECT \"bookstore_store\".\"id\", \"bookstore_store\".\"name\"\nFROM \"bookstore_store\"\n\nSELECT (\"bookstore_store_books\".\"store_id\") AS \"_prefetch_related_val_store_id\", \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE \"bookstore_store_books\".\"store_id\"\nIN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)'\n```\n\n`prefetch_related`를 사용하지 않았을 때와 다른 점은 두번째 쿼리에서 store의 id 값들을 가져와서 In을 사용한다는 것입니다. 이것을 통해서 여러번\n매칭 하였던 것을 한 번으로 줄여서 1 + 1과 같은 결과를 가져왔습니다.\n\n## Example2\n\n이번에는 필터를 사용한 결과를 살펴봅시다.\n\n## bad\n\n```python\n@query_debugger\ndef store_list():\n\n    queryset = Store.objects.prefetch_related(\"books\").all()\n\n    stores = []\n    for store in queryset:\n        books = [book.name for book in store.books.filter(price__range=(250,300))]\n        stores.append({'id': store.id, 'name': store.name, 'books': books})\n\n    return stores\n```\n\n결과는 다음과 같습니다\n\n```\nFunction : store_list\nNumber of Queries : 12\nFinished in : 0.01s\n```\n\nSQL은 다음과 같습니다\n\n```sql\nSELECT \"bookstore_store\".\"id\", \"bookstore_store\".\"name\"\nFROM \"bookstore_store\"\n\nSELECT (\"bookstore_store_books\".\"store_id\") AS \"_prefetch_related_val_store_id\", \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE \"bookstore_store_books\".\"store_id\" IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)'\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE (\"bookstore_store_books\".\"store_id\" = 1 AND \"bookstore_book\".\"price\" BETWEEN 250 AND 300)\n\n...\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE (\"bookstore_store_books\".\"store_id\" = 10 AND \"bookstore_book\".\"price\" BETWEEN 250 AND 300)\n```\n\n조건이 추가되자 조건을 필터링하는 구문을 포함한 쿼리가 추가로 실행되었습니다.\n1 + 1 + 10 총 12개의 쿼리가 발생했습니다.\n\n## good\n\nPrefetch를 사용하여 다시 작성해보도록 합시다\n\n```python\n@query_debugger\ndef store_list():\n\n    queryset = Store.objects.prefetch_related(\n        Prefetch(\"books\", queryset=Book.objects.filter(price__range=(250, 300))))\n\n    stores = []\n    for store in queryset:\n        books = [book.name for book in store.books.all()]\n        stores.append({'id': store.id, 'name': store.name, 'books': books})\n\n    return stores\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : store_list\nNumber of Queries : 2\nFinished in : 0.00s\n```\n\nSQL은 다음과 같습니다.\n\n```sql\nSELECT \"bookstore_store\".\"id\", \"bookstore_store\".\"name\"\nFROM \"bookstore_store\"\n\nSELECT (\"bookstore_store_books\".\"store_id\") AS \"_prefetch_related_val_store_id\", \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nINNER JOIN \"bookstore_store_books\"\nON (\"bookstore_book\".\"id\" = \"bookstore_store_books\".\"book_id\")\nWHERE (\"bookstore_book\".\"price\" BETWEEN 250 AND 300 AND \"bookstore_store_books\".\"store_id\" IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n```\n\nPrefetch를 사용하니까 별도의 쿼리를 작성했던 WHERE를 AND로 묶어서 하나의 쿼리를 생성했습니다.\n\n# 역참조에서의 prefetch\\_related\n\n## Example1\n\n**부모와 관련된 자식 데이터를 가져올 때**<br>\n<br>\n이번에는 역참조입니다. 지금까지 사용한 관계에서 예를 들면 Publisher가 출간한 book들을 조회할 때에 사용할 수 있습니다.\n\n## bad\n\n```python\n@query_debugger\ndef publisher_list():\n\n    queryset = Publisher.objects.all()\n\n    publishers = []\n    for publisher in queryset:\n        books = [book.name for book in publisher.books.all()]\n        publishers.append({'id': publisher.id, 'name': publisher.name, 'books': books})\n\n    return publishers\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : publisher_list\nNumber of Queries : 6\nFinished in : 0.00s\n```\n\nSQL은 다음과 같습니다.\n\n```sql\nSELECT \"bookstore_publisher\".\"id\", \"bookstore_publisher\".\"name\"\nFROM \"bookstore_publisher\"\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nWHERE \"bookstore_book\".\"publisher_id\" = 1\n\n...\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nWHERE \"bookstore_book\".\"publisher_id\" = 5\n```\n\n일단 Publisher를 가져오는 쿼리 1개, book중에서 publisher의 id와 동일한 book을 가져오는 쿼리 5개(1~5까지)\n총 6개입니다.\n\n## good\n\n역참조에서 `prefetch_related`를 사용해봅시다.\n\n```python\n@query_debugger\ndef publisher_list():\n\n    queryset = Publisher.objects.prefetch_related(\"books\")\n\n    publishers = []\n    for publisher in queryset:\n        books = [book.name for book in publisher.books.all()]\n        publishers.append({'id': publisher.id, 'name': publisher.name, 'books': books})\n\n    return publishers\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : publisher_list\nNumber of Queries : 2\nFinished in : 0.00s\n```\n\nSQL은 다음과 같습니다.\n\n```sql\nSELECT \"bookstore_publisher\".\"id\", \"bookstore_publisher\".\"name\"\nFROM \"bookstore_publisher\"\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nWHERE \"bookstore_book\".\"publisher_id\" IN (1, 2, 3, 4, 5)\n```\n\n동일하게 Publisher를 가져오는 쿼리 1개, 위 와다르게 book에 WHERE ~ IN을 사용한 쿼리 1개로 총 2개가 되었습니다.\n\n## Example2\n\n**자식 테이블에 조건을 걸어서 조건에 해당하는 부모객체를 가져올 때**<br>\n<br>\n250~300에 출간한 책들을 가지고 있는 출판사 데이터를 가져와봅시다. 배운바에 의하면 역참조를 위해\n`prefetch_related`를 사용하고 필터를 걸어야합니다.\n\n## bad\n\n```python\n@query_debugger\ndef publisher_list():\n\n    queryset = Publisher.objects.prefetch_related(\"books\").filter(books__price__range=(250,3 00))\n\n    publishers = []\n    for publisher in queryset:\n        publishers.append({'id': publisher.id, 'name': publisher.name})\n\n    return publishers\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : publisher_list\nNumber of Queries : 2\nFinished in : 0.01s\n```\n\nSQL 다음과 같습니다.\n- 첫번째 SQL은 publisher에 book을 inner join 해서 가져옵니다. 그리고\n그 book의 조건은 250~300사이의 가격을 형성하고 있다는 것 입니다. 해당하는 publisher들을 가져옵니다.\n- 두번째 SLQ은 book을 가져오는데 여기서 in 조건에 들어간 id들은 첫번째 sql에서 나온 결과에 해당하는\npublisher의 id입니다. 해당 publisher에게 속해있는 모든 책들을 가져옵니다.\n\n```sql\nSELECT \"bookstore_publisher\".\"id\", \"bookstore_publisher\".\"name\"\nFROM \"bookstore_publisher\"\nINNER JOIN \"bookstore_book\"\nON (\"bookstore_publisher\".\"id\" = \"bookstore_book\".\"publisher_id\")\nWHERE \"bookstore_book\".\"price\" BETWEEN 250 AND 300\n\nSELECT \"bookstore_book\".\"id\", \"bookstore_book\".\"name\", \"bookstore_book\".\"price\", \"bookstore_book\".\"publisher_id\"\nFROM \"bookstore_book\"\nWHERE \"bookstore_book\".\"publisher_id\" IN (1, 2, 4, 5)\n```\n\n## good\n\n```python\n@query_debugger\ndef publisher_list():\n\n    queryset = Publisher.objects.filter(books__price__range=(250,300))\n\n    publishers = []\n    for publisher in queryset:\n        publishers.append({'id': publisher.id, 'name': publisher.name})\n\n    return publishers\n```\n\n결과는 다음과 같습니다.\n\n```\nFunction : publisher_list\nNumber of Queries : 1\nFinished in : 0.00s\n```\n\nsql을 살펴보면 이전의 첫번째 sql과 동일합니다. 어떻게 된 일일까요\n\n```sql\nSELECT `bookstore_publisher`.`id`, `bookstore_publisher`.`name`\nFROM `bookstore_publisher`\nINNER JOIN `bookstore_book`\nON (`bookstore_publisher`.`id` = `bookstore_book`.`publisher_id`)\nWHERE `bookstore_book`.`price` BETWEEN 250 AND 300\n```\n\ndjango의 query 소스코드를 봅시다.\n\n```python\ndef demote_joins(self, aliases):\n    \"\"\"\n    Change join type from LOUTER to INNER for all joins in aliases.\n\n    Similarly to promote_joins(), this method must ensure no join chains\n    containing first an outer, then an inner join are generated. If we\n    are demoting b->c join in chain a LOUTER b LOUTER c then we must\n    demote a->b automatically, or otherwise the demotion of b->c doesn't\n    actually change anything in the query results. .\n    \"\"\"\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type == LOUTER:\n            self.alias_map[alias] = self.alias_map[alias].demote()\n            parent_alias = self.alias_map[alias].parent_alias\n            if self.alias_map[parent_alias].join_type == INNER:\n                aliases.append(parent_alias)\n```\n\n소스 코드를 보면 chain join이 없으면 inner join으로 쿼리를 하도록 강제하고 있기 때문입니다.<br>\n<br>\n많은 블로그 내용들을 하나로 모아보았습니다. 귀한 내용을 공유해주신 개발자님들께 다시한번 감사를 드립니다.\n\n---\n\nref: [Django 나만의 Management Command 만들어보기](https://blog.myungseokang.dev/posts/make-django-custom-command/)<br>\nref: [Python decorator에 @wraps를 사용해야 하는 이유](https://cjh5414.github.io/wraps-with-decorator/)<br>\nref: [Django select_related and prefetch_related](https://medium.com/better-programming/django-select-related-and-prefetch-related-f23043fd635d)<br>\nref: [당신이 몰랐던 Django Prefetch.](https://medium.com/chrisjune-13837/%EB%8B%B9%EC%8B%A0%EC%9D%B4-%EB%AA%B0%EB%9E%90%EB%8D%98-django-prefetch-5d7dd0bd7e15)\n"},"frontmatter":{"layout":"post","title":"Django/select_related와 prefetch_related를 정복해보자","category":"Django","tags":["django"]}}}]}}}