{"data":{"allMarkdownRemark":{"edges":[{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/DRF:#01 DRF란 무엇인가?.md","fields":{"slug":"/python/django/drf-01/","categorySlug":"/categories/django/"},"internal":{"content":"DRF에 대해서 간략하게 알아봅시다.\n\n\n### DRF?\n\n공식문서에서 설명하는 DRF입니다.\n> DRF는 Web API를 만들기 위한 강력하고 유연한 툴입니다.<br>\n우리가 DRF를 써야하는 이유가 몇 가지 있습니다.\n> - Web browsable API는 개발자들에게 큰 유용성을 가져다줍니다.\n> - Serialization은 ORM과 non-ORM 데이터 소스를 모두 지원합니다.\n> - 강력한 View도 있지만 일반적인 View를 커스터마이징 해서 사용할 수 있습니다.\n> - DRF를 사용하는 많은 유저들이 있기때문에, 문서와 커뮤니티를 제공할 수 있습니다.\n> - 국제적인 기업들에서 사용하고 있습니다.\n\n<br>\n\n다른 이는 이렇게 말하기도 합니다.\n> DRF는 개발자가 만든 API들을 디버그하기 쉽게 만들어줍니다. DRF의 큰 기능은 **Models를 serializers로 변환하는 것**입니다. DRF에서 serializers는 복잡한 구조들을 이미 구성해두었습니다.\n> serializers는 모델을 전달하고, 그 모델들을 json 객체로 변환하는 것만이 전부가 아닙니다. 클라이언트로부터 백엔드에게 데이터를 전달하기도합니다. 코드를 검증하는 것도 자동으로 할 수 있습니다. 코드를 정리해서 security issues를 해결하기도 합니다.\n\n<br>\n\n많은 사람들이 설명하는 DRF는 무엇일까요?\n> Django 안에서 RESTful API 서버를 쉽게 구축할 수 있도록 도와주는 오픈소스 라이브러리입니다.\n\n### Serializer\n\n[직렬화(serialisation)는 무엇인가]()\n\n직렬화에 대한 설명은 위의 글을 읽어보길 바랍니다.<br>\n<br>\n파이썬 형식의 코드를 다른 네트워크 환경과 통신을 위해 코드를 직렬화 해야하는데,\nDRF에서 그것을 담당하는 클래스가 바로 `Serializer`입니다. DRF에서 제공하는 Serializer는\nqueryset, model instance 등의 복잡한 데이터를 JSON, XML 등의 컨텐트 타입으로 쉽게 변환 가능한\npython datatype으로 변환시켜줍니다.<br>\n\n**RESTful API와 Serializer가 DRF를 사용하는 가장 큰 장점이 아닐까 생각합니다.**\n"},"frontmatter":{"layout":"post","title":"DRF/#01 DRF란 무엇인가?","category":"Django","tags":["DRF"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/cs/network/gRPC:gRPC가 등장하기까지(REST & RPC).md","fields":{"slug":"/cs/network/grpc-01/","categorySlug":"/categories/network/"},"internal":{"content":"gRPC를 공부하려고 많은 글들을 찾아보다가 네이버 클라우드 플랫폼 블로그에서 좋은 글을 찾아 하나씩 써내려가면서 정독해보겠습니다.좋은 글 감사합니다.\n\n# gRPC의 등장배경\n## 1. 아키텍처의 변화\n_**Monolithic >>> Microservice**_\n1970년대 IBM에서 개인용컴퓨터를 생산한 이후 PC라는 개념이 생겼고 하나의 메인 프레임 워크에서 동작하는 `Monolithic구조`로 설계되었습니다.\n시간이 흐르고 기술이 발전하면서 우리가 익히 알고있는 `Server-Client`의 구조를 가지게 되었고, 하나의 메인 프레임워크에서 프로그램이 동작하는 Monolithic 구조에서는 크게 중요하지 않았던 네트워크의 개념이 정리되기 시작합니다.\n\n그렇게 서버 간 혹은 서버와 개인 PC간 네트워크 연결/통신이 중요해지면서 IOS 7 layer, TCP/IP 등 네트워크 계층 구조가 정의되고 발전하기 시작합니다.\n\n## 2. RPC의 등장\n### IPC와 Socket\n실행되고 있는 컴퓨터 프로그램을 말하는 프로세스는 기본적으로 상호독립적입니다. 즉, 메모리를 공유하지않고 서로 간섭을 하지 않습니다. 하지만 필요에 따라 프로세스간 정보를 교환해야하는 경우가 있습니다. 이때 별도 수단을 이용하여 프로세스 간 통신하는 방법론을 IPC(Iner Process Communication)이라고 합니다.\n\nIPC기법에는 여러가지가 있지만 Socket에 대해서 살펴보겠습니다.\nSocket이란, 앞서 언급한 OSI 7 layer 구조의 L7계층(Application Layer)에서 L4계층(Transport Port)의 TCP 또는 UDP를 이용하기 위한 수단입니다. 일종의 창구라고 생각하면 됩니다. 우리는 온라인을 PC와 PC의 네트워크 통신이라고 알고 있지만, 조금 더 정확히 이야기하면 출발지 프로세스와 도착지 프로세스가 통신을 하는 IPC방법으로 통신한다고 이야기 하는게 정확합니다.\n\nSocket을 통해서 무언가를 개발 해 본 분들은 알겠지만 언어에서 지원해주는 API가 있어서 쉬운 것처럼 보이지만 client-server 통신과정을 직접구현해야하는 어려움을 가지고 있습니다. 통신 장애와 같은 많은 부분들이 개발자의 능력과 직결됩니다. 서비스가 고도화 될 수록 많은 데이터가 돌아다니게 될텐데, 이에 따라 data formatting을 하는 것도 점점 어려워지게 됩니다.\n\n### RPC\nsocket의 어려움을 극복하기 위해 RPC(Remote Procedure Call)라는 기술이 등장합니다. 이름 그대로 네트워크로 연결된 서버 상의 프로시저(함수, 메서드 등)를 원격으로 호출할 수 있는 기능입니다.\nRPC의 목적은 통신에 신경쓰지 않고, 원격지의 자원을 사용하는데에 있습니다.\n\n#### RPC에서 사용되는 개념\n- IDL(Interface Definication Laguage)\n: 서로 다른 언어로 작성된 여러 서비스들 사이에서 공통된 인터페이스를 정의하기 위한 중간 인터페이스 정의 언어\n- stub\n: 서버와 클라이언트는 서로 다른 주소 공간을 사용하므로, 함수 호출에 사용된 매개 변수를 꼭 변화해주어야 합니다. 그렇지 않으면 메모리 매개변수에 대한 포인터가 다른 데이터를 가리키게 됩니다. 이러한 변환을 담당하는게 stub입니다.\n\n> `client stub의 역할`\n함수 호출에 사용된 파라미터의 변환(Mashalling) 및 함수 실행 후 서버에서 전달 된 결과의 반환\n> `server stub의 역할`\n클라이언트가 전달한 매개 변수의 역변환(Unmashalling) 및 함수 실행 결과 변환을 담당\n\n#### RPC의 통신과정\n1. IDL(Interface Definition Language)을 사용하여 호출 규약을 정의합니다.\n함수명, 인자, 반환값에 대한 데이터형이 정의된 IDL 파일을 rpcgen으로 컴파일하면 stub code가 자동으로 생성됩니다.\n2. Stub Code에 명시된 함수는 원시코드의 형태로, 상세 기능은 server에서 구현됩니다.\n만들어진 stub 코드는 클라이언트/서버에 함께 빌드합니다.\n\n3. client에서 stub 에 정의된 함수를 사용할 때,\n4. client stub은 RPC runtime을 통해 함수 호출하고\n5. server는 수신된 procedure 호출에 대한 처리 후 결과 값을 반환합니다.\n6. 최종적으로 Client는 Server의 결과 값을 반환받고, 함수를 Local에 있는 것 처럼 사용할 수 있습니다.\n\n생각보다 통신과정이 복잡합니다. 많은 이점이 있지만 결국 구현이 어렵고, 지원 기능의 한계 등으로 제대로 활용되지 못했습니다. 그러다 Web을 활용해보려는 시도가 이어졌고 `REST`가 등장하게 됩니다\n\n## 3. REST의 등장\nREST(REpresentational State Transfer)는 HTTP/1.1을 기반으로 URI를 통해 모든 자원(Resource)을 명시하고 HTTP Method를 통해 처리하는 아키텍처입니다.\nHTTP Method와 payload의 합은 매우 명시적이고 쉽게 사용할 수 있다는 장점이 있어서 보편화된 방식입니다.\n하지만 REST에도 한계는 존재합니다.REST는 일종의 스타일이지 표준이 아니기 때문에 parameter와 응답 값이 명시적이지 않습니다. 또한 HTTP 메소드의 형태가 제한적이기 때문에 세부 기능 구현에는 제약이 있습니다.\n덧붙여 웹 데이터 전달 format으로 json을 많이 사용합니다. 간결한 `key-value` 구조를 기반으로 동작하고 사람이 읽기 좋은 string이기 때문입니다. 하지만 제공되는 자료형의 한계로 파싱 후 추가 형변환을 하는 작업이 필요한 경우가 많다는 점, string의 형태이기 때문에 데이터 통신/처리를 위한 serialize과정이 빠질 수 없다는 단점이 있습니다.\n\n# gRPC\ngRPC는 google사에서 개발한 오픈소스 RPC(Remote Procedure Call) 프레임워크입니다. 이전까지는 RPC 기능은 지원하지 않고, 메세지(JSON 등)을 Serialize할 수 있는 프레임워크인 PB(Protocol Buffer)만을 제공해왔는데, PB기반 Serializer에 HTTP/2를 결합하여 PRC 프레임워크를 탄생시켰습니다.\n\n**(HTTP/2와 PB에 대한 설명은 다른 포스트에서 설명하도록 하겠습니다)**\n\n여기까지가 gRPC가 탄생하게된 배경과 gRPC에 대한 소개입니다.\n다음 포스트에서는 gRPC에 대해 더 자세히 이야기하도록 하겠습니다.\n\n---\n참고: https://blog.naver.com/n_cloudplatform/221751268831\n"},"frontmatter":{"layout":"post","title":"gRPC/gRPC가 등장하기까지(REST & RPC)","category":"network","tags":["gRPC"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/etc/algorithm/Algorithm:bubble sort.md","fields":{"slug":"/etc/algorithm/bubble-sort","categorySlug":"/categories/algorithm/"},"internal":{"content":"버블정렬에 대해서 알아봅시다.\n\n# 버블정렬의 핵심 IDEA\n\n1. 전체 elements의 개수가 n 이라면, 두 개씩 비교하게 되므로 loop의 범위를 n-1로 합니다.\n2. 비교가 끝나면 제일 큰 요소가 확정되는데, 확정된 요소를 제외하고 loop를 돌면됩니다.\n\n```python\nfor index in range(데이터 길이 - 1):  #✅1\n    for index_2 in range(데이터 길이 - loop 회수 - 1):  #✅2\n        if 앞 데이터 > 뒤 데이터:  #✅3\n            스왑  #✅4\n```\n\n> ✅1: 데이터길이-1 만큼 outer loop range를 지정한다.<br>\n> ✅2: i번 돌면 i개의 요소를 제외하고 inner loop를 진행하면 된다.<br>\n> ✅3: 조건 확인<br>\n> ✅4: swap<br>\n\n---\n\n# 추가 IDEA\n이미 정렬 되어져 있다면 = swap이 한 번도 발생하지 않았다면, 그 다음 loop를 진행하지 않아도 됩니다.<br>\n어떻게 알 수 있을까요? -> 상태를 확인하는 변수를 하나 만들자!\n\n---\n\n# 구현\n```python\ndef bubble_sort(data):\n    for i in range(len(data) - 1):\n        is_swaped = False\n        for j in range(len(data) - i - 1):\n            if data[j] > data[j + 1]:\n                data[j], data[j + 1] = data[j + 1], data[j]\n                is_swaped = True\n\n        if is_swaped is False:\n            break\n    return data\n```\n\n---\n\n# 결과\n```python\nimport random\n\ndata = random.sample(range(100),10)\nbubble_sort(data)\n\n# [3, 15, 17, 20, 28, 50, 55, 63, 70, 76]\n```\n\n## 시간 복잡도 계산\nloop 안에서 loop를 진행하므로 O(n<sup>2</sup>)<br>\n이미 정렬된 상태라면 O(n)\n"},"frontmatter":{"layout":"post","title":"Algorithm/버블 정렬(bubble sort with python)","category":"Algorithm","tags":["Algorithm","bubble-sort"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/articles/python/django/Django:장고는 무엇이고 어떻게 일하는가?.md","fields":{"slug":"/python/django/what-is-django-and-how-to-work-it/","categorySlug":"/categories/django/"},"internal":{"content":"Django는 무엇이고 어떻게 동작하는지 알아봅시다.\n\n![django_flow_02](./images/django_flow_02.png)\n\nDjango는 현재 가장 많이 사용되는 파이썬 웹 프레임워크입니다.\n2003년 로렌스 저널-월드 신문을 만들던 웹 개발팀의 내부 프로젝트로 시작됐으며, 오픈소스 프로젝트로\n공개되었습니. 그리고 구글의 앱 엔진에서 장고를 사용하면서 많은 사람들이 사용하게 되었고, 현재는\n파이썬의 대표적인 웹 프레임워크로 자리매김하고 있습니다.\n\n장고는 MVC를 기반으로 한 프레임 워크입니다. 장고에서는 View를 Template, Controller를 view라고 부릅니다.\n\nView는 데이터를 가져오고 변형하는 컴포넌트, Template는 데이터를 사용자에게 보여주는 컴포넌트입니다.\n그래서 장고를 흔히 MTV 프레임워크라고 부르기도합니다.\n\n- Model\n    안전하게 데이터를 저장\n- View\n    데이터를 적절하게 유저에게 보여줌\n    = 데이터를 유저에게 보내줄 때 유저가 원하는 형태로 형태로 보내주는 것을 담당\n- Control, Template(Django)\n    사용자의 입력과 이벤트에 반응하여 Model과 View를 업데이트(수정)\n\n## Django 개념\n###  장고의 workflow\n![django_flow_01](./images/django_flow_01.png)\n\n\n1. 웹 브라우저에서 이벤트가 발생 (url을 클릭하거나, 어떤 form에 data를 입력 등)\n\n2. 장고 서버로 data가 들어오고 'url dispatcher'에서 user가 요청한 url을 분석하고\n    그에 적합한 view로 보내준다.\n3. view는 사용자의 요청을 받아서, DB 어디에 접근해서, 어떤 데이터를 가공해야할 지 모델에 알려주면\n4. 모델에서 실질적인 DB와 커넥션을 하고 데이터를 가져오게 된다.\n5. DB에서 모델에 다시 데이터를 보내고\n6. 모델이 뷰에 데이터를 보내주고 뷰가 실질적으로 user에게 보여줄 데이터를 템플릿에 전송\n7. 템플릿은 ui를 만들어서 웹브라우저에 넘겨주게 된다.\n\n*이렇게 복잡한 과정들이 있는 것은 특정 영역을 분리하는게 중요하기 때문!*\n\n## project와 App\n\n프로젝트 = 웹 사이트\n의미있는 하나의 기능을 app이라고 구성\n\n    $ django-admin startprojec (project name)\n\n이렇게 명령어를 입력하면\n\n    manage.py(실행파일)\n    project name(디렉토리)\n        __init__.py\n        settings.py(전체 프로젝트를 관리하는 설정파일)\n        urls.py\n        wsgi.py\n\n위와 같이 파일 구조가 생깁니다.\n\napp 생성(상위에)\n\n    $ ./manage.py startapp (app name)\n\n다양한 파일 목록이 생깁니다.\n\n    app name\n        admin.py(관리자권한을 가지는 사용자가 볼 수 있는 페이지에 대한 내용을 다룸)\n        __init__.py\n        migrations\n            __init__.py\n        models.py\n        tests.py\n        views.py(데이터를 가공)\n\n### Settings.py\n\n전체적인 프로젝트 환경 설정 파일\n\n`debug`\n에러에 대한 내용을 보고 싶을때 true로 두게 되면 변수의 상태를 확인 할 수 있습니다.\n배포를 할 때는 false(디버깅 내용을 공개하지 않기 위해서), 개발단계에서는 true\n\n`installed_apps`\n    pip로 설치한 앱 또는 본인이 만든 app를 추가\n\n`middelware_classes`\nrequest와 response 사이의 주요 기능 레이어(크게 신경 쓸 필요 없음 - 보안 기능)\n`templates`\ndjango template관련 설정, 실제 뷰(html, 변수)에서 컨트롤해서 다루게 됩니다.\n`databases`\n데이터베이스 설정 파일, 데이터베이스 엔진의 연결 설정(다양한 데이터베이스를 사용할 수 있음)\n`static_url`\n정적파일(js,img,css)들과 관련된 url이나 dict가 관련된 설정파일\n\n### Manage.py\n프로젝트 관리 명령어 모음\n\n`startapp`: 앱생성\n`runserver`: 서버 실행\n`createsuperuser`: 관리자 실행\n`makemigrations app`: app의 모델 변경 사항 체크\n`migrate`: 변경 사항을 DB에 반영\n`shell`: 쉘을 통해 데이터를 확인\n`collectstatic`: static 파일을 한 곳에 모음\n\n    ex) ./manage.py runserver 0.0.0.0:8080\n\n---\n\nref : https://www.essenceandartifact.com/2012/12/the-essence-of-mvc.html\n"},"frontmatter":{"layout":"post","title":"Django/장고는 무엇이고 어떻게 일하는가?","category":"Django","tags":["django"]}}}]}}}