{"data":{"allMarkdownRemark":{"edges":[{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/js/2019-04-25-es6_basic3/index.md","fields":{"slug":"/etc/es6-basic-3/","categorySlug":"/categories/js/"},"internal":{"content":"# es6 basic 3\n[코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)\n\n채널에서 보고 정리한 글입니다.\n\n---\n\n\n[WONISM's Blog](https://wonism.github.io/javascript-iteration-protocol/) 블로그 참고\n\nIterables vs Iterator\n\n- iterable 프로토콜은 반복 가능한 **객체를** 나타내는 프로토콜\n- iterator 프로토콜은 반복 가능한 **객체의 값**을 시퀸스대로 처리하는 프로토콜\n\n## Interface in JS\n\n1. 인터페이스란 사양에 맞는 값과 연결된 속성키의 셋트\n2. 어떤 Object라도 인터페이스의 정의를 충족시킬 수 있다.\n3. 하나의 Object는 여러개의 인터페이스를 충족시킬 수 있다.\n\n### Interface Test\n\n1. test라는 키를 갖고\n2. 값으로 문자열인자를 1개 받아 불린결과를 반환하는 함수가 온다.\n\n    {\n      test(str){return true;}\n    }\n\n## Iterator Interface\n\n1. next라는 키를 갖고\n2. 값으로 인자를 받지 않고 IteratorResultObject를 반환하는 함수가 온다.\n3. IteratorResultObject는 value와 done이라는 키를 갖고 있다.\n4. 이중done은계속반복할수있을지없을지에따라불린값을반환한다.\n\n    {\n    \tnext(){\n    \treturn {value:1, done:false}; }\n    }\n    \n    {\n      data:[1,2,3,4],\n      next(){\n    \t\treturn { \n    \t\t\tdone:this.data.length == 0, \n    \t\t\tvalue:this.data.pop()\n    \t\t}; \n    \t}\n    }\n\n## Iterable Interface\n\n1. Symbol.iterator라는 키를 갖고\n2. 값으로 인자를 받지 않고 Iterator Object를 반환하는 함수가 온다.\n\n    {\n    \t[Symbol.iterator](){\n    \t\treturn { \n    \t\t\t\tnext(){\n    \t        return {value:1, done:false};\n    \t\t\t\t}\n        };\n    \t} \n    }\n\n## Loop to iterator\n\nstatement(문) : 엔진한테 주는 힌트 , 실행하고 나면 흔적도 없이 사라진다.\n\nexpression(식): 메모리에 남고, 언제든지 조회, 참조 할 수 있다.\n\nfor, while 은 문이다.\n\niterator 는 loop 를 식으로 바꾸고 싶어서 사용한다.\n\n## while문으로 살펴보는 Iterator\n\n    let arr = [1, 2, 3, 4];\n    while(arr.length > 0){ //계속 반복할지 판단\n    \tconsole.log(arr.pop()); //반복시 처리할 것\n    }\n    // 4 \n    // 3 \n    // 2 \n    // 1\n\nIterator Interface\n\n    {\n    \tarr:[1, 2, 3, 4], \n    \tnext(){\n    \t\treturn {\n    //self descrition\n    //계속 반복할지 판단\n    \t\tdone:this.arr.length == 0,  \n    //반복시 처리할 것\n    \t\tvalue:console.log(this.arr.pop())\n    \t\t}; \n    \t}\n    }\n\n1. 반복자체를 하지는 않지만\n2. 외부에서반복을하려고할때\n3. 반복에 필요한 조건과 실행을\n4. 미리준비해둔객체\n\n→\n\n반복행위와 반복을 위한 준비를 분리\n\n→\n\n1. 미리반복에대한준비를해두고\n2. 필요할 때 필요한만큼 반복\n3. 반복을재현할수있음\n\n## es6+ Loop\n\n- 사용자반복처리기직접 Iterator 반복처리기를 구현\n\n    const loop = (iter, f) => {\n      //Iterable이라면 Iterator를 얻음\n        if(typeof iter[Symbol.iterator] == 'function'){\n          iter = iter[Symbol.iterator]();\n      }\n      //IteratorObject가 아니라면 건너뜀\n        if(typeof iter.next != 'function') return;\n      do{\n      const v = iter.next(); if(v.done) return; //종료처리 f(v.value); //현재 값을 전달함\n      }while(true); \n    };\n    \n    const iter = {\n      arr:[1, 2, 3, 4],\n      [Symbol.iterator](){return this;}, next(){\n      return { \n        done:this.arr.length == 0, \n        value:this.arr.pop()\n    };\n    loop(iter, console.log);\n    //4 \n    //3 \n    //2 \n    //1\n\n- 내장반복처리기\n\nArray destructuring (배열해체)\n\n    const iter = {\n      [Symbol.iterator]() {\n        return this;\n      },\n      arr: [1, 2, 3, 4],\n      next() {\n        return { done: this.arr.length == 0, value: this.arr.pop() };\n      }\n    };\n    \n    const [a, ...b] = iter;\n    console.log(a, b);\n    // 4, [3, 2, 1]\n\nSpread (펼치기)\n\n    const iter = {\n      [Symbol.iterator]() {\n        return this;\n      },\n      arr: [1, 2, 3, 4],\n      next() {\n        return { done: this.arr.length == 0, value: this.arr.pop() };\n      }\n    };\n    const a = [...iter];\n    console.log(a);\n    // [4, 3, 2, 1]\n\nRest Parameter (나머지인자)\n\n    const iter = {\n      [Symbol.iterator]() {\n        return this;\n      },\n      arr: [1, 2, 3, 4],\n      next() {\n        return { done: this.arr.length == 0, value: this.arr.pop() };\n      }\n    };\n    const test = (...arg) => console.log(arg);\n    test(...iter);\n    // [4, 3, 2, 1]\n\nFor of (문 - 권한이 거의 없는 문)\n\n    const iter = {\n      [Symbol.iterator]() {\n        return this;\n      },\n      arr: [1, 2, 3, 4],\n      next() {\n        return { done: this.arr.length == 0, value: this.arr.pop() };\n      }\n    };\n    for (const v of iter) {\n      console.log(v);\n    }\n    //4 //3 //2 //1\n\n---\n\n## 블로킹(Blocking)\n\n프로그램은 노이만 머신(메모리)에 적재되면 쉴 틈 없이 실행되고, 우리는 간섭하지 못한다. \n\n이러한 상태를 동기 명령이라고 한다. 동기 명령이란 한번 적재된 명령어를 한번에 쭉 실행되는 것을 말한다.  \n\n동기 명령어가 실행되는 것을  관찰하는 것이 flow 이다. \n\n동기 명령어가 실행되고 있을 때에는 cpu를 건들 일 수 없다. cpu 를 못 건들 이는 현상을 block(blocking)이라고 한다.\n\n블로킹을 걸 수 있는 범위는 5초 이내이다.\n\n시간 동안 얼만큼 많은 일을 할 수 있는 지는 cpu 클럭 수, 비트 수에 달려 있다.\n\nloop 가 길면 블로킹으로 걸면 안된다.(os, 브라우저 가 실행을 종료 해버린다.) Generator cpu 를 sleep을 걸어 주어 release 하여 다른 작업을 할 수 있게 해야 한다.\n\n node 에서는 nexttick() 브라우저에서는 request animation frame 이나 setTimeout() 이 있다.\n\n무한 루프가 없도록 limit 를 걸어 줘야 한다.\n\nIterator 를 만들때 done 의 limit 를 설정해줘야 한다.\n\nex) next() {\n        if (cursor > max) \n\n}\n\n---\n\n## practice\n\n제곱을 요소로 갖는 가상컬렉션\n\n    const N2 = class {\n      constructor(max) {\n        this.max = max;\n      }\n      [Symbol.iterator]() {\n        let cursor = 0,\n          max = this.max;\n        return {\n          done: false,\n          next() {\n    //함수는 함수 바깥쪽의 변수를 캡쳐할 수 있는 권한이 있다. 이를 free value (자유변수)라고 한다.\n    //자유 변수가 갇히(가두)면 클로져라고 한다.\n            if (cursor > max) {\n              this.done = true;\n            } else {\n              this.value = cursor * cursor;\n              cursor++;\n            }\n            return this;\n          }\n        };\n      }\n    };\n    \n    console.log([...new N2(5)]);\n    //[0, 1, 4, 9, 16]\n    \n    for (const v of new N2(5)) {\n      console.log(v);\n    }\n    // 0\n    // 1\n    // 4\n    // 9\n    // 16\n\n## Generator\n\n[자바스크립트 제너레이터의 재미](https://medium.com/@jooyunghan/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%9E%AC%EB%AF%B8-246553cadfbd) 블로그 참고\n\nIterator의 구현을 돕는 Generator\n\nGenerator 는 호출 할때 마다 iterator 가 만들어 진다.\n\nGenerator가 만드는 **iterator 는 동시에 Iterable** 이기도 한다.\n\nGenerator는 yield 이때 잠깐 suspension 이 생겨  coroutine 이라고도 한다. 일반적인 함수는 은 routine 이라고 한다.\n\n(iterator 는 동시에 Iterable 이기에 for of 를 이용 할 수 있다.)\n\n(for of 는 Generator를 사용 할 수 없다.)\n\n배열은 for of 로 돌아간다. === 배열 === Iterable, Symbol.iterator를 호출 하면 배열이 나온다. === 배열 ===iterator\n\n    const N2 = class {\n      constructor(max) {\n        this.max = max;\n      }\n      [Symbol.iterator]() {\n        let cursor = 0,\n          max = this.max;\n        return {\n          done: false,\n          next() {\n            if (cursor > max) {\n              this.done = true;\n            } else {\n              this.value = cursor * cursor;\n              cursor++;\n            }\n            return this;\n          }\n        };\n      }\n    };\n    \n    const generator = function*(max) {\n      let cursor = 0;\n      while (cursor < max) {\n        yield cursor * cursor;\n    //yield 이때 잠깐 suspension 이 생겨 \n    //iterator result object 를 반환해준다. \n        cursor++;\n      }\n    };\n    console.log([...generator(5)]);\n    //[0, 1, 4, 9, 16]\n    for (const v of generator(5)) {\n      console.log(v);\n    }\n    //0 \n    //1 \n    //4 \n    //9 \n    //16"},"frontmatter":{"layout":"post","title":"ES6 Basic 3","category":"js","tags":["Iterator","Iterable","Interface","Generator"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/js/2019-04-30-es6_basic4/index.md","fields":{"slug":"/etc/es6-basic-4/","categorySlug":"/categories/js/"},"internal":{"content":"# es6 basic 4\n[코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)\n\n채널에서 보고 정리한 글입니다.\n\n---\n\n\n# abstract loop & lazy execution\n\n# abstract loop\n\niterator 루프의 제어권을 객체로 넘길수 있다.\n\n## complex recursion\n\n단순한 배열을 루프인 경우는 간단히 이터레이션을 작성할 수 있음.\n\n    {\n      [Symbol.iterator](){return this;},\n      data:[1,2,3,4], \n      next(){\n         return {\n           done:this.data.length == 0,\n           value:this.data.shift()\n        }; \n      }\n    }\n\n복잡한 다층형 그래프는 어떻게 이터레이션할 것인가?\n\n    {\n      [Symbol.iterator](){return this;},\n      data:[{a:[1,2,3,4], b:'-'}, [5,6,7], 8, 9], next(){\n      return ???; }\n    }\n\n    {\n      [Symbol.iterator](){return this;},\n      data:[{a:[1,2,3,4], b:'-'}, [5,6,7], 8, 9],\n      next (){\n        let v;\n        while(v = this.data.shift()){\n          switch(true){\n          case Array.isArray(v):\n            this.data.unshift(...v);\n        break;\n        case v && typeof v == 'object':\n            for(var k in v) this.data.unshift(v[k]);\n            break;\n          default:\n            return {value:v, done:false};\n          }\n        }\n      return {done:true}; \n      }\n    }\n\nes6 로 변경\n\n[//cla](//class)ss Compx {} 는 let 이다.\n\n[[Javascript] typeof 와 instanceof의 차이, 타입 또는 클래스 구분하기](https://unikys.tistory.com/260)\n\n    const Compx = class {\n      constructor(data) {\n        this.data = data;\n      }\n      [Symbol.iterator]() {\n        const data = JSON.parse(JSON.stringify(this.data));\n        //완전한 복사된다. 깊은복사 보다 빠르다 언어의 c 가 처리한다.\n        return {\n          next() {\n            let v;\n            while ((v = data.shift())) {\n              if (!v && !(v instanceof Object)) return { value: v };\n              if (!Array.isArray(v)) v = Object.values(v);\n              data.unshift(...v);\n            }\n            return { done: true };\n          }\n        };\n      }\n    };\n    const a = new Compx([{ a: [1, 2, 3, 4], b: '-' }, [5, 6, 7], 8, 9]);\n    console.log([...a]);\n    console.log([...a]);\n\n    const Compx = class {\n      constructor(data) {\n        this.data = data;\n      }\n      *gene() {\n        const data = JSON.parse(JSON.stringify(this.data));\n        let v;\n        while ((v = data.shift())) {\n          if (!v && !(v instanceof Object)) yield v;\n          else {\n            if (!Array.isArray(v)) v = Object.values(v);\n            data.unshift(...v);\n          }\n        }\n      }\n    };\n    const a = new Compx([{ a: [1, 2, 3, 4], b: '-' }, [5, 6, 7], 8, 9]);\n    console.log([...a.gene()]);\n    console.log([...a.gene()]);\n\n# abstract loop\n\n다양한구조의루프와무관하게해당값이나상황의개입만하고싶은경우\n\n    (data, f) => {\n      let v;\n      while ((v = data.shift())) {\n        if (!(v instanceof Object)) f(v);\n        else {\n          if (!Array.isArray(v)) v = Object.values(v);\n          data.unshift(...v);\n        }\n      }\n    };\n\n제어문을 재활용할 수 없으므로 중복정의할 수 밖에 없다.\n\n    (data, f) => {\n      let v;\n      while ((v = data.shift())) {\n        values(v);\n        if (!(v instanceof Object)) {\n          //v로 뭔가 하는 부분\n          console.log(v); //console 추가\n          f(v);\n        } else {\n          if (!Array.isArray(v)) v = Object.values(v);\n          data.unshift(...v);\n        }\n      }\n    };\n\n결국 제어문을 직접 사용할 수 없고 구조객체를 이용해 루프실행기를 별도로 구현\n\n    (data, f) => {\n      let v;\n      //루프 공통 골격\n      while ((v = data.shift())) {\n        if (!(v instanceof Object)) {\n          //개발 구조 객체\n          f(v);\n        } else {\n          //개발 구조 객체\n          if (!Array.isArray(v)) v = Object.values(v);\n          data.unshift(...v);\n        }\n      }\n    };\n\n팩토리 + 컴포지트\n\n    const Operator = class {\n      static factory(v) {\n        if (v instanceof Object) {\n          if (!Array.isArray(v)) v = Object.values(v);\n          return new ArrayOp(v.map(v => Operator.factory(v)));\n        } else return new PrimaOp(v);\n      }\n      constructor(v) {\n        this.v = v;\n      }\n      operation(f) {\n        throw 'override';\n      }\n    };\n    const PrimaOp = class extends Operator {\n      constructor(v) {\n        super(v);\n      }\n      operation(f) {\n        f(this.v);\n      }\n    };\n    const ArrayOp = class extends Operator {\n      constructor(v) {\n        super(v);\n      }\n      operation(f) {\n        for (const v of this.v) v.operation(f);\n      }\n    };\n    Operator.factory([1, 2, 3, { a: 4, b: 5 }, 6, 7]).operation(console.log);\n\n![](Untitled-fcc6028e-3648-4362-b39e-416f67411649.png)\n\n팩토리 + 컴포지트 + ES6 Iterable\n\n[generator yield*](https://bblog.tistory.com/313)\n\n[yield from - 다른 제너레이터에게 작업을 위임하기 · Wireframe](https://soooprmx.com/archives/8679)\n\n    const Operator = class {\n      static factory(v) {\n        if (v instanceof Object) {\n          if (!Array.isArray(v)) v = Object.values(v);\n          return new ArrayOp(v.map(v => Operator.factory(v)));\n        } else return new PrimaOp(v);\n      }\n      constructor(v) {\n        this.v = v;\n      }\n      *gene() {\n        throw 'override';\n      }\n    };\n    const PrimaOp = class extends Operator {\n      constructor(v) {\n        super(v);\n      }\n      *gene() {\n        yield this.v;\n      }\n    };\n    const ArrayOp = class extends Operator {\n      constructor(v) {\n        super(v);\n      }\n      *gene() {\n        for (const v of this.v) yield* v.gene();\n        //yield* v.gene() (위임 yield 설명)\n        // yield는 내것을 반환하고 중지한다.\n        // yield* v.gene() 모든 것들을 yield처리 하고 문이 넘어간다\n      }\n    };\n    for (const v of Operator.factory([1, 2, 3, { a: 4, b: 5 }, 6, 7]).gene())\n      console.log(v);\n\n![](Untitled-79493470-28e9-42f4-8ae1-3acd9aeeaeb5.png)\n\n## lazy execution\n\n## yield\n\n    const odd = function*(data) {\n      for (const v of data) {\n        console.log('odd', odd.cnt++);\n        if (v % 2) yield v;\n      }\n    };\n    odd.cnt = 0;\n    //1번째\n    console.log('-----------------1번째-----------------');\n    for (const v of odd([1, 2, 3, 4])) console.log(v);\n    \n    const take = function*(data, n) {\n      for (const v of data) {\n        console.log('take', take.cnt++);\n        if (n--) yield v;\n        else break;\n      }\n    };\n    take.cnt = 0;\n    //2번째\n    console.log('-----------------2번째-----------------');\n    for (const v of take([1, 2, 3, 4], 2)) console.log(v);\n    \n    odd.cnt = 0;\n    take.cnt = 0;\n    //3번째\n    console.log('-----------------3번째-----------------');\n    for (const v of take(odd([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), 2)) console.log(v);\n\n1. 결과\n\n    ![](Untitled-8ad7fc4d-2e5d-4b23-bea4-2218ffaedb79.png)\n\n2. 결과\n\n    ![](Untitled-cea9dd1a-917a-4e84-b71c-0ac012276338.png)\n\n3. 결과 \n\n    (yield 체인의 결과가 효율이 높다.)\n\n    코루틴의 서스팬션을 이용한 경우\n\n    ![](Untitled-3d4078b4-f719-4ee1-8c34-0d08121ff728.png)\n\n## yield*\n\n    const Stream = class {\n      static get(v) {\n        return new Stream(v);\n      }\n      constructor(v) {\n        this.v = v;\n        this.filters = [];\n      }\n      add(gene, ...arg) {\n        this.filters.push(v => gene(v, ...arg));\n        return this;\n      }\n      *gene() {\n        let v = this.v;\n        for (const f of this.filters) v = f(v);\n        yield* v;\n      }\n    };\n    \n    const odd = function*(data) {\n      for (const v of data) if (v % 2) yield v;\n    };\n    const take = function*(data, n) {\n      for (const v of data)\n        if (n--) yield v;\n        else break;\n    };\n    for (const v of Stream.get([1, 2, 3, 4])\n      .add(odd)\n      .add(take, 2) //커링\n      .gene())\n      console.log(v);\n\n![](Untitled-dd7e9d37-8560-4460-ba16-cddc5c44b9f0.png)\n\n[커링 함수 (Curring function)](https://webclub.tistory.com/6?category=501390)"},"frontmatter":{"layout":"post","title":"ES6 Basic 4","category":"js","tags":["커링","Yield"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/java/2019-07-15---JAVA-순열/index.md","fields":{"slug":"/etc/permutation/","categorySlug":"/categories/java/"},"internal":{"content":"\n# [JAVA]-순열(Permutation)\n\n## TMI\n\n[[온라인 스터디] 코딩테스트와 실무 역량 모두 잡는 알고리즘 스터디(Java) 2기 | 프로그래머스](https://programmers.co.kr/learn/courses/10004)\n\n시작부터 TMI 가 시작된다. 프로그래머스에서 진행하는 코딩테스트-JAVA 를 온라인 스터디 진행하면서 배운 내용을 정리 한다.\n\n[알고리즘 연습 - 소수 만들기 | 프로그래머스](https://school.programmers.co.kr/courses/10022/lessons/58131)\n\n내가 풀었던 문제 중 소수 만들기 문제를 풀면서 조합을 만들기 위해 Picker 클래스를 만들게 되었다. Picker 클래스를 만들면서 조합과 순열을 만드는 방법이 크게 다르지 않아 이번에는 순열을 만들어 주는 Permutation 클래스를 만들어 보았다.\n\n## n개중 r개를 선택하여 순열 만들기\n\n> 예시\n\n- int[] numbers = {1,2,3};\n- 집합에서 2개의 순열을 구하는 경우\n- [[1, 2], [1, 3], [2,1], [2,3], [3,2], [3,1]]\n\n- 집합에서 3(모든)개의 순열을 구하는 경우\n\n    [[1, 2,3], [1, 3,2], [2,1,3], [2,3,1], [3,2,1], [3,1,2]]가 될것이다.\n\n    ![](Untitled-0e2d06e6-f0b4-4073-a43d-9bc523d823f1.png)\n    > 순열을 만드는 방법은 선택할 (앞에서 순차적인)인덱스와 교환될 인덱스를 선택하여 교환(switch)하는 과정을 반복적으로 실행하여 순열을 만들어 낼 수 있다. 순열은 depth level === [선택된/ 고정된]index 와 동일하다.\n\n## 소스코드 (Permutation 클래스 설명)\n\n- 필드\n\n        private T[] array; //제네릭 타입\n        private List<T[]> selectedPermutationList; // 반환할 리스트\n        //ex) [[1, 2], [1, 3], [2,1], [2,3], [3,2], [3,1]]\n\n- getSelectedList()\n\n        List<T[]> getSelectedPermutationList(int selecteCount) {\n            doPermutation(Arrays.copyOf(array, array.length), 0, selecteCount);\n            return selectedPermutationList;\n        }\n\n    - 순열 리스트를 반환하는 메소드\n    - `int selecteCount` 를 입력 받아 몇 개 선택할지 인자로 받는다.\n    - doPermutation() 를 실행하여 순열을 만든다.\n- doPermutation()\n\n        private void doPermutation(T[] values, int depth, int selecteCount) {\n            final int arrayLength = values.length;\n        \n            if (depth == selecteCount) {\n                addSelectedValueList(Arrays.copyOf(values, selecteCount));\n                return;\n            }\n            for (int index = depth; index < arrayLength; index++) {\n                T[] swapedArray = getSwapedArray(values, index, depth);\n                doPermutation(swapedArray, depth + 1, selecteCount);\n            }\n        }\n\n    - `if (depth == selecteCount)` 반환 조건 (선택한 갯수 === depth level)\n    - `int depth` 는 선택된 index 와 같다.\n\n### 전체 소스코드\n\n    class Permutation<T> {\n          private T[] array;\n          private List<T[]> selectedPermutationList;\n    \n          Permutation(T[] array) {\n              this.array = array;\n              selectedPermutationList = new ArrayList<>();\n          }\n    \n          List<T[]> getSelectedPermutationList(int selecteCount) {\n              doPermutation(Arrays.copyOf(array, array.length), 0, selecteCount);\n              return selectedPermutationList;\n          }\n    \n          private void addSelectedValueList(T[] values) {\n              selectedPermutationList.add(values);\n          }\n    \n          private void doPermutation(T[] values, int depth, int selecteCount) {\n              final int arrayLength = values.length;\n    \n              if (depth == selecteCount) {\n                  addSelectedValueList(Arrays.copyOf(values, selecteCount));\n                  return;\n              }\n              for (int index = depth; index < arrayLength; index++) {\n                  T[] swapedArray = getSwapedArray(values, index, depth);\n                  doPermutation(swapedArray, depth + 1, selecteCount);\n              }\n          }\n    \n          T[] getSwapedArray(T[] arr, int depthIndex, int indexToExchanged) {\n              T temp = arr[depthIndex];\n              arr[depthIndex] = arr[indexToExchanged];\n              arr[indexToExchanged] = temp;\n              return Arrays.copyOf(arr, arr.length);\n          }\n      }\n\n### Permutation 클래스 사용법\n\n    int[] nums = {1, 2, 3};\n    Integer[] values = Arrays.stream(nums).boxed().toArray(Integer[]::new);\n    \n    List<Integer[]> combinationNumberList = new Permutation(values).getSelectedPermutationList(2);\n    for (Integer[] arr : combinationNumberList) {\n        System.out.println(Arrays.toString(arr));\n    }\n\n## PS\n\n- 지난번 Picker 클래스의 getSelectedCombinationList()의 리턴타입은 Set in List 타입이었다. 이후에는 array in List 타입으로 추천을 했었기 때문에 Permutation 클래스의 getSelectedPermutationList() 의 리턴타입은 array in List 타입으로 변경해 보았다.\n- 순열과 조합을 만드는 과정은 매우 유사해 보인다. 코드를 더 줄일 수도 있지만 개인적으로(머리가 좋지 않아서ㅠㅠ) 이러한 코드가 실행 과정이 더 잘 보이는 것 같다.\n- 다음번엔 Map 클래스에 대해 공부할 예정이다. (..여러 구현체가 있었군..)\n- 공부한 내용을 정리 해야되는데...열심히 해야겠다..(#정리짤 #평화 #깔끔)\n\n    ![](Untitled-02504320-5869-4c35-ba90-5d7037b452c8.png)\n\n\n---\n\n참고 사이트\n\n[순열(Permutation) 알고리즘](https://gorakgarak.tistory.com/522)"},"frontmatter":{"layout":"post","title":"JAVA-순열(Permutation)","category":"java","tags":["permutation","재귀"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/java/2019-07-14---JAVA-조합/index.md","fields":{"slug":"/etc/combination/","categorySlug":"/categories/java/"},"internal":{"content":"\n# [JAVA]-조합(Combination)\n\n![](Untitled-8ea39325-eb25-4417-a718-de94f245cb85.png)\n\n## TMI\n\n[코딩테스트와 실무 역량 모두 잡는 알고리즘 스터디(Java) 2기 | 프로그래머스](https://programmers.co.kr/learn/courses/10004)\n\n시작부터 TMI 가 시작된다. 프로그래머스에서 진행하는 코딩테스트-JAVA 를 온라인 스터디 진행하면서 배운 내용을 정리 한다. \n\n[알고리즘 연습 - 소수 만들기 | 프로그래머스](https://school.programmers.co.kr/courses/10022/lessons/58131)\n\n내가 풀었던 문제 중 소수 만들기 문제를 풀면서 조합을 만들기 위해 Picker 클래스를 만들게 되었다. 피드백을 받아 제네릭을 사용하여 범용성있는 클래스를 구성해보았다.\n\n## n개중 r개를 선택하는 방법의 수\n\n![](Untitled-b3e8d277-9451-4ee5-8121-bb2065f42d88.png)\n\n> 예시\n\n- int[] numbers = {1,2,3};\n- 집합에서 2개의 조합을 구하는 경우 (순서x, 중복x)\n- [[1, 2], [1, 3], [2, 3]]\n\n- 순서나 중복을 허용했다면\n\n    [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]] 가 될것이다.(하지만 조합은 순서x 중복x )\n\n![](Untitled-23491a6c-d4cf-4be3-8c03-ffb44db7c9a9.png)\n> 선택된 숫자는 Stack에 넣는 것 처럼 생각하면 이해하기가 쉽다고 생각한다.\n\n## 조합 점화식\n\n![](Untitled-8ad919e7-0ef8-4616-b1ef-1c99a9d19334.png)\n\n1. 선택하여 뽑은 경우 [n-1 C r-1]\n\n    > ex) 1을 뽑은경우 , 전체 갯수, 뽑아야 될 숫자 각각 1씩 감소, n개에서 1개를 뽑혔기 때문에 n-1 개중에서 현재 index를 선택한 경우 r-1 (선택,뽑을 수 있는 갯수)\n\n2. 선택하지 않고 뽑지 않은 경우 [n-1 C r]\n\n    > ex) 이전에 1을 뽑지 않은경우, 전체 갯, n개에서 1개를 뽑혔기 때문에 n-1 개중에서 현재 index를 선택하지 않았을 경우 r(선택,뽑을 수 있는 갯수)\n\n- n개중 r를 선택하는 조합: 1의 경우와 2의 경우 (경우의 수:합의 법칙)\n\n## 소스코드 (Picker 클래스 설명)\n\n- 필드\n\n        private T[] array; //제네릭 타입\n        private List<Set<T>> selectedCombinationList; // 반환할 리스트\n        //ex) [[1, 2], [1, 3], [2, 3]]\n\n- getSelectedCombinationList()\n\n          List<Set<T>> getSelectedCombinationList(selecteCount) {\n              Stack<T> selectedNumber = new Stack<>();\n              doCombination(array.length, selecteCount, 0, selectedNumber);\n              return selectedCombinationList;\n          }\n    - 조합 리스트를 반환하는 메소드\n    - `int selecteCount` 를 입력 받아 몇 개 선택할지 인자로 받는다.\n    - doCombination() 를 실행하여 조합을 만든다.\n\n\n- doCombination()\n\n        private void doCombination(int totalCount, int selecteCount, int index, Stack<T> selectedNumber) {\n            Stack<T> stackOfSelectValue = new Stack<>();\n            stackOfSelectValue.addAll(selectedNumber);\n        \n            if (selecteCount == 0) {\n                addSelectedValueList(selectedNumber);\n            } else if (totalCount == selecteCount) {\n                for (int i = 0; i < totalCount; i++) {\n                    selectedNumber.add(array[index + i]);\n                }\n                addSelectedValueList(selectedNumber);\n            } else {\n                stackOfSelectValue.add(array[index]);\n                doCombination(totalCount - 1, selecteCount - 1, index + 1, stackOfSelectValue);\n        \n                stackOfSelectValue.pop();\n                doCombination(totalCount - 1, selecteCount, index + 1, stackOfSelectValue);\n            }\n        }\n\n    - 재귀 함수\n    - `if (selecteCount == 0)` 더이상 뽑을 수가 없는 경우\n    - `else if (totalCount == selecteCount)` 모두 선택할 경우\n    - `else` 일반 적인 경우 (재귀 실행할 구문)\n        1. 선택할 경우\n        2. 선택하지 않을 경우\n\n        ![](Untitled-23491a6c-d4cf-4be3-8c03-ffb44db7c9a9.png)\n        > 개인적으로 선택된 숫자는 Stack에 넣는 것이 동작 방식을 이해하기 쉬웠다. 굳이 stack을 사용할 필요는 없었다. array나 list 나 set 도 가능하기도 하다.\n\n### 전체 소스코드\n\n    class Picker<T> {\n        private T[] array;\n        private List<Set<T>> selectedCombinationList;\n    \n        Picker(T[] array) {\n            this.array = array;\n            selectedCombinationList = new ArrayList<>();\n        }\n    \n        List<Set<T>> getSelectedCombinationList(int selecteCount) {\n            Stack<T> selectedNumber = new Stack<>();\n            doCombination(array.length, selecteCount, 0, selectedNumber);\n            return selectedCombinationList;\n        }\n    \n        private void addSelectedValueList(Stack<T> selectedNumber) {\n            Set<T> selectedNumbers = new HashSet<>(selectedNumber);\n            selectedCombinationList.add(selectedNumbers);\n        }\n    \n        private void doCombination(int totalCount, int selecteCount, int index, Stack<T> selectedNumber) {\n            Stack<T> stackOfSelectValue = new Stack<>();\n            stackOfSelectValue.addAll(selectedNumber);\n    \n            if (selecteCount == 0) {\n                addSelectedValueList(selectedNumber);\n            } else if (totalCount == selecteCount) {\n                for (int i = 0; i < totalCount; i++) {\n                    selectedNumber.add(array[index + i]);\n                }\n                addSelectedValueList(selectedNumber);\n            } else {\n                stackOfSelectValue.add(array[index]);\n                doCombination(totalCount - 1, selecteCount - 1, index + 1, stackOfSelectValue);\n    \n                stackOfSelectValue.pop();\n                doCombination(totalCount - 1, selecteCount, index + 1, stackOfSelectValue);\n            }\n        }\n    }\n\n### Picker 클래스 사용법\n\n    int[] nums = {1, 2, 3};\n    Integer[] numbers = Arrays.stream(nums).boxed().toArray(Integer[]::new);\n    List<Set<Integer>> combinationNumberList = new Picker<>(numbers).getSelectedCombinationList(2);\n\n## PS\n\n- `int[] nums` 가 아닌 `String[] name` 와 같이 제네릭타입을 지정하여 여러 타입의 Array 의 조합을 만들수 있게 Pciker 클래스를 작성하였습니다.\n- 조합을 만드는 클래스를 만들어 보았으니 다음은 순열을 만들어 주는 클래스를 만들어 보겠습니다. (조합과 매우 유사합니다.)\n- `List<Set<T>> getSelectedCombinationList(int selecteCount)` 의 반환타입이 `List<Set<T>>` Set in List 인데 반환 타입은 원하는 대로 변경을 해도 괜찮을 것 같다. List in List 를 피하기 위해 Set<T> 로 하였지만 array in List 형식으로 해도 괜찮을 것 같다는 생각을 했다. ex) List<Integer[]>\n\n\n---\n\n참고 사이트\n\n[자바로 만드는 조합(Combination) 알고리즘](https://bumbums.tistory.com/2)\n\n[[Algorithm] JAVA로 중복이 없고, 순서도 없는 조합(Combination) 구하기!](https://limkydev.tistory.com/156)"},"frontmatter":{"layout":"post","title":"JAVA-조합(Combination)","category":"java","tags":["combination","재귀","조합"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---cs/data-structure/2019-11-14---DataStructure-Trie/index.md","fields":{"slug":"/cs/data-structure/trie","categorySlug":"/categories/data-structure/"},"internal":{"content":"\n# Trie 구조 (문자열 검색)\n\nTags: tree, trie, 문자열\n\n![Trie/Untitled.png](Trie/Untitled.png)\n\n## TMI\n\n[코딩테스트 연습 - 가사 검색 | 프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/60060)\n\n오늘도 여김 없이 TMI부터 시작한다. 코딩 테스트 연습을 하면서 알게 된 Trie (트라이) 라는 자료 구조에 대헤 정리 한다. \n\n## Trie-트라이\n\n> 문자열을 효율적으로 탐색하기 위한 자료 구조로 n 진 Tree(트리)형태로 구성되어 있다.\n\n트라이?? 발음은 Try 랑 같다. 잘 모르겠지만 일단 Try 해보자!!\n\n우리가 여러 개의 문자열을 가지고 있을 때, 어떤 문자열이 그 문자열 중 하나인지 알아내는 방법은 뭐가 있을까?단순하게 일일이 비교해보면 된다. 하지만 컴퓨터는 이러한 방법이 매우 비효율적이다. 예를 들어, 최대 길이가\n\nm인 문자열 *n*개의 집합에서 마찬가지로 최대 길이가*m*인 임의의 문자열이 그 문자열들의 집합에 포함되는지를 일일이 확인하면 사전처리는 필요 없지만, 최악의 경우O(nm)의 비교 횟수가 필요하다.\n\n이 문자열을 정렬시킨 뒤, [이진 탐색](https://namu.wiki/w/%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89) 이라는 강력한 알고리즘을 사용하면O(m log n)로 단축시킬 수 있지만, 정렬 과정 자체에 O(n m log n)의 시간이 걸리므로 사양이 안 좋은 컴퓨터라면 이것도 비효율적이다. 하지만 위의 시간 복잡도를 압도하는 알고리즘이 존재한다. 프레드킨이 이름 붙인 \"Trie\"라는 자료구조가 지금부터 설명할 가장 효율적인 문자열 검색법이다.\n\n## 구현 코드\n\n    public class TrieNode {\n        private final Map<Character, TrieNode> children = new HashMap<>();\n        private boolean endOfWord;\n        private int count;\n    \n        Map<Character, TrieNode> getChildren() {\n            return children;\n        }\n    \n        boolean isEndOfWord() {\n            return endOfWord;\n        }\n    \n        void setEndOfWord(boolean endOfWord) {\n            this.endOfWord = endOfWord;\n        }\n    \n        public int getCount() {\n            return count;\n        }\n    \n        void increaseCount() {\n            this.count++;\n        }\n    }\n\n    public class Trie {\n        private TrieNode root;\n    \n        public Trie() {\n            root = new TrieNode();\n        }\n    \n        public void insert(String word)1\n            TrieNode current = root;\n    \n            current.increaseCount();\n            current = current.getChildren()\n                    .computeIfAbsent((char) (word.length() + '0'), c -> new TrieNode());\n    \n            for (char trieWord : word.toCharArray()) {\n                current.increaseCount();\n                current = current.getChildren()\n                        .computeIfAbsent(trieWord, c -> new TrieNode());\n            }\n    \n            current.setEndOfWord(true);\n        }\n    \n        public int countOfSearched(String word, int index) {\n            TrieNode current = root;\n    \n            TrieNode wordLengthNode = current.getChildren().get((char) (word.length() + '0'));\n            if (wordLengthNode == null) {\n                return 0;\n            }\n            current = wordLengthNode;\n    \n            for (int i = 0; i < index; i++) {\n                char ch = word.charAt(i);\n                TrieNode node = current.getChildren().get(ch);\n                if (node == null) {\n                    return 0;\n                }\n                current = node;\n            }\n            return current.getCount();\n        }\n    }\n\n## update 예정..."},"frontmatter":{"layout":"post","title":"Trie 트라이","category":"data-structure","tags":["문자열 탐색"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/java/2019-06-26---JAVA-객체 정렬(비교)의 기준/index.md","fields":{"slug":"/etc/comparable-comparator/","categorySlug":"/categories/java/"},"internal":{"content":"\n## TMI\n\n[코딩테스트와 실무 역량 모두 잡는 알고리즘 스터디(Java) 2기 | 프로그래머스](https://programmers.co.kr/learn/courses/10004)\n\n시작부터 TMI 가 시작된다. 프로그래머스에서 진행하는 코딩테스트-JAVA 를 온라인 스터디 진행하면서 배운 내용을 정리 한다. \n\n[알고리즘 연습 - 모의고사 | 프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/42840)\n\n내가 풀었던 문제 중 모의 고사 문제를 풀면서 객체를 Sort 하거나 MAX 값을 얻기 위해 Comparable, Comparator를 사용하게 되었다.\n\n## 객체 **기준!!**\n\n![](Untitled-6e740739-1d83-497d-8be2-d0f841e5b809.png)\n\n- 객체의 정렬 기준 예시) Student\n    - Student.name 오름차순으로 정렬!!\n    - Student.age 내림차순으로 정렬!!\n        - age가 같으면 name 내림차순으로 정렬!!\n\n## 객체의 정렬의 기준을 정하는 두가지 인터페이스\n\n1. Comparable : 클래스 객체에 정렬 기준을 부과 할 때 사용하는 인터페이스 \n    - 정렬 기준: 클래스 객체 내부에 명시\n    - ex) sort(list< Student>)\n       - class Student implements Comparable< Student>\n2. Comparator: (클래스 객체)컬렉션을 정렬할때 기준을 부과 해주기 위한 기능적 인터페이스\n    - 정렬 기준: 메서드 사용시 메서드 인자로 명시\n\n    - Comparable 로 객체가 가지고 있는 정렬 기준이 아닌 새로운 기준을 부과 할때 사용\n        - 객체에 Comparable가 없어도 사용 가능(sort() 에서 정렬 기준을 명시할때)\n    - ex) sort(list, CustomSort)\n        - class CustomSort implements Comparator<CustomSort>\n\n---\n\n## 1. Comparable - 클래스 객체가 정렬 기준을 가지고 있자!\n\n> class.sort() 를 사용 할 때 인자를 지정 해주지 않아도 사용이 가능 한 이유는 해당 클래스 객체는 Comparable 인터페이스를 구현 하고 있기 때문이다.\n\n- 구현 예시\n    - sor(), max(), min() 등 정렬을 사용할 클래스 객체에 Comparable 인터페이스 구현 → compareTo() 를 오버라이드 한다.\n\n\n        class Student implements Comparable<Student> {\n            private int id;\n            private int score = 0;\n        \n            @Override\n            public int compareTo(Student student) {\n                return this.getScore() - student.getScore();\n            }\n        }\n\n- compareTo() 메서드\n    - Collections, Arrays에서 sort(), max(), min() 을 사용 할 때 compareTo() 메서드 사용\n    - 구현 방법\n        - this > 파라미터\n        - this < 파라미터\n        - this == 파라미터\n        - this - 파라미터\n        - 파라미터 - this\n    - 정렬 기준:\n        1. 양수 리턴: 오름차순\n        2. 음수 리턴: 내림차순\n        3. 0 리턴: 변동없음\n- 사용 예시\n\n        public Student maxScoreStudent(List<Student> studentList) {\n            return Collections.max(studentList);\n        }\n\n        public List<Student> sort(List<Student> studentList){\n            studentList.stream().sorted();\n        \t\treturn studentList;\n        }\n\n> Comparable 인터페이스가 없는 클래스 객체라면 Collections, Arrays에서 sort(), max(), min() 을 사용 할 때, 인자를 생략 할 수 없다!!\n\n- 왜?? 정렬 기준이 없으니까? 그럼 정렬 기준을 주입 해주면 되지 않을까?\n\n## 2. Comparator - 정렬 기준을 알려줄게! 이 기준으로 정렬!!\n\n![](Untitled-6e740739-1d83-497d-8be2-d0f841e5b809.png)\n\n> 클래스 객체의 지정된 정렬 기준을 따르고 싶지 않아 새로운 기준으로 정렬 하고 싶을 때 사용, 혹은 클래스 객체의 지정된 정렬 기준이 없을 때 사용\n\n- 구현 예시\n    1. Comparator 인터페이스를 구현하여 정렬 기준 클래스 사용\n\n            class CustomSort implements Comparator<Student> {\n            \n                @Override\n                public int compare(Student o1, Student o2) {\n                    if (o1.getScore() > o2.getScore()) {\n                        return 1;\n                    } else if (o1.getScore() == o2.getScore()) {\n                        if (o1.getId() < o2.getId()) {\n                            return 1;\n                        }\n                    }\n                    return -1;\n                }\n            }\n            \n            //사용\n            public Student maxScoreStudentUsingComparator(List<Student> studentList) {\n                return studentList.stream().max(new CustomSort()).orElse(null);\n            }\n\n    2. Comparator 인터페이스를 이용한 익명 클래스 사용\n\n            public Student maxScoreStudentUsingAnonymousComparatorClass(List<Student> studentList) {\n                return studentList.stream().max(new Comparator<Student>() {\n            \n                    @Override\n                    public int compare(Student o1, Student o2) {\n                        if (o1.getScore() > o2.getScore()) {\n                            return 1;\n                        } else if (o1.getScore() == o2.getScore()) {\n                            if (o1.getId() < o2.getId()) {\n                                return 1;\n                            }\n                        }\n                        return -1;\n                    }\n                }).orElse(null);\n            }\n\n    3. 람다(Lamda) 를 이용하여 Comparator 인터페이스 구현\n\n            public Student maxScoreStudentUsingLamda(List<Student> studentList) {\n                return studentList.stream().max((prevStudent, curentStudent) -> prevStudent.getScore() - curentStudent.getScore()).orElse(null);\n            }\n\n- compare() 메서드\n    - Collections, Arrays에서 sort(), max(), min() 을 사용 할 때 compare() 메서드 사용\n    - 구현 방법\n        - 파라미터1 > 파라미터2\n        - 파라미터1 < 파라미터2\n        - 파라미터1 == 파라미터2\n        - 파라미터1 - 파라미터2\n        - 파라미터2 - 파라미터1\n    - 정렬 기준:\n        1. 양수 리턴: 오름차순\n        2. 음수 리턴: 내림차순\n        3. 0 리턴: 변동없음\n\n> 개인적으로 Comparator는 람다(Lamda) 방식으로 사용하는 것이 좋은것 같다.\n\n---\n\n## PS - 소감쓰..\n\n정리하지 않고 사용할 땐, 모르고 사용 했었던 것 같다.\n\n최근에 javascript 를 공부하고 자주 사용했었는데, 다시 Java 공부 하면서 Java 의 sort 사용과 Javascript의 sort 사용법이 비슷했던 것 같다. 그래서 더 잘 와 닿는 느낌을 받았다.\n\n정리 할 내용들이 많은데, 정리 하는 시간이 생각 보다 길었다.\n\n---\n\n참고 사이트\n\n[자바 정렬 Java Comparable Comparator 확실히 알고 넘어가기](https://cwondev.tistory.com/15)\n\n[[Java] Comparable와 Comparator의 차이와 사용법 - Heee's Development Blog](https://gmlwjd9405.github.io/2018/09/06/java-comparable-and-comparator.html)"},"frontmatter":{"layout":"post","title":"JAVA-객체 정렬(비교)의 기준?Comparable, Comparator","category":"java","tags":["Comparable","Comparator","Normal Flow","unTIL the end"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/designe-pattern/2020-01-03---Flyweight/index.md","fields":{"slug":"/design-pattern/flyweight/","categorySlug":"/categories/design-pattern/"},"internal":{"content":"\n# 플라이웨이트 패턴\n\n> 플라이웨이트 패턴은 비용이 큰 자원을 공통으로 사용할 수 있도록 만드는 패턴이다. 1990년에 Paul Calder와 Mark Linton이 WYSIWYG 문서 편집기의 글자모양 정보를 효율적으로 다루기 위해 처음 도입되고 널리 연구되어 졌다.\n\n자원에 대한 비용은 크게 두가지로 나눠 볼 수 있다.\n\n1. 중복 생성될 가능성이 높은 경우.\n    - 중복 생성될 가능성이 높다는 것은 동일한 자원이 자주 사용될 가능성이 매우 높다는 것을 의미한다. 이런 자원은 공통 자원 형태로 관리해 주는 편이 좋다.\n2. 자원 생성 비용은 큰데 사용 빈도가 낮은 경우.\n    - 이런 자원을 항상 미리 생성해 두는 것은 낭비이다. 따라서 요청이 있을 때에 생성해서 제공해주는 편이 좋다.\n\n---\n\n이 두가지 목적을 위해서 플라이웨이트 패턴은 자원 생성과 제공을 책임진다.\n\n자원의 생성을 담당하는 Factory 역할과 관리 역할을 분리하는 것이 좋을 수 있으나, 일반적으로는 역할의 크기가 그리 크지 않아서 하나의 클래스가 담당하도록 구현한다.\n\n**장점**\n\n- 많은 객체를 만들 때 성능을 향상시킬 수 있다.\n- 많은 객체를 만들 때 메모리를 줄일 수 있다.\n- State pattern과 쉽게 결합될 수 있다.\n\n**단점**\n\n- 특정 인스턴스의 공유 컴포넌트를 다르게 행동하게 하는 것이 불가능 하다.\n- (개별 설정이 불가능 하다.)\n\n## 예제 - Tree\n\nTree 클래스로 만들어지는 객체는 mesh, bark, leaves 등 객체를 직접 만들지 않고 미리 만들어진 TreeModel을 사용한다.\n\nstatic 변수로 선언된 객체를 하나 만들어 모든 Tree 객체의 내부에서 사용되는 TreeModel 에서 공유한다.\n\n- 각각의 Tree 클래스에 직접 만드는 예시\n\n        public class TreeFactory {\n            private static final TreeModel sharedTreeModel = new TreeModel();\n        \n            static public Tree create(Position position, double height, double thickness) {\n                Tree tree = new Tree();\n                tree.setPosition(position);\n                tree.setHeight(height);\n                tree.setThickness(thickness);\n                tree.setTreeModel(sharedTreeModel);\n                \n                return tree;\n            }\n        }\n\n        public class Tree {\n            Mesh mesh;\n            Texture bark;\n            Texture leaves;\n            Position position;\n            double height;\n            double thickness;\n            Color barkTint;\n            Color leafTint;\n        }\n\n- Flyweight pattern 을 이용하여 공유할 객체를 분리 된 코드\n\n        public class Tree {\n            TreeModel treeModel;\n            Position position;\n            double height;\n            double thickness;\n        }\n        \n        // 공유할 객체를 감쌀 나무모델 클래스를 정의\n        public class TreeModel {\n            Mesh mesh;\n            Texture bark;\n            Texture leaves;\n        \n            public TreeModel() {\n                this.mesh = new Mesh();\n                this.bark = new Texture(\"bark\");\n                this.leaves = new Texture(\"leaves\");\n            }\n        }\n\n## Flyweight pattern 사용 예\n\n- 고전적인 사용 예\n    - 워드 프로세서에서 문자들의 그래픽적 표현에 대한 자료구조\n    - 문서에 입력된 모든 글자들에 대해서 글자(폰트) 정보를 가지고 있다면 메모리 낭비가 일어난다.\n- JDK 예\n    - java.lang.String\n    - java.lang.Integer.valueOf(int)\n    - java.lang.###.valueOf( ) 형식\n\n### java.lang.String의 예시\n\nstr1 과 str2는 각자 새로운 객체를 생성 하였기 때문에 서로 다른 객체 이지만 str3 과 str4는 같은 객체이다.(참조 되는 메모리가 같다. 중복 생성을 방지한다.)\n\n    public class TestPattern {\n        public static void main(String[] args) {\n            String str1 = new String(\"홍길동\");\n            String str2 = new String(\"홍길동\");\n            String str3 = \"홍길동\";\n            String str4 = \"홍길동\";\n    \n            System.out.println(\"Flyweight Pattern\");\n        }\n    }\n\n### 얕은 복사도 일종의 Flyweight 패턴이 적용되어 있다.\n\n    public class TestPattern {\n        public static void main(String[] args) {\n            MyData md1 = new MyData();\n            md1.xpos = 10;\n            md1.ypos = 11;\n            md1.name = \"홍길동\";\n    \n            MyData md2 = new MyData();\n            md2 = md1;\n    \n            MyData md3 = new MyData();\n            md3.xpos = 20;\n            md3.ypos = 21;\n            md3.name = \"손오공\";\n    \n            md2.name = \"전우지\";\n            md2.xpos = 5;\n        }\n    }\n    \n    class MyData {\n        int xpos;\n        int ypos;\n        String name;\n    }\n\n### Flyweight 패턴 구현하기\n\n    public class Subject {\n        private String name;\n    \n        public Subject(String name) {\n            this.name = name;\n        }\n    }\n\n    import java.util.HashMap;\n    import java.util.Map;\n    \n    public class FlyweightFactory {\n        private static Map<String, Subject> map = new HashMap<>();\n    \n        public Subject getSubject(String key) {\n            Subject subject = map.get(key);\n            if (subject == null) {\n                subject = new Subject(key);\n                map.put(key, subject);\n    \n                System.out.println(\"새로 생성\" + key);\n            } else {\n                System.out.println(\"재사용\" + key);\n            }\n    \n            return subject;\n        }\n    }\n\n Test code 사용 예시\n\n    public class TestPattern {\n        public static void main(String[] args) {\n            FlyweightFactory flyweightFactory = new FlyweightFactory();\n            flyweightFactory.getSubject(\"a\");\n            flyweightFactory.getSubject(\"a\");\n            flyweightFactory.getSubject(\"b\");\n            flyweightFactory.getSubject(\"b\");\n        }\n    }"},"frontmatter":{"layout":"post","title":"Flyweight 패턴","category":"design-pattern","tags":["Flyweight","design pattern"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/designe-pattern/2020-01-02---Singleton/index.md","fields":{"slug":"/design-pattern/singleton/","categorySlug":"/categories/design-pattern/"},"internal":{"content":"\n# 싱글턴 패턴\n\n객체가 너무 많아지면 컴퓨터 자원을 과도하게 사용하게 되고, 이는 프로그램 전체의 속도를 느리게 할 수 있다.\n\n→ 개발자는 객체의 최대 개수를 제한할 필요가 생긴다.\n\n싱글턴 패턴 : 최대 N개로 객체 생성을 제한하는 패턴\n\n→ 여기서 중요한 것은 생성되는 객체의 최대 개수를 제한하는 데 있어 객체의 생성을 요청하는 쪽에서는 일일이 신경쓰지 않아도 되도록 만들어주는 것이다.\n\n## 사용 예\n\n일반 자바 프로그래밍\n\n- 데이터베이스 컨넥션 풀\n- 로그 라이터\n\n게임 프로그래밍\n\n- 사운드 매니저\n- 스코어 매니저\n\n### 객체 생성 개수 제한 하기\n\n    public class Database {\n        private static Database singleton;\n        private String name;\n    \n        public Database(String name) {\n            super();\n            this.name = name;\n        }\n    \n        public static Database getInstance(String name) {\n            if (singleton == null) {\n                singleton = new Database(name);\n            }\n            return singleton;\n        }\n    \n        public String getName() {\n            return name;\n        }\n    }\n\n Test code 사용 예시\n\n    public class TestPattern1 {\n    \n        public static void main(String[] args) {\n            Database database;\n            database = Database.getInstance(\"첫 번째\");\n            System.out.println(\"database.getName() = \" + database.getName());\n    \n            database = Database.getInstance(\"두 번째\");\n            System.out.println(\"database.getName() = \" + database.getName());\n    \n            Database d1 = new Database(\"1\");\n            Database d2 = new Database(\"2\");\n            Database d3 = new Database(\"3\");\n            Database d4 = new Database(\"4\");\n            Database d5 = new Database(\"5\");\n            Database d6 = new Database(\"6\");\n    \n            System.out.println(\"database use\");\n        }\n    }\n\n## 생성자 문제점과 해결, 쓰레드 사용시 문제점 파악하기\n\n- 생성자를 priavte로 막아 둔다.\n- 생성을 하기 위해 생성 유틸리티 메서드를 사용한다.\n- 아래의 코드 중 생성자 메서드는 실제 DB 커넥션을 하는 것 처럼 효과를 주기 위함이다.\n\n        public class Database {\n            private static Database singleton;\n            private String name;\n        \n        //    public Database(String name) {\n        //        super();\n        //        this.name = name;\n        //    }\n            \n            private Database(String name) {\n                try {\n                    Thread.sleep(100);\n                    this.name = name;\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        \n            public static Database getInstance(String name) {\n                if (singleton == null) {\n                    singleton = new Database(name);\n                }\n                return singleton;\n            }\n        \n            public String getName() {\n                return name;\n            }\n        }\n\n Test code 사용 예시\n\n- for 문으로 생성된 객체는 거의 동시에 실행한 효과와 같다. 그렇기 때문에 sigleton 객체는 null로 인식하여 전부 인스턴스를 생성한다.\n- 생성 순서는 랜덤으로 메모리에 로드되는 순서대로 생성된다.\n- 이 처럼 싱글턴은 스레드에 취약점을 가지고 있다.\n\n        public class TestPattern2 {\n        \n            static int nNUm = 0;\n        \n            public static void main(String[] args) {\n                Runnable task = () -> {\n                    try {\n                        nNUm++;\n                        Database database = Database.getInstance(nNUm + \"번째 Database\");\n                        System.out.println(\"This is the \" + database.getName());\n        \n                    } catch (Exception e) {\n                        e.getStackTrace();\n                    }\n                };\n        \n                for (int i = 0; i < 10; i++) {\n                    Thread t = new Thread(task);\n                    t.start();\n                }\n            }\n        }\n\n## 쓰레드 사용시 문제점 해결 1\n\n- synchronized 예약어를 사용하여 동기화 처리\n- 단점: synchronized 는 비용이 비싸다.\n- 스레드를 한줄로 세워서 순서대로 처리 해야 되기 때문에 병목현상이 일어 한다.\n- Database 클래스 중 getInstance() 코드 예시\n\n        public class Database {\n            private static Database singleton;\n            private String name;\n        \n            private Database(String name) {\n                try {\n                    Thread.sleep(100);\n                    this.name = name;\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        \n            public synchronized static Database getInstance(String name) {\n                if (singleton == null) {\n                    singleton = new Database(name);\n                }\n                return singleton;\n            }\n        \n            public String getName() {\n                return name;\n            }\n        }\n\n## 쓰레드 사용시 문제점 해결 2\n\n- Static 키워드는 프로그램이 실행되면 제일 먼저 메모리에 로드 된다는 특성을 가지고 있다.\n- Static 키워드의 특성을 잘 활용한다. - 생성자 생성 x  직접 생성 o\n\n        public class Database {\n            private static Database singleton = new Database(\"product\");\n            private String name;\n            private Database(String name) {\n                try {\n                    Thread.sleep(100);\n                    this.name = name;\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        \n            public static Database getInstance(String name) {\n                 return singleton;\n            }\n        \n            public String getName() {\n                return name;\n            }\n        }\n\n## 싱글턴 패턴을 이용한 예제 - 로그 객체\n\n    import java.io.BufferedWriter;\n    import java.io.FileWriter;\n    import java.time.LocalDateTime;\n    \n    public class LogWriter {\n        private static LogWriter singleton = new LogWriter();\n        private static BufferedWriter bw;\n    \n        private LogWriter() {\n            try {\n                bw = new BufferedWriter(new FileWriter(\"log.txt\"));\n            } catch (Exception e) {\n                e.getStackTrace();\n            }\n        }\n    \n        public static LogWriter getInstance() {\n            return singleton;\n        }\n    \n        public synchronized void log(String str) {\n            try {\n                bw.write(LocalDateTime.now() + \" : \" + str + \"\\n\");\n                bw.flush();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    \n        @Override\n        protected void finalize() {\n            try {\n                super.finalize();\n                bw.close();\n            } catch (Throwable ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n Test code 사용 예시\n\n    public class TestPattern1 {\n        public static void main(String[] args) {\n            LogWriter loggger;\n    \n            loggger = LogWriter.getInstance();\n            loggger.log(\"홍길동\");\n    \n            loggger = LogWriter.getInstance();\n            loggger.log(\"전우치\");\n        }\n    }\n\n    //    웹 상의 많은 페이지를 동시에 열어 본다는 것은 쓰레드에서 동시에 메서드를 호출하는 것과 동일 하다.\n    public class TestPattern2 {\n        public static void main(String[] args) {\n            for (int i = 0; i < 50; i++) {\n    //            쓰레드 마다 구분되는 로그 작성용 파라미터\n                Thread thread = new ThreadSub(i);\n                thread.start();\n            }\n        }\n    }\n    \n    //    외부 클래스\n    class ThreadSub extends Thread {\n        int num;\n    \n        public ThreadSub(int num) {\n            this.num = num;\n        }\n    \n        @Override\n        public void run() {\n            LogWriter logger = LogWriter.getInstance();\n            if (num < 10) {\n                logger.log(\"*** 0\" + num + \"***\");\n            } else {\n                logger.log(\"*** \" + num + \"***\");\n    \n            }\n        }\n    }\n\n- TestPattern2 은 실제 여러 스레드가 동시에 접근하더라도 synchronized 예약어를 통해 겹치지 않고 각자 실행이 잘 이루어 진다.\n- 하지만 실행 순서는 보장되지 않는다. (실행 순서를 확인하기 위해 실행 순서 num 변수 사용)"},"frontmatter":{"layout":"post","title":"Singleton 패턴","category":"design-pattern","tags":["Singleton","design pattern"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/designe-pattern/2020-01-01---DI/index.md","fields":{"slug":"/design-pattern/di/","categorySlug":"/categories/design-pattern/"},"internal":{"content":"\n# 객체를 사용하는 두가지 방법\n\n1. A객체가 B/C 객체를 직접 생성한다.\n\n        public class A {\n        \tprivate B b = new B();\n        \tprivate C c = new C();\n        }\n\n    a는 갑 b,c는 을\n\n    a가 b,c를 사용하기도 하지만 b,c에 의존 하기도 한다.\n\n    객체 간의 의존 관계에서 직접 생성 하면 생성 부터 메모리 관리를 위한 소멸까지 해당 객체의 라이프 사이클을 개발자가 직접 관리 해주어야 됨으로 객체 간 강한 결합이다\n\n2. B/C 객체가 외부에 생성되어 A객체에 주입된다.\n\n        public class A {\n         \tprivate B b;\n        \tprivate C c;\n        \n        \tpublic A (B b, C c) {\n        \t\tthis.b = b;\n        \t\tthis.c = c;\n        \t}\n        //or\n        \tpublic void setb(B b){\n        \t\tthis.b = b;\n        \t}\n        \n        \tpublic void setC(C c){\n        \t\tthis.c = c;\n        \t}\n        }\n\n    a가 을 bc를 가지고, 있는 곳이 갑\n\n    a가  b,c기능이 필요하면 갑이 a에게 bc의 기능을 주입 시켜주는 구조이다.\n\n    이미 누군가가  생성한 객체를 주입 받아 사용만 하면 됨으로 약한 결합이다.\n\n    객체 지향에서 약한 결합, 느슨한 결합을 사용하면 개발자가 관리 할 것이 작아진다는 장점이 있다.\n\n        package di;\n        \n        import java.util.Date;\n        \n        public class UnderstandDI {\n            public static void main(String[] args) {\n                Date date = new Date();\n                System.out.println(date);\n            }\n        \n            public static void getDate(Date d) {\n                Date date = d;\n                System.out.println(date);\n            }\n        \n            public static void memberUser1() {\n        //        강한 결합 : 직접 생성\n                Member m1 = new Member();\n        //        억지스럽지만 Member 클래스의 생성자 메서드를 private 으로 변경하면 문제가 생긴다\n        //        이와 반대로 약한 겷합은 안전하고 유연하게 대체 가능하다\n            }\n        \n            public static void memberUser2(Member m) {\n        //        약한 결합 : 생성된 것을 주입 받음 - 의존 주입 (Dependency Injection)\n                Member m2 = m;\n            }\n        }\n        \n        //    Member를 사용한다.-->Member의 기능에 의존한다 라는 의미\n        class Member {\n            String name;\n            String nickname;\n        \n            public Member() {\n        \n            }\n        //    private Member() {\n        //    }\n        }"},"frontmatter":{"layout":"post","title":"DI (Dependency Injection)","category":"design-pattern","tags":["DI","design pattern"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/js/2019-04-09-es6_basic1/index.md","fields":{"slug":"/etc/es6-basic-1/","categorySlug":"/categories/js/"},"internal":{"content":"\n## programming & javascript elementry\n[코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)\n\n채널에서 보고 정리한 글입니다.\n\n---\n\n프로그래밍 언어 기본 틀과 자바스크립트 언어의 기본 요소를 살펴봅니다.\n\n## why did you do that?\n\n철학 - 합리주의, 상대주의 (부모는 무조건 부모인가? 누구의 자식이지 않는가?)\n\n- 켄트백\n\n- 가치\n    - 의사소통\n    - 단순함\n    - 유연함\n- 원칙\n    - 지역화\n    - 중복제거\n    - 대칭성\n- 패턴\n    - 개발론\n    - 설계론\n    - 각종적용패턴\n- 동기\n    - 돈\n    - 시간\n\n## program & timing\n\n### Compile program\n\n1. language code (c,java, javascript == text file)\n    1. Lint Time(시점)\n2. machine language (compile된 컴퓨터 언어, text file 일수도 있다.)\n\n    2. Compile Time(시점)\n\n3. file\n4. load - load영역 까지 프로그래머가 통제하는 영역이다.\n5. run\n    1. Run Time(시점)\n    2. Run Time Error 에도 안 걸리는 논리적인 오류를 context error 라고 한다.\n6. terminate\n\n### script program\n\n1. language code (c,java, javascript == text file)\n    1. Lint Time(시점)\n2. file\n3. load - load영역 까지 프로그래머가 통제하는 영역이다.\n4. machine language (메모리 내부에서 변경된다. 매번 만들 수 도 있다.)\n\n    2. Compile Time(시점)\n\n5. run\n    1. Run Time(시점)\n    2. Run Time Error 에도 안 걸리는 논리적인 오류를 context error 라고 한다.\n6. terminate\n\n## Runtime\n\nscript program을 잘 이해하기 위해서 Runtime 에 대해 잘 알아야 한다. \n\n### Compile program runtime\n\nruntime 은 메모리에 로드 하고 적재하는 시점이다.\n\n1. Loding\n\n    ![](Untitled-cb7d7382-c448-41c1-b2d9-1491fc6a0074.png)\n\n2. Instruction Fetch & Decoding\n\n    Fetch: 외부 버스에서 Memory 의 명령어를 가져온다.\n\n    Instruction : cpu가 해석할 수 있는 명령어\n\n    디코더는 memoery의 추상 명령어를 cpu의 명령어로 Decoding 한다.\n\n    ![](Untitled-b83b9d06-e84e-4f6e-9b0a-9c7eabf6a506.png)\n\n3. execution\n\n파일을 메모리 적재하고 ,적재된 명령들을 순차적으로 실행하면 종료된다.\n\n![](Untitled-573a1798-55c0-4c57-81a2-c7be698429bc.png)\n\nLoding → { Instruction Fetch & Decoding → execution → } → terminate\n\n1. essential definition loading (가장 중요한 정의 로딩)\n2. vtable mapping (코드의 변수들이 활성화 되는 부분이다.)\n3. run\n4. runtime definition loading (ex) 클릭을 했을 때 함수 생성)\n5. run\n\n### script program runtime\n\nRun\n\n- declare base function, class...\n\nstatic time (상대적으로 static)\n\n---\n\nrun time\n\n- declare extended function, class...\n\nstatic time (상대적으로 static)\n\n---\n\nrun time\n\n- use function, class...\n\n여기 까지가 프로그램 생명주기\n\n---\n\n## 프로그램 작동 방식\n\nmemory, address, pointer, variables, dispatch\n\n- 프로그램의 유연성을 위해 참조를 사용 하는데, 왜 참조의 참조를 사용하는지 알아야 한다.\n\n메모리 주소의 블록은 컴퓨터 환경마다 다르다 (32bit, 64bit)\n\n32bit 의 최대의 메모리는 가질 수 있 는 크기는 4G 이다.\n\n### 메모리 상황 알아 보기\n\n> ( 직접 참조) b 의 배신 알아 보기\n\n- &A 의 &는 c언어의 주소 연산자, 즉 메모리 주소를 반환하는 연산자 이다.\n\n    A의 메모리 주소는 11번이라는 것을 알 수 있다.\n\n- *B 의 * 는 포인트 긴잡 참조 연산자, 즉 메모리 번지의 값을 반환 하는 연산자 이다.\n\n    B의 값이 있는 주소, 즉 B의 값 11인 의 주소 번지의 값을 반환 한다. == test\n\n![](Untitled-7ff9bb74-979a-42ce-b9bc-44981e454c3a.png)\n\n- B의 참조 값을 변경 했을 경우\n\n    실행 상 문제가 되지 않는다. 하지만 남은 코드를 보았을 때 C, D 는 B의 값을 참조 한 것으로 보이지만, B는 배신을 하여 최초의 A가 아닌 K 를 참조하게 된다. \n\n![](Untitled-25dcb70b-c321-4efd-a6c7-3cbf9a0fdf03.png)\n\n**이러한 직접 참조의 문제 (배신의 문제) 를 해결하기 위해서는 *더블 디스패치*를 이용한다.**\n\nB의 참조 가 변경 되더라도 남은 코드를 봤을 때, 직접 참조보다 추측하기 쉬워진다.\n\n![](Untitled-8801542b-3830-495d-a829-5410caec2cb0.png)\n\n- 참조의 참조 == 더블 디스패치 (링크드 리스트의 구조와 같다고 본다)\n- 객체지향에서는 인터페이스와 같다. (커플링을 제거한다고 본다.)\n\n---\n\n여기 부터 javascript basic\n\n## lexical grammar\n\n- control character 제어문자\n- white space 공백문자\n- line terminators 개행문자\n- comments 주석\n- keyword 예약어\n- literals 리터럴\n    - 더이상 나눌 수 없는 객체의 값, 값의 표현\n    - ex) 숫자 37, 0.5, .5 등등\n\n## language element\n\n- statements 문\n    - 공문, 식문, 제어문, 선언문\n    - 단문, 중문\n    - 공문 ex) for(let i=0; i<5; i++); 이것도 인정해준다.\n    - 단문 ex) if(true) let i = 5;\n    - 중문 ex) if(true) { let i =5; j=6;}\n- expression 식\n    - 값식, 연산식, 호출식\n- identifier 식별자\n    - 기본형, 참조형\n    - 변수, 상수"},"frontmatter":{"layout":"post","title":"ES6 Basic 1","category":"js","tags":["Memoery","Compfile program","Script program"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/js/2019-04-24-es6_basic2/index.md","fields":{"slug":"/etc/es6-basic-2/","categorySlug":"/categories/js/"},"internal":{"content":"\n## flow control statement\n[코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)\n\n채널에서 보고 정리한 글입니다.\n\n---\n\n## record, completion record\n\n- js 식 처리 방식\n    - 식은 하나 의 값으로 해석:\n- js 문처리 방식\n    - 하나의 실행 단위로 해석; ex)10개의 문, 10개의 줄은 10개의 실행한위\n\n        **statement - record**\n\n        flow control statement\n\n        completion record \n\n        (flow를 선택할수 있는 문, 어떤 record를 선택할지)\n\n        ![](Untitled-46103b9f-8868-4235-88f6-50d47bfa73ed.png)\n\n    ## Direct flow control\n\n    B언어 까지 직접 flow control을 사용하였다.\n\n    C언어가 오고나서야 전용 flow control 이 생겼다. \n\n    ## Label\n\n    js 에서의 직접 flow control. ex) while의 break;\n\n        var i, j;\n        \n        loop1:\n        for (i = 0; i < 3; i++) {      //첫번째 for문은 \"loop1\" 레이블을 붙였다.\n           loop2:\n           for (j = 0; j < 3; j++) {   //두번째 for문은 \"loop2\" 레이블을 붙였다.\n              if (i === 1 && j === 1) {\n                 continue loop1;\n              }\n              console.log('i = ' + i + ', j = ' + j);\n           }\n        }\n\n    break나 continue 구문과 함께 사용할 수 있다. 원하는 식별자로 구문 앞에 레이블을 추가할 수 있다.\n\n    - identifier\n\n        label은 공문이라도 있어야 된다 하나의 문이 아니다.\n\n            label : \n            \t\tstatement\n\n            <!DOCTYPE html>\n            <html lang=\"en\">\n              <head>\n                <title>Document</title>\n              </head>\n              <body>\n                <script>\n            \t\t\t//abc: error\n                  abc: const a= 3;\n                </script>\n              </body>\n            </html>\n\n    - scope\n        - static parsing\n\n        같은 범위를 지정 할 수 없다. 파싱 단계에서 막아 준다.\n\n            <!DOCTYPE html>\n                <html lang=\"en\">\n                  <head>\n                    <title>Document</title>\n                  </head>\n                  <body>\n                    <script>\n                      abc: const a= 3;\n            \t\t\t\t\tabc: const a= 3;\n                    </script>\n                  </body>\n                </html>\n\n        label scope 를 만들면 영역을 나눌 수 있다. 중문 이랑 생김 새는 비슷하지만 다른다.\n\n            abc: {\n            \tabc:3;\n            }\n\n        - label shadow\n\n            <!DOCTYPE html>\n            <html lang=\"en\">\n              <head>\n                <title>Document</title>\n              </head>\n              <body>\n                <script>\n                  abc: {\n                    console.log('start');\n                    if (true) {\n                      break;\n                      // break abc;\n                    }\n                    console.log('end');\n                  }\n                </script>\n              </body>\n            </html>\n\n        ![](Untitled-907075ea-f441-4457-8ebb-8d32c084aeaa.png)\n\n            <script>\n              abc: {\n                console.log('start');\n                if (true) {\n                  // break;\n                  break abc;\n                }\n                console.log('end');\n              }\n            </script>\n\n        ![](Untitled-d92f9685-4382-432c-b796-d2cccf466dbd.png)\n\n    - label range & set\n        - 다음 레이블 까지가 지정이 안되어 있으면 다음 label 까지  label range 가 된다.\n\n            <!DOCTYPE html>\n            <html lang=\"en\">\n              <head>\n                <title>Document</title>\n              </head>\n              <body>\n                <script>\n                  console.log('0');\n                  abc: if (true) {\n                    break abc;\n                  }\n                  console.log('1');\n                  bbb: console.log('2');\n                </script>\n              </body>\n            </html>\n\n        break abc 는 label 의 마지막 블록으로 보내진다.\n\n        ![](Untitled-90a95844-2536-42bd-a4bb-93cb24e1794c.png)\n\n        다음 과 같은 경우 지정이 있을 경우 label rabge는 해당 범위 까지 지정된다.\n\n        - auto label\n        - iteration, switch\n        undefined named label\n    - as comment\n\n    ## switch\n\n    - special label block\n    - fall through\n        - 각 case 마다 break 를 안 걸면 fall through (다른 케이스도 실행되는 현상)\n\n                <script>\n                  switch (true) {\n                    default:\n                      console.log('c');\n                    case true:\n                      console.log('a');\n                    case false:\n                      console.log('b');\n                  //default:\n                \t\t\tconsole.log('c')\n                \t}\n                </script>\n\n    - auto label\n        - 각 case 마다 break 를  걸면 switch 앞에 auto label 을 생성한다.\n\n                <script>\n                tmep17:\n                  switch (true) {\n                    default:\n                      console.log('c');\n                    case true:\n                      console.log('a') break temp17;\n                \t\t\t//temp17을 생략 해도 똑같이 작동된다.\n                    case false:\n                      console.log('b');\n                  }\n                </script>\n\n    - runtime switch\n\n        default label의 처리 순서는 언어마다 다르다. (컴파일 방식, 인터프리터 방식)\n\n        - (정적인 경우)값에 대한 라우팅\n\n            case에  값에 대한 평가는 꼭 정적으로 할 필요는 없다 동적으로 해도 된다.\n\n                <script>\n                  const f1 = function(a) {\n                    return true;\n                  };\n                  const f2 = function(a) {\n                    return false;\n                  };\n                  const a = true;\n                  switch (a) {\n                    default:\n                      console.log('c');\n                    case f1(a):\n                      console.log('a');\n                    case f2(a):\n                      console.log('b');\n                  }\n                </script>\n\n        - 조건 분기에 대한 라우팅\n\n            연쇄되어 있는 책임 분기 의 상황에서 사용한다. (조건을 무력화 시킨다. == 통일한다.)\n\n                <script>\n                    switch (ture) {\n                      case network():\n                      case localCache():\n                      default: //안내문\n                    }\n                </script>\n\n    - reverse case\n\n    ## if, if else\n\n    else 는 후방결합 특성이 있다.\n\n    if, else if 중첩이나 복잡한 사용은 else의 후방결합을 완전히 이해하지 않으면 버그로 이어 진다. 이제 부터 else if 사용을 금지한다.\n\n    else if 는 병행 조건에 사용 되는 것이 아니다.\n\n    (switch 를 이용해야 한다.)\n\n        a:count c =3;\n        if(c === 1){\n        \n        } else if(c === 2){ //위험한 코드이다.\n        \n        } else{\n        \t\n        }\n\n        a:count c =3;\n        if(c === 1){\n        \n        } else {\n        \tif(c === 2){\n        \n        \t} else{\n        \t\n        \t}\n        }\n\n    단일 if 문은 optional 하다.\n\n    if, else 문은 mandatory (필수적) 이다.\n\n    if, else if, else 는 nested 일 경우에 사용한다.\n\n    switch 는 parallel 일 경우에 사용한다.\n\n    ## iterate flow control\n\n    ## for\n\n        for(ex;ex;ex;){\n        //1번째는 선언문 이거나 식이 올수 있다. \n        //2번째는 truthy 값일 때만\n        }\n\n    1. 1번째는 선언문 이거나 식이 올수 있다. \n\n        원래는 식만 있어야 하지만 for 문의 예외 상황이다.\n\n        식은 값으로 떨어진다.\n\n        var 가 들어 가있는 건 문이다. \n\n            var a = 3;\n            var k = var a =3; // 오류, 식은 값으로 떨어진다. 이는 문이다.\n\n    2. 2번째는 truthy 값일 때만\n\n        falsy 값(거짓 계열들의 값) \n\n        - '', false, 0, undifined, nulll, NaN\n\n        truthy 는 falsy 값이 아닌 것\n\n    3. 식문이기에 공문으로 둘수 있다.\n\n            for(;;;){\n            //상식적으로 2번째 식은 falsy값이기 때문에 안돌것 같지만\n            //예외적으로 for 문의 2번째 식은 공문으로 truthy 로 처리한다.\n            }\n\n    limited statement empty truthy last execution\n\n    ## while, do while\n\n    Infinite loop(ex in body)\n\n    조건식이 나오는 내용이 body 에 나오는 것인지 확인하는 것이 관건이다.\n\n        var a= -1;\n        while(a > 2){\n        \ta++;\n        }\n        do {\n        \n        } while(truthy)"},"frontmatter":{"layout":"post","title":"ES6 Basic 2","category":"js","tags":["식, 문","조건문, 반복문"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/css/2019-04-08-cssRendering6/index.md","fields":{"slug":"/etc/css-rendering-6/","categorySlug":"/categories/css/"},"internal":{"content":"\n## Display Model\n[코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)\n\n채널에서 보고 정리한 글입니다.\n\n---\n\ncss display module level3\n\n지금 현재 Geometry 를 계산해주는 공식은 display와 position 이다.\n\n## display group\n\noutside | inside | listitem | internal | box | legacy\n\n속성은 geometry를 계산해주는 알고리즘과 같다.\n\n- css 는 오페라 브라우저가 처음으로 제안했다. (이안이스?)\n\n1. outside \n    - nomal flow 와 관련 있다.\n\n        **block | inline | run-in**\n\n2. listitem\n\n    **list-item**\n\n3. box\n\n    br, wbr, meter, progress, canvas, embed, object, audio, iframe, img, video,\n    frame, frameset, input, textarea, select, legend, button, details, fieldset\n\n    **contents | none** \n\n    (box안을 무시하고 그위에 다시 그린다. 대체한다. | 무시)\n\n4. inside\n\n    contents layout \n\n    (outside와 반대로 안쪽, contents에 관련된 배치)\n\n    **flow | flow-root | table\n    flex | grid | subgrid | ruby**\n\n    css 에서 flow가 나오면 nomalflow 말고는 없다고 생각해도 된다.\n\n    float 는 block 요소를 짤라먹지 않고 inline 요소만 guard 한다. (float == 떠있으니까)\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n        \n          <body>\n            <div\n              style=\"height: 200px; width: 200px; background: red; opacity: 0.5; float: left;\"\n            ></div>\n            <div style=\"background: blue;\">abc</div>\n          </body>\n        </html>\n\n    ![](Untitled-dae04767-fc38-40bf-8972-2553e2736de0.png)\n\n    새로운 block 요소를 통해서 겹치지 않게 하기 위해서는 overflow 요소를 준다. \n\n    overflow는 auto가 아닌 이상 새로운 bfc 를 생성한다.\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n        \n          <body>\n            <div\n              style=\"height: 200px; width: 200px; background: red; opacity: 0.5; float: left;\"\n            ></div>\n            <!-- <div style=\"background: blue\">abc</div> -->\n            <div style=\"background: blue; overflow: hidden;\">abc</div>\n          </body>\n        </html>\n\n    ![](Untitled-f8d217e9-7cdc-4a9d-8c92-d8818b90c8cd.png)\n\n    flow-root 도  overflow hidden 과 똑같이 적용된다.\n\n    overflow hidden 과 다르게 side effect 없이 새로운 bfc를 만들수 있다. \n\n    css 2.x 레벨부터 있었던 스펙이다. \n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n        \n          <body>\n            <div\n              style=\"height: 200px; width: 200px; background: red; opacity: 0.5; float: left;\"\n            ></div>\n            <!-- <div style=\"background: blue\">abc</div> -->\n            <!-- <div style=\"background: blue; overflow: hidden;\">abc</div> -->\n            <div style=\"background: blue; display: flow-root\">abc</div>\n          </body>\n        </html>\n\n    ![](Untitled-874b462b-67c4-40df-b973-57e6917046e3.png)\n\n5. legacy\n\n    inline contents layout\n\n    **inline-block | inline-table | inline-flex | inline-grid**\n\n6. internal\n\n    table & ruby\n\n    특정 레이아웃 시스템 안에 들어왔을 때 아이템(자식)이 사용해야 되는 속성들\n\n    **table-row-group | table-header-group | table-footer-group\n    table-row | table-cell | table-column-group | table-column\n    table-caption\n    ruby-base | ruby-text | ruby-base-container | ruby-text-container**\n\ndisplay는 inside 이외에는 확장하지 않는다. internal이 늘어 나지 않는다.\n\nflexbox 나 grid 같은 경우에 별도의 domain 정의한다.\n\n## flexbox\n\nCSS Flexible Box Layout Module\n\n[CSS Box Alignment Module Level 3](https://drafts.csswg.org/css-align/)\n\ndraft 역사 -2012년 부터 flex란 이름을 가지게 되었다.\n\n1. Jul 2009 Working Draft (display: box;)\n2. Mar 2011 Working Draft (display: flexbox;)\n3. Nov 2011 Working Draft (display: flexbox;)\n4. Mar 2012 Working Draft (display: flexbox;)Jun **2012** Working Draft (**display: flex;**)\n5. Sep 2012 Candidate Recommendation (display: flex;)\n\nflexbox는 직계 자식만 flex-item이다. \n\nflex-item 은 따로 지정하지 않아도 부모가 display flex 면 모든 직계 자식은 flex-item 이다. \n\n단 자식의 자식은 상속되지 않는다. \n\n![](Untitled-a36f109f-8951-4e96-ba16-81a8f180db45.png)\n\nflexbox는 기본적인 정책은 한 줄만 그리는 정책을 가지고 있다 flex-line. 기본적으로 x 축으로 그린다. 기본축 main-axis . main 축과 직교하는 축을 cross-axis이다.\n\n![](Untitled-277e7f85-2d47-4cc1-aa1b-9707467d2caf.png)\n\nflexbox 의 작동원리는 DOM rendering 이 아니라 Post Process이기 때문에, 그림을 그리고 GPU에 올리기 때문에 속도가 훨씬더 빠르다. \n\nDOM 의 구조를 변경하는 것이 아니기 때문에 reflow가 일어 아니지 않는다. (repaint 만 적용된다.)\n\nflex-direction 은  배치를 변경하거나, flex의 기본 축을 변경한다(main-axis 와 cross-axis 를 바꾼다.). \n\n정렬\n\n![](Untitled-8f75ea70-95f6-4dd6-9305-288e1d8743da.png)\n\njustify-content (flex에서만 사용되는 속서이다.) main 축에서만 사용되는 속성이다.) \n\n![](Untitled-90aadb73-cb9c-400d-9c36-ea452c689a57.png)\n\ncross-axis 는 align-items 속성을 사용한다.\n\n![](Untitled-8d6ec064-b605-4960-b99e-9e8ba2388fbe.png)\n\ndirection에 따라 x축 y 축이 달라진다.\n\nalign-self 는 flex-item 들에 대한 정렬을 지정하는 속성이다.\n\n![](Untitled-59d22f96-47ae-4e40-aded-daf5fb3b5553.png)\n\n* flex 는 기본적으로 1 line 을 기준으로 적용된다. \n\n* line 을 여러줄 사용하기 위해서는 flex-wrap 속성을 사용한다.\n\n* flex line을 어떻게 정렬할것인가에 대한 속성은 align-content 가 있다.\n\n* flex wrap 이 있어야 align-content 가 적용된다.\n\n\n\n* flex 크기에 대한 옵션 flex-grow | flex-shrnk | flex-basis 가 있다.\n\n  * grow(가중치의 개념이다.) shrnk 0-100% , 1~ , 1 \n\n  * basis 는 기본적으로 auto|content or width,height 기본값은 나의 content 값이다. 따로 width, height를 주면 기본 값은 설정한 값을 준다.\n\n  * flex 는 initial|auto|none|1~ 하나만  지정하는 속성이다."},"frontmatter":{"layout":"post","title":"Css Rendering 6","category":"css","tags":["Display Model","Flex"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/blog/2019-06-25---unTIL-the-end-다짐/index.md","fields":{"slug":"/etc/until-the-end/","categorySlug":"/categories/blog/"},"internal":{"content":"\n## 다시 시작하는 TIL다짐 - unTIL the end\n\n블로그를 만들고 나서 4월 부터 TIL 시작하기로 생각했었다...\n\n공부 주제도 정하지 않고, TIL 은 주로 Code spitz 영상 내용을 정리하였다. CS 공부도 한다고 했는데 블로그에는 올리지 않았다. (지금까지 한것 보니까 1달 밖에 안했네..)\n\n![](Untitled-5f8ca495-f973-453c-84ec-9ccb21da597b.png)\n\n\n\n\n\n## 코드리뷰 온라인 스터디 시작\n\n> 프로그래머스에서 운영하는 강의는 내 기억상 인강 같은 강의만 있는 줄 알았는데 코드 리뷰 온라인 강의가 생겼다.\n\n\n<a href=\"https://programmers.co.kr/learn/courses/9872\">\n  <img src=\"Untitled-389f278b-6b1f-4bba-88ac-01b4514893ee.png\"/>\n</a>\n\n\n[단순 CRUD는 그만! 웹 백엔드 시스템 구현 온라인 스터디(Java반) 1기 | 프로그래머스](https://programmers.co.kr/learn/courses/9872)\n\n\n\n나는 지금까지 코드 리뷰라는 것을 경험 해보지 못하였고, 필요성은 너무나 절실하게 느꼈다. 나도 내 코드가 좋지 않다고 생각하는데, 어떤 부분을 어떻게 고쳐야 될지..조언을 받고 싶었다.\n\n제목 부터 맘에 들었다. 해당 스터디를 하면서 내가 배운 내용을 TIL 게시 글을 올릴려고 했었는데.. 잘 되지 않았다. (핑계..) \n\n\n\n## 5월, 6월 2달간 무엇을 했나?\n\n스터디가 종료 되고 나서 시간이 꽤나 흘렀다.\n\n뭐 그간 놀긴 놀았는데..나름대로 뭐 진행을 하고 있다고 생각 했다. 웹 백엔드 시스템 구현 온라인 스터디가 끝나고나서 배우고 싶었던 Types script 스터디도 하고,\n\n\n<a href=\"https://programmers.co.kr/learn/courses/9940\">\n  <img src=\"Untitled-aca74cdf-02bd-41fa-9d30-f7e3e2bf47c6.png\"/>\n</a>\n\n[[온라인 스터디] 2기 대기 중 - 제대로 알고 쓰자! TypeScript: TS를 TS답게 | 프로그래머스](https://programmers.co.kr/learn/courses/9940)\n\n\n\n때마침? 그 기간에 여름방학 스타트업 인턴 프로그램인 2019 써머 코딩의 과정들을 진행하였다.\n\n\n<a href=\"https://programmers.co.kr/competitions/95/2019-summer-coding\">\n  <img src=\"Untitled-811529b0-c336-45b8-9178-ffc0aa1f7999.png\"/>\n</a>\n\n[2019 Summer Coding - 여름방학 스타트업 인턴 프로그램](https://programmers.co.kr/competitions/95/2019-summer-coding)\n\n(할말은 많지만, 생략쓰... 공부 글도 아니니까 간단하게만 기록 하자는 마음 )\n\n\n\n## 갑자기 이글을 쓰는 이유는 무엇?\n\n[주니어 성장일기 시리즈: 진주에서 왔다! 웹 백엔드 개발자 꿈나무 이야기](https://prgms.tistory.com/10?fbclid=IwAR30itRAGGU-UyoFBMZWsYiRN-GXliOy8H7M_rugcX9XX85uxpCclVZ8RHs)\n\n웹 백엔드 스터디를 마치고 교육 운영자님이신 에밀리(님 아니고 에밀리)와 인터뷰를 진행하였다. 나의 이야기를 잘 들어 주시고, 나보다 더 잘 표현 해주셨다. 마치 잡지 같은 느낌!\n\n인터뷰를 하고, 게시가 되니까 뭔가 부끄러워 졌다. 누군가 내 블로그를 볼수 있구나..그리고 Java, Spring, 혹은 내가 공부 했고, 다룰 수 있는 기술에 대한 게시글도 없어서도 부끄러웠다.\n\n![](Untitled-781d8008-4446-4462-aaec-dfbb4c1cb545.png)\n\n이전 티스토리 블로그에서도 Spring 공부한 글을 okky나 다른 블로그에서 내 링크가 공유되어서, 부끄럽고 제대로 정리 해야 되겠다는 생각만 들었었는데, 지금은 아무런 글이 없어서 더 부끄럽다.\n\n뭐 남들 보라고 TIL을 하는 건 아니지만, 내 스스로도 다시 정신차려야 될것 같고, 지금까지 너무 논것? 같아서, 밀린 숙제? 공부 했었던 것을 지금이라도 정리 하자 라는 다짐을 하기 위해 이글을 적어 본다. \n\n![](Untitled-daaf146c-8d87-4809-8d74-ddb20017f390.png)\n\n앗!! 그리고 교육 운영자님이신 에밀리(님 아니고 에밀리) TIL 제목도 지어 주셨다. 뜻: 인생 끝날때까지 TIL을 쓰겠다\n\n## 마침\n\n> 음..뭔가 프로그래머스를 광고 하는 느낌이 들지만..(아무런 관계가 없다. 프로그래머스 강의를 계속 이용 한 것은 온라인 코드 리뷰 스터디가 재미있어서 계속 하게 되었다.)\n\n다시 맘 잡고 TIL열심히 해야겠다 라는 생각과, 공부한 흔적을 잘 남기자 라는 다짐을 위해서 작성한 글이다.\n\n이글 이후로 스터디(Java Spring, Typescript, Coding Test 대비-Java)에서 공부했던 내용들과, 앞으로  웹 백엔드 개발자가 되기 위해 필요한 공부를 정리 하면서 TIL을 실천 해야겠다.\n\n![](Untitled-b4225cc9-ca03-48f2-b743-501a682d4f20.png)"},"frontmatter":{"layout":"post","title":"다시 시작하는 TIL다짐","category":"blog","tags":["TIL","Progremmers","Backend"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/blog/2019-03-31---Gatsby-Js로-블로그-시작하기/index.md","fields":{"slug":"/etc/start-gatsby-for-blog/","categorySlug":"/categories/blog/"},"internal":{"content":"\n## Gatsby JS 를 선정한 이유\n\n> 결론부터 말하면 Markdwon 을 지원하는 블로그가 필요했다.\n\n공부한 내용을 정리해서 지속적으로 공부의 동기를 가지기 위해 블로그가 필요하다고 생각했고, Tistory 초대장을 받아 블로그 개설을 한 경험이 있었다. \n\nTistory 블로그는 여러 개발자 분들이 많이 이용하기도 하였고, 스킨 custom을 할 수 있는 장점이 있었다. \n\n그당시 공식적?으로 Markdown이 지원되지 않아 스킨 편집으로 markdown.css  파일을 올려 custom 으로 사용해야 됬다.\n\n다른 방법이 있겠지만, 게시물을 올리기 위해서 번거러움이 존재했다.(..핑계)\n\n[티스토리(Tistory) 마크다운(Markdown) 적용](https://regyu.tistory.com/2)\n\n### Gatsby.js 로 만든 블로그 장점\n\n> 기존의 블로그의 단점들이 장점으로 작용되어서 선정되었다.\n\n1. Markdown이 지원할것\n2. 사진을 올릴 때 편하게 올릴 수 있을것\n    - Typora, Notion에서 내보내기로 바로 편하게 게시 할 수 있다.\n3. 필요한 기능 디자인을 수정 할 수 있을 것\n    - React를 이용해서 블로그를 만들고 싶은 욕구\n\n## Gatsby js 에 필요한 지식\n\n1. React.js(Node js)\n2. Css(scss)\n3. Graphql\n4. Git\n\n## 테마\n\n> Gatsby.js 홈페이지의 starters에서 테마들을 고를 수 있다.\n\n[Library](https://www.gatsbyjs.org/starters/?v=2)\n\n![](Untitled-86ded4fd-38d7-4ee5-9fd2-5748e556acc4.png)\n\n## 테마 선택\n\n- 각 테마 마다 demo 사이트들이 있다.\n- 테마 마다 특징이 다르다.\n    - 대부분 plugin 들을 잘 적용해 두었다.(config.js 파일만 수정하면 될정도)\n- Source 를 클릭 하면 테마가 있는 Github 페이지로 이동한다.\n\n![](Untitled-0dccaec2-6351-42ca-adc0-868ae3f05a26.png)\n\n## 시작\n\n> 선택한 테마의 Source(Github) url 을 복사한다.\n\n    npm i -g gatsby-cli\n    gatsby new YOUR_PROJECT_NAME https://github.com/GatsbyCentral/gatsby-v2-starter-lumen\n\n### 블로그 실행\n\n    npm run develop\n\n    OR\n\n    gatsby develop\n\n  [http://localhost:8000/](http://localhost:8000/) 블로그 페이지로 접속 할 수 있습니다.\n\n## 배포\n\n> outsider 님의 netlify(네트리파이?) 정리 글을 보고 netilfy를 이용하였다.\n\n[netlify로 정적 사이트 배포하기 :: Outsider's Dev Story](https://blog.outsider.ne.kr/1417)\n\n- 장점\n    - 정적 페이지 **무료** 호스팅\n    - CI / CD 적용 (private 저장소도 가능)\n    - HTTPS 적용\n    - 간편한 조작( 클릭 몇번으로 간편하게 세팅)\n\n[Netlify 접속]([https://www.netlify.com/](https://www.netlify.com/))\n\n1. 사이트 추가\n\n    ![](Untitled-4eb19170-afb6-4e56-ae74-4c547921fc1c.png)\n\n2. Github 레포 추가\n\n    ![](Untitled-936ebf91-9169-4b76-a36e-ef3507be74b3.png)\n\n3. 빌드 & 배포\n\n    ![](Untitled-5a43e227-ef33-4a30-9ea2-97e4b3551efc.png)\n\n4. 세팅\n\n    ![](Untitled-87c325da-63ee-435c-bd34-50ab11b6a6db.png)\n\n5. Site setting \n    - site name을 변경하여 domain 변경 가능\n    - ex) www.your_site_name.netlify.com\n\n    ![](Untitled-f44e6678-9fc2-4530-b164-fd822e321ff7.png)\n\n6. Domain setting\n\n    ![](Untitled-8f5043b3-1d14-47ba-9a52-dfb6e4ec5896.png)\n\n7. 2단계 ( custom domain 추가)\n    - Netlify 에서 domain 을 구매 할 수 있다.\n    - 다른 곳에서 구입한 domain 을 추가 해도 된다.\n\n    ![](Untitled-93596e70-17fd-40cf-ad2d-ab56f3844d30.png)\n\n    > 2단계 (custom domain)이 완료 되면 3단계 (HTTPS)는 자동으로 완료 된다. (단 1시간~24 시간 소요 된다.)\n\n## DISQUS(댓글)\n\n1. Get started\n2. I want to install Disqus on my site\n\n    ![](Untitled-92ee59f1-dbbd-4193-80b5-efa9d47ef7aa.png)\n\n    ![](Untitled-82ce8621-13ee-4b95-8349-457cd56f98bb.png)\n\n3. Shortname 추가 (shortname은 gatsby 블로그의 config 에서 사용할 예정)\n\n    ![](Untitled-4c1ac438-fc7e-458e-a57c-12841ee48507.png)\n\n4. shortname이 보이지 않을 경우 website name 하단의 customize your url 클릭\n\n![](Untitled-cc245c12-a818-4f8d-a7b5-ebe37d46a172.png)\n\n5. admin — setting 에서 short name 을 확인 할 수 있다.\n\n![](Untitled-ef0862d0-75aa-4e99-8178-0dd8a572a104.png)\n\n6. Gatsby 블로그 프로젝트연동\n\n**추가 수정!!**\n\n프로젝트의 'react-disqus-comments'  라이브러리는 뭔가 정상적으로 작동하지 않는다.\n\n(댓글은 달리지만 각 페이지마다 댓글이 달리는 것이 아니라 전체 페이지에 모든 댓글이 다 달린다...)\n\n    npm uninstall react-disqus-comments\n\n\n\n'gatsby-plugin-disqus'  플러그인을 사용하자!!\n\n[](https://www.gatsbyjs.org/packages/gatsby-plugin-disqus/)\n\n    npm install -S gatsby-plugin-disqus\n\ngatsby-config.js ( 앞으로의 모든 설정은 여기서 할 것이다.)\n\n    module.exports = {\n      siteMetadata: {\n        url: 'https://www.regyu.dev/',\n        title: 'Regyu Dev log',\n        subtitle:\n          '리규의 흐릿한 잉크 남기기',\n        copyright: '© All rights reserved.',\n        disqusShortname: 'your-disqus-shortname' // 이부분 수정\n      },\n      plugins: [\n        {\n          resolve: `gatsby-plugin-disqus`,\n          options: {\n            shortname: `your-disqus-shortname` // 이부분 수정\n          }\n        },\n      ]\n    }\n\nsrc/templates/post-template.jsx\n\npageQuery 변수에 'slug' 필드 추가\n\n    markdownRemark(fields: { slug: { eq: $slug } }) {\n      id\n      html\n      fields {\n        tagSlugs\n    // 추가\n        slug\n    // ...\n      }\n    }\n\nsrc/Disqus/Disqus.jsx\n\n코드 변경\n\n    import React, { Component } from 'react'\n    \n    import { Disqus } from 'gatsby-plugin-disqus'\n    \n    class DisqusDetails extends Component {\n    \n      render() {\n        const { postNode, siteMetadata } = this.props\n        if (!siteMetadata.disqusShortname) {\n          return null\n        }\n        const post = postNode.frontmatter\n        const url = siteMetadata.url + postNode.fields.slug\n    \n        let disqusConfig = {\n          url: url,\n          identifier: postNode.id,\n          title: post.title,\n        }\n    \n        return (\n          <Disqus config={disqusConfig} ></Disqus>\n        )\n      }\n    }\n    \n    export default DisqusDetails\n    \n## Google Analytics\n\n> 티스토리 관리자 페이지 처럼 블로그의 방문자 수, 인기 글을 확인 할 수 있다. - **무료**\n\n1. [Google Analytics]([https://analytics.google.com](https://analytics.google.com/)) 로그인\n2. 설정 → 속성 추가 → 추적 코드 \n\n    ![](Untitled-2458a67e-e9f1-4b55-9a79-5db0a3a7091f.png)\n\n3. Gatsby 블로그 프로젝트연동\n\n    gatsby-config.js ( 앞으로의 모든 설정은 여기서 할 것이다.)\n\n        'gatsby-transformer-sharp',\n        'gatsby-plugin-sharp',\n        {\n          resolve: 'gatsby-plugin-google-analytics',\n          options: { trackingId: 'YOUR_TRACKINGID' },\n        },\n\n## Google 웹마스터 등록 (Search Console)\n\n> 구글 검색 엔진에 검색되기 위해서 필요하다.\n\n1. [Google Search Console]([https://search.google.com/search-console](https://search.google.com/search-console)) 접속\n2. 사이트 등록 - URL 접두어 에서 url 입력\n\n    ![](Untitled-df1be055-4c8f-40c6-be39-43dc54fafdac.png)\n\n3. 소유권 확인을 위해 meta 태그 추가\n\n    ![](Untitled-2796c868-d6e8-43b9-8d34-1c5040c9920a.png)\n\n    - yourProject→src→components→Layout→index.jsx 의 Helmet태그 안에 입력\n    - 각 태마 마다 경로는 다를 수 있지만 대부분 Layout을 담당하는 컴포넌트에 meta 태그를 넣으면 될 것 같다.\n\n    ### Sitemaps & Rss 등록\n\n    > 구글이 크롤링을 잘 하기 위해? Sitemaps과 Rss를 등록 해야 한다.\n\n    Gatsby 테마의 특징을 보면 대부분 sitemaps 와 rss 플러그인을 미리 잘 해두었기 때문에 따로 설정할 필요가 없다. \n\n    (만약 gatsby-config.js 에서 sitemaps 와 rss에 관련된 플러그인이 적용되지 않았다면 공식문서를 보고 적용해야 한다.)\n\n    ![](Untitled-cc813416-f5ec-4a03-b427-ca74b74ecd29.png)\n\n---\n\n## End\n\n여기 까지가 기본적인 세팅이 끝났다. 배포 까지만 해도 되고, 굳이 custom url 까지 적용할 필요는 없다고 생각한다. 필요한 테마를 잘 골라도 되고 custom으로 디자인을 수정하거나 기능을 추가 해도 될 것 같다. \n\n- TMI\n    - 대부분 설정, 메뉴 관리는 gatsby-config.js 에서 다룬다는 것을 까먹지 말자\n    - 공식문서를 제대로 읽지 않았었는데 현재 기준으로 v2 는 컴포넌트의 graphql 은 staticQuery 만 지원한다.(변수 사용 X, 역시 공식문서를 잘 읽어 봐야 된다는.....)\n    - sample md 파일, gatsby-node.js, gatsby-config.js 위주로 분석하면 (gatsby)프로젝트에 대해 이해하는데 도움이 될 것 같다.\n\n### TLT - Today I Learn\n\n내가 배운 내용을 블로그를 통해 정리하여 글쓰기 연습을 하자.   \n\n### PS\n\n내가 동경하는 개발자들의 블로그를 보면서 대단하다고 생각한다. 좋은 내용을 정리와 이해하기 쉽게 정리하는 것도 대단하지만 꾸준히 작성하는 것에 대하여 대단하다고 생각한다.\n\n언젠간 나도 그들 처럼 되고 싶다 라고 느끼면서 블로그를 다시 시작 해보려고 한다."},"frontmatter":{"layout":"post","title":"Gatsby Js 로 블로그 시작하기","category":"blog","tags":["Gatsby","Netlify","Disqus","Blog","Google Search console","Google Analytics"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/css/2019-04-06-cssRendering5/index.md","fields":{"slug":"/etc/css-rendering-5/","categorySlug":"/categories/css/"},"internal":{"content":"## semantic web & css query\n[코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)\n채널에서 보고 정리한 글입니다.\n\n---\n\nDOM구조를 되도록 이면 의존하지 않는 셀렉터와 CSS의 관리에 대해 알아봅니다.\n\n## semantic web\n\n- DOM : 하나의 문서로서 의미를 갖도록 태깅, (크롤러에게 친화적인 웹, 데이터베이스에 적합한 데이터) 클래스로 의미를 부여하지 말자\n- **CSS Selector** : DOM의 구조에 밀접하게 선택\n- CSS: 의미와 무관한 스타일\n\n1. DOM을 스타일에 맞춰 제작\n2. 태그의 변화가 스타일을 깨먹음\n\nselector는 Class 만 사용한다.\n\n- css attribute selector\n\n    [attr] - 속성이 존재함\n    [attr=val] - 값과 일치\n    [attr~=val] - 공백으로 구분된 단어로 포함되면 일치\n    [attr|=val] - 일치하거나 뒤에 -가 붙을 때\n    [attr*=val] - 값이 포함될 때\n    [attr^=val] - 값으로 시작할 때 //정규식에도 ^는 시작\n    [attr$=val] - 값으로 끝날 때 //정규식에도 &는 마지막\n    [(ex) i] - 대소문 구분안 함\n\nSQL = select * from table where field conditions..\nCSS Selector = base selector[field conditions][..][..]..\n\n### Scss 문법으로 Selector 사용 예시\n\n[Sass 강좌 - 한 눈에 보기](https://velopert.com/1712)\n\nvelopert 님의 sass 강좌를 참고한다.\n\n    //node-sass 글로벌 설치\n    npm install -g node-sass\n    \n    //컴파일하여 현재 디렉토리에 저장\n    node-sass selector.scss -o .\n    \n    //style.scss 파일에 변화가 있을 떄 마다 자동으로 리컴파일\n    node-sass selector.scss -w -o .\n\n[CSS: 선택자(Selector) 이해](http://www.nextree.co.kr/p8468/)\n\n이 블로그는 css 선택자의 설명과 함께 그림이 있어 이해하기 편하다.\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <title>Title</title>\n      </head>\n      <link rel=\"stylesheet\" href=\"./selector.css\" />\n      <body>\n        <form id=\"join\">\n          <input type=\"text\" name=\"userid\" />\n          <input type=\"password\" name=\"pw\" />\n          <input type=\"text\" name=\"nick\"/>\n        </form>\n      </body>\n    </html>\n    \n    #join {\n      [name=\"userid\"] {\n        boder: 1px solid #f00;\n      }\n      [name=\"pw\"] {\n        border: 1px solid #0f0;\n      }\n      [name=\"nick\"] {\n        border: 1px solid #00f;\n      }\n    }\n\n![](Untitled-799b2960-e7dd-4250-ab62-54f90fe2e41d.png)\n\n## HTML5 MicroData\n\n[HTML Microdata](https://www.w3.org/TR/microdata/)\n\n속성을 이용하여 의미론적 으로 html 를 정의하자\n\n- itemscope - 적용범위 설정\n- itemtype - 스키마 설정\n- itemid - 특정 id부여\n- itemprop - 속성명\n- content - 비가시적일 때 값을 설정value - 가시적인 값이 원하는 값이 아닐때\n- itemref - scope계층구조 안에 없을 때\n\n비교 - 기존 html\n\n    <body>\n      <h1>CodeSpitz76 - 5</h1>\n      <nav>Home</nav>\n      <p>\n        코드스피츠76 5회차 수업은 css를 쿼리화하여 사용하는 방법을 다룹니다.\n      </p>\n      <ul>\n        <li>\n          <h2>HTML5 MicroData</h2>\n          <p>마이크로데이터에 대한 개념과 예제</p>\n        </li>\n        <li>\n          <h2>HTML5 DataSet</h2>\n          <p>데이터셋에 대한 개념과 예제</p>\n        </li>\n      </ul>\n      <footer>\n        <div>MIT</div>\n        <div>Bsidesoft co.</div>\n      </footer>\n    </body>\n\n비교 - html5 micro data (semantic)\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <title>Title</title>\n      </head>\n      <link rel=\"stylesheet\" href=\"./micro.css\" />\n      <body itemscope itemtype=\"http://schema.org/WebPage\">\n        <h1 itemprop=\"name\">CodeSpitz76 - 5</h1>\n        <nav itemprop=\"breadcrumb\">Home</nav>\n        <p itemprop=\"description\">\n          코드스피츠76 5회차 수업은 css를 쿼리화하여 사용하는 방법을 다룹니다.\n        </p>\n        <ul>\n          <li\n            itemprop=\"mainEntity\"\n            itemscope\n            itemtype=\"http://schema.org/CollegeOrUniversity\"\n          >\n            <h2 itemprop=\"name\">HTML5 MicroData</h2>\n            <p itemprop=\"description\">마이크로데이터에 대한 개념과 예제</p>\n          </li>\n          <li\n            itemprop=\"mainEntity\"\n            itemscope\n            itemtype=\"http://schema.org/CollegeOrUniversity\"\n          >\n            <h2 itemprop=\"name\">HTML5 DataSet</h2>\n            <p itemprop=\"description\">데이터셋에 대한 개념과 예제</p>\n          </li>\n        </ul>\n        <footer>\n          <div itemprop=\"license\">MIT</div>\n          <div itemprop=\"publisher\">Bsidesoft co.</div>\n        </footer>\n      </body>\n    </html>\n\n태그의 속성으로 의미론 적인 selector를 지정 할 수 있다,\n\n    [itemtype$=\"WebPage\"] {\n      [itemprop=\"name\"] {\n        font-size: 20px;\n        padding: 0;\n        margin: 10px 0;\n      }\n      [itemprop=\"breadcrumb\"] {\n        font-size: 11px;\n        margin: 0 10px;\n        color: #234a7f;\n      }\n      [itemprop=\"description\"] {\n        font-size: 14px;\n        line-height: 20px;\n        color: #444;\n      }\n      ul {\n        list-style: none;\n        padding: 0;\n      }\n      [itemprop=\"mainEntity\"] {\n        padding: 0 20px;\n        margin: 10px;\n        border: 1px solid #999;\n        border-radius: 20px;\n      }\n      [itemprop=\"license\"] {\n        font-size: 11px;\n        color: #999;\n      }\n      [itemprop=\"publisher\"] {\n        font-size: 12px;\n        font-weight: bold;\n        font-family: sans-serif;\n      }\n    }\n    [itemtype$=\"CollegeOrUniversity\"] {\n      [itemprop=\"name\"] {\n        font-size: 15px;\n      }\n      [itemprop=\"description\"] {\n        font-size: 12px;\n        line-height: 15px;\n      }\n    }\n    \n    node-sass micro.scss -o .\n\n![](Untitled-a309a36c-3711-4f81-811a-62f20c9af3f0.png)\n\n## HTML5 DataSet\n\n[HTML 5.2](https://www.w3.org/TR/html5/dom.html#dom-dataset)\n\n문법 : data- 가 prefix로 붙는다. \n\nex) data-id , data-member-id, data-featue\n\n    <div data-id=\"hika\"></div> \n    <div data-id>hika</div>\n    console.log(div.dataset.id); //hika\n    \n    <div data-id=\"hika\" data-nick=\"abc\"></div>\n    <div data-member-id=\"k0123\"></div>\n    console.log(div.dataset.memberId); //k0123\n\nDataset 이 권장하는 바는 의미론 적으로 사용하기 위해 class 를 사용하지 말자\n\nclass 와 id 는 의미론 적인 요소가 아닌 디자인을 위해 사용하길 권장 한다.\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <title>Title</title>\n      </head>\n      <link rel=\"stylesheet\" href=\"./data-set.css\" />\n      <body data-type=\"http://schema.org/WebPage\">\n        <h1 data-name>CodeSpitz76 - 5</h1>\n        <nav data-breadcrumb>Home</nav>\n        <p data-description>\n          코드스피츠76 5회차 수업은 css를 쿼리화하여 사용하는 방법을 다룹니다.\n        </p>\n        <ul>\n          <li data-mainEntity data-type=\"http://schema.org/CollegeOrUniversity\">\n            <h2 data-name>HTML5 MicroData</h2>\n            <p data-description>마이크로데이터에 대한 개념과 예제</p>\n          </li>\n          <li data-mainEntity data-type=\"http://schema.org/CollegeOrUniversity\">\n            <h2 data-name>HTML5 DataSet</h2>\n            <p data-description>데이터셋에 대한 개념과 예제</p>\n          </li>\n        </ul>\n        <footer>\n          <div data-license>MIT</div>\n          <div data-publisher>Bsidesoft co.</div>\n        </footer>\n      </body>\n    </html>\n    \n    [data-type$=\"WebPage\"] {\n      color: #900;\n      [data-name] {\n        font-size: 20px;\n        padding: 0;\n        margin: 10px 0;\n      }\n      [data-breadcrumb] {\n        font-size: 11px;\n        margin: 0 10px;\n        color: #234a7f;\n      }\n      [data-description] {\n        font-size: 14px;\n        line-height: 20px;\n        color: #444;\n      }\n      ul {\n        list-style: none;\n        padding: 0;\n      }\n      [data-mainEntity] {\n        padding: 0 20px;\n        margin: 10px;\n        border: 1px solid #999;\n        border-radius: 20px;\n      }\n      [data-license] {\n        font-size: 11px;\n        color: #999;\n      }\n      [data-publisher] {\n        font-size: 12px;\n        font-weight: bold;\n        font-family: sans-serif;\n      }\n    }\n    [data-type$=\"CollegeOrUniversity\"] {\n      [data-name] {\n        font-size: 15px;\n      }\n      [data-description] {\n        font-size: 12px;\n        line-height: 15px;\n      }\n    }\n    \n    node-sass data-set.scss -o .\n\n![](Untitled-a309a36c-3711-4f81-811a-62f20c9af3f0.png)\n\n### 출석부 예제\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Title</title>\n  </head>\n  <link rel=\"stylesheet\" href=\"./attendance.css\" />\n  <body>\n    <h1 data-name>CodeSpitz72 - member</h1>\n    <table>\n      <thead>\n        <th>번호</th>\n        <th>이름</th>\n        <th>1강</th>\n        <th>2강</th>\n        <th>3강</th>\n        <th>개근</th>\n      </thead>\n      <tr data-id=\"1\">\n        <td>1</td>\n        <td data-name=\"이도형\">이도형</td>\n        <td data-1=\"on\">출석</td>\n        <td data-2=\"on\">출석</td>\n        <td data-3=\"on\">출석</td>\n        <td></td>\n      </tr>\n      <tr data-id=\"22\">\n        <td>22</td>\n        <td data-name=\"Suho Lee\">Suho Lee</td>\n        <td data-1=\"on\">출석</td>\n        <td data-2=\"on\">출석</td>\n        <td data-3=\"on\">결석</td>\n        <td></td>\n      </tr>\n      <tr data-id=\"36\">\n        <td>36</td>\n        <td data-name=\"Beom Yeon Andrew Kim\">Beom Yeon Andrew Kim</td>\n        <td data-1=\"on\">출석</td>\n        <td data-2=\"off\">결석</td>\n        <td data-3=\"off\">결석</td>\n        <td></td>\n      </tr>\n      <tr data-id=\"7\">\n        <td>7</td>\n        <td data-name=\"HoHoon Lee\">HoHoon Lee</td>\n        <td data-1=\"off\">결석</td>\n        <td data-2=\"off\">결석</td>\n        <td data-3=\"off\">결석</td>\n        <td></td>\n      </tr>\n    </table>\n\n    <footer>\n      <div data-license>MIT</div>\n      <div data-publisher>Bsidesoft co.</div>\n    </footer>\n  </body>\n</html>\n\n[data-1=\"on\"],\n[data-2=\"on\"],\n[data-3=\"on\"] {\n  color: green;\n}\n[data-1=\"off\"],\n[data-2=\"off\"],\n[data-3=\"off\"] {\n  color: red;\n}\n[data-1=\"on\"] + [data-2=\"on\"] + [data-3=\"on\"] + td {\n  background: green;\n}\n[data-1=\"off\"] + [data-2=\"off\"] + [data-3=\"off\"] + td {\n  background: red;\n}\n// 1개만 off 인 경우를 만든다.\n@for $i from 1 through 3 {\n  $ret: \"\";\n  @for $j from 1 through 3 {\n    @if $j == $i {\n      $ret: $ret + \"[data-\" + $j + '=\"on\"]';\n    } @else {\n      $ret: $ret + \"[data-\" + $j + '=\"off\"]';\n    }\n    $ret: $ret + \"+\";\n  }\n  #{$ret + \"td\"} {\n    background: yellow;\n  }\n}\n```\n\n![](Untitled-c51284dd-4e71-47cf-a57c-4d0406f80ae8.png)\n\n## \n\n## Practice\n\n앞의 출석부에서는 하루만 출석한 경우에 노란색이 표시된다. 출석부를 6강까지로 확장하고 다양한 일부만 출석한 모든 경우에 노란색이 잘 표시되도록 SCSS를 작성하시오\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <title>Title</title>\n      </head>\n      <link rel=\"stylesheet\" href=\"./practice.css\" />\n      <body>\n        <h1 data-name>CodeSpitz72 - member</h1>\n        <table>\n          <thead>\n            <th>번호</th>\n            <th>이름</th>\n            <th>1강</th>\n            <th>2강</th>\n            <th>3강</th>\n            <th>4강</th>\n            <th>5강</th>\n            <th>6강</th>\n            <th>개근</th>\n          </thead>\n          <tr data-id=\"1\">\n            <td>1</td>\n            <td data-name=\"이도형\">이도형</td>\n            <td data-1=\"on\">출석</td>\n            <td data-2=\"on\">출석</td>\n            <td data-3=\"on\">출석</td>\n            <td data-4=\"on\">출석</td>\n            <td data-5=\"on\">출석</td>\n            <td data-6=\"on\">출석</td>\n            <td></td>\n          </tr>\n          <tr data-id=\"22\">\n            <td>22</td>\n            <td data-name=\"Suho Lee\">Suho Lee</td>\n            <td data-1=\"on\">출석</td>\n            <td data-2=\"on\">출석</td>\n            <td data-3=\"on\">결석</td>\n            <td data-4=\"on\">출석</td>\n            <td data-5=\"on\">출석</td>\n            <td data-6=\"on\">출석</td>\n            <td></td>\n          </tr>\n          <tr data-id=\"36\">\n            <td>36</td>\n            <td data-name=\"Beom Yeon Andrew Kim\">Beom Yeon Andrew Kim</td>\n            <td data-1=\"on\">출석</td>\n            <td data-2=\"off\">결석</td>\n            <td data-3=\"off\">결석</td>\n            <td data-4=\"on\">출석</td>\n            <td data-5=\"on\">출석</td>\n            <td data-6=\"on\">출석</td>\n            <td></td>\n          </tr>\n          <tr data-id=\"7\">\n            <td>7</td>\n            <td data-name=\"HoHoon Lee\">HoHoon Lee</td>\n            <td data-1=\"off\">결석</td>\n            <td data-2=\"off\">결석</td>\n            <td data-3=\"off\">결석</td>\n            <td data-4=\"off\">결석</td>\n            <td data-5=\"off\">결석</td>\n            <td data-6=\"off\">결석</td>\n            <td></td>\n          </tr>\n        </table>\n    \n        <footer>\n          <div data-license>MIT</div>\n          <div data-publisher>Bsidesoft co.</div>\n        </footer>\n      </body>\n    </html>\n\nBit 연산자를 이용하여 모든 조합(경우의 수)를 구할 수 있지만, Sass는 bit 연산자가 없는 것 같아서, 비슷하게 흉내 냈다.\n\n| 2진수 | 10진수 |\n| ----- | ------ |\n| 0001  | 1      |\n| 0010  | 2      |\n| 0011  | 3      |\n| 0100  | 4      |\n\n    [data-1=\"on\"],\n    [data-2=\"on\"],\n    [data-3=\"on\"],\n    [data-4=\"on\"],\n    [data-5=\"on\"],\n    [data-6=\"on\"] {\n      color: green;\n    }\n    [data-1=\"off\"],\n    [data-2=\"off\"],\n    [data-3=\"off\"],\n    [data-4=\"off\"],\n    [data-5=\"off\"],\n    [data-6=\"off\"] {\n      color: red;\n    }\n    [data-1=\"on\"] + [data-2=\"on\"] + [data-3=\"on\"] + [data-4=\"on\"] + [data-5=\"on\"] + [data-6=\"on\"] + td {\n      background: green;\n    }\n    [data-1=\"off\"] + [data-2=\"off\"] + [data-3=\"off\"] + [data-4=\"off\"] + [data-5=\"off\"] + [data-6=\"off\"] + td {\n      background: red;\n    }\n    \n    @function pow($base, $exponents) {\n      $raised: 1;\n    \n      @for $i from 1 through $exponents {\n        $raised: $raised * $base;\n      }\n    \n      @return $raised;\n    }\n    \n    $data_num: 6;\n    \n    @for $i from 1 through pow(2, $data_num)-2 {\n      $ret: \"\";\n      $binary: $i;\n      @for $j from 1 through $data_num {\n        @if (floor($binary % 2) ==1) {\n          $ret: $ret + \"[data-\" + $j + '=\"on\"]';\n        } @else {\n          $ret: $ret + \"[data-\" + $j + '=\"off\"]';\n        }\n        $ret: $ret + \"+\";\n        $binary: $binary/2;\n      }\n      $i: $i * 2;\n      #{$ret + \"td\"} {\n        background: yellow;\n      }\n    }\n\n![](Untitled-2b74797a-fde3-4531-8b1e-7cd5ef7b30e4.png)"},"frontmatter":{"layout":"post","title":"Css Rendering 5","category":"css","tags":["Semantic web","Sass","MicroData","DataSet"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/css/2019-04-04-cssRendering4/index.md","fields":{"slug":"/etc/css-rendering-4/","categorySlug":"/categories/css/"},"internal":{"content":"## Transform 3d & Scss & Compass\n[코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)\n채널에서 보고 정리한 글입니다.\n\n---\n\n- Rendering Process\n    - 영역 설정 (Geometry == reflow) → 채색 (Fragment == repaint) : Cpu 에서 처리\n    - reflow를 하면 전부다 repaint를 하기 때문에 비용이 쎄다.\n\n## Post Process\n\n- 버퍼(Buffer)와 관련 있다. : Gpu에처 처리(Geometry, Fragment 의 버퍼를 이용)\n- Post Process 는 Geometry 와 Fragment 와 관련이 없다. (직접 그리지 않는다.)\n- post process 부터는 하나의 이미지로써 인식이 된다. (DOM 구조와 상관없다.)\n\n![](Untitled-7d5b90d8-5c6a-4754-94f8-b9acf00a1100.png)\n\n## Transform\n\n- perspective(원근 - 모니터와 눈 사이의 거리)\n- perspective-origin\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n        \n          <style>\n            @keyframes origin {\n              0% {\n                perspective-origin: 0% 50%;\n              }\n              50% {\n                perspective-origin: 100% 50%;\n              }\n              100% {\n                perspective-origin: 0% 50%;\n              }\n            }\n        \n            @keyframes spin {\n              100% {\n                transform: rotateX(360deg);\n              }\n            }\n        \n            html,\n            body {\n              height: 100%;\n            }\n        \n            body {\n              perspective: 600px;\n              background: #404040;\n              animation: origin 10s linear infinite;\n            }\n        \n            .test {\n              width: 500px;\n              height: 500px;\n              background: #aaa;\n              position: absolute;\n              left: 50%;\n              top: 50%;\n              margin-left: -250px;\n              margin-top: -250px;\n              animation: spin 30s linear infinite;\n            }\n          </style>\n        \n          <body>\n            <div class=\"test\"></div>\n          </body>\n        </html>\n\n    <video controls autoplay loop>\n        <source src=\"./transform.mov\" type=\"video/mp4\">\n          Your browser does not support the video tag.\n    </video>\n\n## Transform 3D\n\n> DOM의 계층구조를 이용하기 위해서는(자식도 부모의 속성에 이어받기) transform-style 을 넘겨 줘야 한다. default 는 flat 이다.\n- perspective\n- perspective-origin ( 눈을 바라보는 관점)\n- transform-style\n- transform-origin (변형이 일어 날때의 관점)\n- backface-visibility\n\n![](Untitled-32934a51-94f2-4e38-9691-2b8a60c801d3.png)\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n        \n          <style>\n            @keyframes spin {\n              100% {\n                transform: rotateX(360deg);\n              }\n            }\n        \n            html,\n            body {\n              height: 100%;\n            }\n        \n            body {\n              perspective: 800px;\n              background: #404040;\n            }\n        \n            .test {\n              width: 300px;\n              height: 300px;\n              background: #aaa;\n              position: absolute;\n              margin-left: -150px;\n              margin-top: -150px;\n              animation: spin 4s linear infinite;\n            }\n          </style>\n        \n          <body>\n            <div class=\"test\" style=\"left: 25%;top:50%;transform-origin: 50% 0%\"></div>\n            <div class=\"test\" style=\"left: 50%;top:50%;transform-origin: 50% 50%\"></div>\n            <div\n              class=\"test\"\n              style=\"left: 75%;top:50%;transform-origin: 50% 100%\"\n            ></div>\n          </body>\n        </html>\n\n  <video controls autoplay loop>\n      <source src=\"./transform-style.mov\" type=\"video/mp4\">\n        Your browser does not support the video tag.\n  </video>\n\n### Transform 3D 실습\n\nface , splite,  texture 의 덩어리는 mash(입체),Atlas\n\n![](Untitled-0c7d8695-7b86-417c-bcad-dd531046080f.png)\n\n![](Untitled-2726b634-0720-4ab9-9c19-c1ded36c8a72.png)\n\n      <!DOCTYPE html>\n      <html lang=\"en\">\n        <head>\n          <meta charset=\"UTF-8\" />\n          <title>Title</title>\n        </head>\n      \n        <style id=\"style\">\n          @keyframes spin {\n            to {\n              transform: rotateX(750deg) rotateY(360deg) rotateZ(360deg);\n            }\n          }\n      \n          html,\n          body {\n            height: 100%;\n          }\n      \n          body {\n            perspective: 600px;\n            background: #404040;\n          }\n          .ani {\n            animation: spin 4s linear infinite;\n          }\n          .face {\n            background: url('https://keithclark.co.uk/labs/css-fps/drum2.png');\n          }\n        </style>\n      \n        <body>\n          <script>\n            const El = class {\n              constructor() {\n                this.el = document.createElement('div');\n              }\n              set class(v) {\n                this.el.className = v;\n              }\n            };\n      \n            const Face = class extends El {\n              constructor(w, h, x, y, z, rx, ry, rz, tx, ty) {\n                //tx, ty, tz 는 texture의 x,y,z 좌표 === 한 면(face)\n                //rx, ry, rz 는 rotation의 x,y,z\n                //w,h 너비, 높이\n                super();\n                this.el.style.cssText = `\n                  position: absolute;\n                  width:${w}px;\n                  height:${h}px;\n                  margin:-${h * 0.5}px 0 0 -${w * 0.5}px;\n                  transform:translate3d(${x}px,${y}px,${z}px) rotateX(${rx}rad) rotateY(${ry}rad) rotateZ(${rz}rad);\n                  background-position:-${tx}px ${ty}px;\n                `;\n              }\n            };\n      \n            const Mesh = class extends El {\n              constructor(l, t) {\n                super();\n                this.el.style.cssText = `\n                position:absolute;\n                  left:${l};\n                  top:${t};\n                  transform-style: preserve-3d;\n                `;\n              }\n              add(face) {\n                this.el.appendChild(face.el);\n                return face;\n              }\n            };\n      \n            const mesh = new Mesh('50%', '50%');\n      \n            const r = 100,\n              height = 196,\n              sides = 20;\n            const sideAngle = (Math.PI / sides) * 2;\n            const sideLen = r * Math.tan(Math.PI / sides);\n      \n            for (let c = 0; c < sides; c++) {\n              const x = (Math.sin(sideAngle * c) * r) / 2;\n              const z = (Math.cos(sideAngle * c) * r) / 2;\n              const ry = Math.atan2(x, z);\n              const face = new Face(\n                sideLen + 1,\n                height,\n                x,\n                0,\n                z,\n                0,\n                ry,\n                0,\n                sideLen * c,\n                0\n              );\n              face.class = 'face';\n              mesh.add(face);\n            }\n            const _top = new Face(100, 100, 0, -98, 0, Math.PI / 2, 0, 0, 0, 100);\n            const _bottom = new Face(100, 100, 0, 98, 0, -Math.PI / 2, 0, 0, 0, 100);\n            _top.class = 'face';\n            _bottom.class = 'face';\n            mesh.add(_top);\n            mesh.add(_bottom);\n            mesh.class = 'ani';\n            document.body.appendChild(mesh.el);\n          </script>\n        </body>\n      </html>\n\n  <video controls autoplay loop>\n      <source src=\"./face.mov\" type=\"video/mp4\">\n        Your browser does not support the video tag.\n  </video>\n\n예제를 보면서 2d의 그림을 수학 공식을 통해 3D 로 변경하였다. \n\n여기에 사용된 수학 내용은 중학교 의 원의 둘레 구하기 정도 수준이다. \n\n( 순간적으로 기억이 안나서 수학 공식에 대해 찾아 보았다...)\n\n[수포자가 필요해서 정리하는 수학공식](https://imcts.github.io/math-hodobub/)\n\n[삼각함수 공식 총정리](https://blog.naver.com/PostView.nhn?blogId=dalsapcho&logNo=20131746494)\n\n    const sides = 20; //20조각\n    const sideAngle = (Math.PI / sides) * 2;\n    //π(pi) = 는 180 도(반원)에 해당하는 값이다.\n    \n    const r = 100 // 반지름 100\n    for (let c = 0; c < sides; c++) {\n    \tconst x = (Math.sin(sideAngle *  c) * r) / 2;\n    \tconst z = (Math.cos(sideAngle * c) * r) / 2;\n    \tconst ry = Math.atan2(x, z);\n    }\n\n![](Untitled-af30799e-dd06-4fb2-9093-f44d8d06c3b4.png)\n\n### Sass + compass로 변경 ex\n\n[Sass 강좌 - 한 눈에 보기](https://velopert.com/1712)\n\nVelopert 님의 Sass를 참고 하면 좋을 것 같다.\n\n- sass 에서는 변수에 @를 붙인다. .\n- sass 의 #{} 구문은 #{변수} 변수가 무조건 String 으로 인식한다.\n- function 과  mixin과의 차이\n    - function 에는 @return directive구문이 있다.\n    - mixin 은 css 전부를 리턴해준다.\n\n            $pi: 3.14159265359;\n            @function atan2($y, $x) {\n              @if $x > 0 {\n                @return atan($y / $x);\n              }\n              @if $x < 0 {\n                @if $y >= 0 {\n                  @return atan($y / $x) + $pi;\n                }\n                @if $y < 0 {\n                  @return atan($y / $x) - $pi;\n                }\n              }\n              @if $x == 0 {\n                @if $y > 0 {\n                  @return $pi/2;\n                }\n                @if $y < 0 {\n                  @return -$pi/2;\n                }\n              }\n              @return atan($y/$x);\n            }\n            \n            @mixin face($w, $h, $x, $y, $z, $rx, $ry, $rz, $tx, $ty) {\n              position: absolute;\n              width: #{$w}px;\n              height: #{$h}px;\n              margin-top: -#{$h/2}px;\n              margin-left: -#{$w/2}px;\n              transform: translate3d(#{$x}px, #{$y}px, #{$z}px) rotateX(#{$rx}rad) rotateY(#{$ry}rad) rotateZ(#{$rz}rad);\n              background-position: #{$tx}px #{$ty}px;\n            }\n            \n            .mesh {\n              position: absolute;\n              left: 50%;\n              top: 50%;\n              transform-style: preserve-3d;\n            }\n            .mesh > div {\n              position: absolute;\n              transform-style: preserve-3d;\n              background-image: url(\"http://keithclark.co.uk/labs/css-fps/drum2.png\");\n              backface-visibility: hidden;\n            }\n            .mesh > .top {\n              @include face(100, 100, 0, -98, 0, $pi/2, 0, 0, 0, 100);\n            }\n            .mesh > .bottom {\n              @include face(100, 100, 0, 98, 0, -$pi/2, 0, 0, 0, 100);\n            }\n            $r: 100;\n            $height: 196;\n            $sides: 20;\n            $sideAngle: $pi * 2 / $sides;\n            $sideLen: $r * tan($pi/$sides);\n            $w: $sideLen + 1;\n            @for $i from 0 through $sides {\n              $x: sin($sideAngle * $i) * $r / 2;\n              $z: cos($sideAngle * $i) * $r / 2;\n              $ry: atan2($x, $z);\n              .mesh > div:nth-child(#{$i}) {\n                @include face($w, $height, $x, 0, $z, 0, $ry, 0, -$sideLen * $i, 0);\n              }\n            }\n\n## Practice\n\nQ. 주어진 큐브맵을 이용해 다음과 같은 화면을 구성하여 Y축으로 회전시키시오\n\n[http://paulbourke.net/miscellaneous/cubemaps/cube.jpg](http://paulbourke.net/miscellaneous/cubemaps/cube.jpg)\n\n![](Untitled-10081dcd-bf0a-4b74-be72-f5bb7ba91ad0.png)\n\n  <video controls autoplay loop>\n      <source src=\"./practice.mov\" type=\"video/mp4\">\n        Your browser does not support the video tag.\n  </video>\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Title</title>\n  </head>\n\n  <style id=\"style\">\n    @keyframes spin {\n      to {\n        transform: rotateY(360deg);\n      }\n    }\n\n    html,\n    body {\n      height: 100%;\n    }\n\n    body {\n      perspective: 600px;\n      background: #404040;\n      overflow: hidden;\n    }\n    .ani {\n      animation: spin 20s linear infinite;\n    }\n    .face {\n      background: url('http://paulbourke.net/miscellaneous/cubemaps/cube.jpg');\n      backface-visibility: hidden;\n    }\n  </style>\n\n  <body>\n    <script>\n      const El = class {\n        constructor() {\n          this.el = document.createElement('div');\n        }\n        set class(v) {\n          this.el.className = v;\n        }\n      };\n\n      const Face = class extends El {\n        constructor(w, h, x, y, z, rx, ry, rz, tx, ty) {\n          //tx, ty, tz 는 texture의 x,y,z 좌표 === 한 면(face)\n          //rx, ry, rz 는 rotation의 x,y,z\n          //w,h 너비, 높이\n          super();\n          this.el.style.cssText = `\n            position: absolute;\n            width:${w}px;\n            height:${h}px;\n            margin:-${50}px 0 0 -${500}px;\n            transform:translate3d(${x}px,${y}px,${z}px) rotateX(${rx}deg) rotateY(${ry}deg) rotateZ(${rz}deg);\n            background-position:-${tx}px ${ty}px;\n            \n          `;\n        }\n      };\n\n      const Mesh = class extends El {\n        constructor(l, t) {\n          super();\n          this.el.style.cssText = `\n          position:absolute;\n            left:${l};\n            right:${t};\n            transform-style: preserve-3d;\n          `;\n        }\n        add(face) {\n          this.el.appendChild(face.el);\n          return face;\n        }\n      };\n\n      const mesh = new Mesh('50%', '50%');\n\n      const r = 1000,\n        height = 1000,\n        sides = 4;\n      const sideAngle = (Math.PI / sides) * 2;\n      const sideLen = r * Math.tan(Math.PI / sides);\n\n      let deg = 90;\n      for (let c = 0; c < sides; c++) {\n        const x = ((Math.cos(sideAngle * c) * r) / 2) * -1;\n        const z = ((Math.sin(sideAngle * c) * r) / 2) * -1;\n        // const ry = (180 / Math.PI) * parseInt(Math.atan2(x, z));\n        const ry = deg;\n        deg -= 90;\n        const face = new Face(\n          sideLen,\n          height,\n          x,\n          0,\n          z,\n          0,\n          ry,\n          0,\n          sideLen * c,\n          -1000\n        );\n        face.class = 'face';\n        mesh.add(face);\n      }\n      const _top = new Face(1000, 1000, 0, -500, 0, -90, 0, 0, 1000, 0);\n      const _bottom = new Face(1000, 1000, 0, 500, 0, 90, 0, 0, 1000, -2000);\n      _top.class = 'face';\n      _bottom.class = 'face';\n      mesh.add(_top);\n      mesh.add(_bottom);\n      mesh.class = 'ani';\n      document.body.appendChild(mesh.el);\n    </script>\n\n  </body>\n</html>\n```\n\n혹은 css 버전\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Title</title>\n  </head>\n\n  <style id=\"style\">\n    @keyframes spin {\n      to {\n        transform: rotateY(360deg);\n      }\n    }\n\n    html,\n    body {\n      height: 100%;\n    }\n\n    body {\n      perspective: 600px;\n      background: #404040;\n      overflow: hidden;\n    }\n    .env {\n      animation: spin 20s linear infinite;\n      position: absolute;\n      left: 50%;\n      right: 50%;\n      transform-style: preserve-3d;\n    }\n    .env > div {\n      background: url('http://paulbourke.net/miscellaneous/cubemaps/cube.jpg');\n      position: absolute;\n      margin: -50px 0 0 -500px;\n      width: 1000px;\n      height: 1000px;\n\n      backface-visibility: hidden;\n    }\n  </style>\n\n  <body>\n    <div class=\"env\">\n      <div\n        class=\"left\"\n        style=\"transform:translate3d(-500px,0,0)  rotateY(90deg) ;background-position:0 -1000px;\"\n      ></div>\n      <div\n        class=\"back\"\n        style=\"transform:translate3d(0,0,-500px) ;background-position:-1000px -1000px;\"\n      ></div>\n      <div\n        class=\"right\"\n        style=\"transform:translate3d(500px,0,0)  rotateY(-90deg) ;background-position:-2000px -1000px;\"\n      ></div>\n      <div\n        class=\"front\"\n        style=\"transform:translate3d(0,0,500px)  rotateY(180deg) ; background-position:-3000px -1000px;\"\n      ></div>\n      <div\n        class=\"top\"\n        style=\"transform:translate3d(0,-500px,0) rotateX(-90deg) ;background-position:-1000px 0\"\n      ></div>\n      <div\n        class=\"botton\"\n        style=\"transform:translate3d(0,500px,0) rotateX(90deg) ;background-position:-1000px -2000px\"\n      ></div>\n    </div>\n  </body>\n</html>\n```\n"},"frontmatter":{"layout":"post","title":"Css Rendering 4","category":"css","tags":["Post Process","Transform","cpu","gpu"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/css/2019-04-02-cssRendering2/index.md","fields":{"slug":"/etc/css-rendering-2/","categorySlug":"/categories/css/"},"internal":{"content":"\n# Morden Box\n\n[코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)\n채널에서 보고 정리한 글입니다.\n\n---\n\n> Geometry 영향을 끼치지 않는다.\n\n- margin\n    - outline ( 박스로 되어 있다. border - radisous 에 영향을 미치지 않는다.)\n    - Box-shadow (갯 수 제한이 없다. border - radisous 에 영향을 미친다.)\n        - Border-box ( 그림을 그려주는 Fragment는 Border -box 까지이다.)\n            - box-shadow inset\n            - paddingbox\n                - content-box\n\n![](Untitled-6b3434b7-0deb-4c21-8f8a-325d9f3a8a28.png)\n\n## Box-sizing\n\n- width, height 를 지정하는 건 content size 이다.\n\n- Box-sizing 을 border-box로 지정하면 width , height 는  테두리 크기까지 포함 한다.\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n          <style>\n            div {\n              width: 100px;\n              height: 100px;\n              padding: 10px;\n              border: 10px solid #000;\n              display: inline-block;\n            }\n          </style>\n          <body>\n            <div style=\"background: red\"></div>\n            <div style=\"background: blue; box-sizing: border-box\"></div>\n          </body>\n        </html>\n\n    ![](Untitled-222c32b8-3acd-42f3-b64c-d38d46b53fd0.png)\n\n## Box-shadow\n\n- Geometry 에 영향을 미치지 않는다.\n- 색칠만 하게 된다.\n- 그림에 순서에 의해 z-index가 나중에 그려진 것이 올라간다.(Fragment 와 연관있다)\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n          <style>\n            div {\n              width: 100px;\n              height: 100px;\n              padding: 10px;\n              border: 10px dashed #000;\n              display: inline-block;\n            }\n          </style>\n          <body>\n            <div style=\"background: red\"></div>\n            <div style=\"background: blue; box-shadow: 0 0 0 10px yellow;;\"></div>\n          </body>\n        </html>\n\n![](Untitled-9bcae1eb-934e-4179-90e5-23809aba075d.png)\n\n- Position relative 는 Nomal Flow를 그리고 그다음 relative 를 재계산해서 그린다.\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n          <style>\n            div {\n              width: 100px;\n              height: 100px;\n              padding: 10px;\n              border: 10px dashed rgba(0, 0, 0, 0.5);\n              display: inline-block;\n            }\n          </style>\n          <body>\n            <div style=\"background: red; position: relative;\"></div>\n            <div style=\"background: blue; box-shadow: 0 0 0 10px yellow;;\"></div>\n          </body>\n        </html>\n\n![](Untitled-613f824c-369f-44ad-9372-c0db5fecec1f.png)\n\n## Box-shadow-sandwich\n\n- ,(콤마)로 여러 개 를 그릴 수 있게된다.\n- 밖에 부터 그려진다.\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n          <style>\n            div {\n              width: 100px;\n              height: 100px;\n              padding: 10px;\n              border: 10px dashed rgba(0, 0, 0, 0.5);\n              display: inline-block;\n            }\n          </style>\n          <body>\n        \t\t<div style=\"background: red;\"></div>\n        \t\t<div style=\"background: blue; box-shadow:0 0 0 10px purple, inset 0 0 0 10px yellow;;\"></div>\n        \t</body>\n        </html>\n\n    ![](Untitled-0d347306-2422-4f20-8960-7ac6b48bfead.png)\n\n## stitched\n\n- outline 을 지정하고 안에 마감은 border-radius 로 하는 기법\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n          <style>\n            div {\n              width: 100px;\n              height: 100px;\n              padding: 10px;\n              border: 10px dashed rgba(0, 0, 0, 0.5);\n              display: inline-block;\n            }\n          </style>\n          <body>\n            <div style=\"\n              background: yellow; \n              border-radius: 15px;\n              outline: 10px solid rgba(0,255,0,0.5);\n              border: 5px dashed #fff;\n              color: #fff;\n              box-shadow: 0 0 0 10px red;\"\n            >\n            </div>\n          </body>\n        </html>\n\n![](Untitled-316723b5-2dad-4f02-8cd9-9ae9b87adaf3.png)\n\n## Position\n\nstatic | relative | **absolute** | **Fiexed**\n\nCaret Position & Offset\n\n- Caret Position :\n- Offset : Geometry 계산이 끝나서 fix 숫자로 계산된 것 ( 수정이 불가능 하겠지? 참조는 가능)\n- frame : 브라우저가 한번의 계산하는 단위(변경해야 되는 요소를 queue 에 flush 하는 행위)\n    - offset 을 요청 하면 바로 재 계산이 계속 되어 최적화 룰이 깨진다.\n\n## Offset parent ( 기준점 : Dom 이 아니다)\n\n1. Null\n    - Root, Html, Body\n    - Position: Fixed\n    - Out of Dom Tree\n2. Recursive Search\n    - Parent Position : Fixed = null\n    - Parent Position : !Static = ok ( absolute, relative{ 주로 absolute 의 기준을 잡기 위해 사용})\n        - Absoulte\n            - offsetParent 무관하게 동상의 (static 이라도)부모 값을 기본적으로 갖고 있다.(default)\n            - left,right,top,bottom 속성을 사용하면 더이상 부모 값의 기준이 아니라 offsetParent를 기준으로 삼는다.\n\n                    <!DOCTYPE html>\n                    <html lang=\"en\">\n                      <head>\n                        <meta charset=\"UTF-8\" />\n                        <title>Title</title>\n                      </head>\n                    \n                      <body>\n                        <div style=\"width: 200px; height: 200px; background: yellow;margin: 100px;\">\n                          <div style=\"width: 100px; height: 100px;position: absolute; background: red;\"></div>\n                          <div style=\"width: 100px; height: 100px;position: absolute; background: blue;left: 0;\"></div>\n                        </div>\n                      </body>\n                    </html>\n\n        ![](Untitled-875209c7-b721-42eb-8b3e-4a605a8e5555.png)\n\n        - relative{ 주로 absolute 의 기준을 잡기 위해 사용}\n\n                <!DOCTYPE html>\n                <html lang=\"en\">\n                  <head>\n                    <meta charset=\"UTF-8\" />\n                    <title>Title</title>\n                  </head>\n                  <style>\n                    .in {\n                      width: 100px;\n                      height: 100px;\n                      border: 1px dashed black;\n                      display: inline-block;\n                    }\n                    .abs {\n                      position: absolute;\n                      height: 50px;\n                      width: 50px;\n                      background: red;\n                      left: 40px;\n                      top: 40px;\n                    }\n                    .rel {\n                      position: relative;\n                    }\n                  </style>\n                  <body>\n                    <div style=\"background: red;\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in rel\">\n                      <div class=\"abs\"></div>\n                    </div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in rel\">\n                      <div class=\"abs\"></div>\n                    </div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in rel\">\n                      <div class=\"abs\"></div>\n                    </div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                    <div class=\"in\"></div>\n                  </body>\n                </html>\n\n        ![](Untitled-8ffe03b3-84f0-49d5-a8ba-039ec780df9d.png)\n\n    - Body = ok\n    - TD, TH, Table =ok\n    - Parent Parent Coninue\n\n## Position:absolute VS Float = Position:absolute\n\n- Float 는 normal flow 일때만 : (static , relative) new BFC  를 만들어야 하기 때문에\n\n## Practice\n\n    Q. <div><div>★</div></div> 태그로 다음의 실드를 구현하시오\n\n![](Untitled-d95582d8-2a01-46e1-9ed7-d7c9a5dd531e.png)\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <title>Title</title>\n        <style>\n          div {\n            display: inline-block;\n            border-radius: 50%;\n          }\n        </style>\n      </head>\n    \n      <body>\n        <div style=\"margin: 30%; box-shadow:0 0 10px 30px rgb(150, 80, 80);\">\n          <div\n            style=\"\n            width: 150px;\n            height: 150px;\n            font-size: 100px;   \n            text-align: center;\n            line-height: 160px;\n            vertical-align: middle;\n            background: blue;\n            color: white;\n            border: 20px solid white;\n            box-shadow:0 0 0 20px red, inset 0 0 0 20px red;\n          \"\n          >\n            ★\n          </div>\n        </div>\n      </body>\n    </html>\n\nborder 와 box-shadow inset 을 이용하여 해결하였다.\n\n![](Untitled-34509fc1-02ee-4569-a6d5-bb56b4cc901e.png)"},"frontmatter":{"layout":"post","title":"Css Rendering 2","category":"css","tags":["Morden Box","stitched"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/css/2019-04-03-cssRendering3/index.md","fields":{"slug":"/etc/css-rendering-3/","categorySlug":"/categories/css/"},"internal":{"content":"\n## CSSOM & VENDOR PREFIX\n\n> CSS 객체모델 & 브라우저 접두어   \n\n[코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)\n채널에서 보고 정리한 글입니다.\n\n---\n\n## Css object model\n\n- Html의 텍스트를 메모리상의 구조로 만드는것은 Css object model 이다.\n- Html 의 태크는 일종의 컨터이너 역할이다.\n- Style태그의 실체는 Sheet 속성에 있는 cssStyleSheet 객체이다.\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n        \n          <style id=\"s\">\n            .test {\n              background: #ff0;\n            }\n          </style>\n        \n          <body>\n            <script>\n              const el = document.querySelector('#s');\n        \t\t\tconst sheet = el.sheet;\n        \t\t\tconst rules = sheet.cssRules;\n        \t\t\tconst rule = rules[0];\n        \t\t\tconsole.log(rule.selectorText);\n        \t\t\tconsole.log(rule.style.background);\n            </script>\n          </body>\n        </html>\n\n    ![](Untitled-8b2002a4-2cb6-43c6-9390-12a1eea209d6.png)\n\n[CSSRule](https://developer.mozilla.org/en-US/docs/Web/API/CSSRule)\n\n  | **Type**                   | **Value** | **Rule-specific interface** |\n  | -------------------------- | --------- | --------------------------- |\n  | **CSSRule.STYLE_RULE**     | 1         | CSSStyleRule                |\n  | **CSSRule.IMPORT_RULE**    | 3         | CSSImportRule               |\n  | **CSSRule.MEDIA_RULE**     | 4         | CSSMediaRule                |\n  | **CSSRule.FONT_FACE_RULE** | 5         | CSSFontFaceRule             |\n  | **CSSRule.PAGE_RULE**      | 6         | CSSPageRule                 |\n  | **CSSRule.KEYFRAMES_RULE** | 7         | CSSKeyframesRule            |\n  | **...**                    |           |                             |\n\n## Insert Rule\n\n- 동적으로 css 추가 rules에 추가 하는것이 아니라 sheet에 의뢰를 해야된다.(sheet에 추가해달라고 해야한다.)\n- style rule은 뒷순서로 적혀있는 것이 우선이 된다.\n- styleSheet를 건들이면 inlineTag를 건드리는것보다 훨씬좋다. (일괄 적용이 가능, inlineStyle을 건들이는 것이 아니라 css를 건들이는 것은성능상의 저하가 거의 없다.  돔을 건들이지 않는다.)\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n          </head>\n        \n          <style id=\"s\">\n            .test {\n              background: #ff0;\n            }\n          </style>\n        \n          <body>\n            <div class=\"red red1\">red</div>\n            <div class=\"blue blue1\">blue</div>\n            <div class=\"red\">red</div>\n            <div class=\"blue\">blue</div>\n            <div class=\"red\">red</div>\n            <div class=\"blue\">blue</div>\n            <div class=\"red\">red</div>\n            <div class=\"blue\">blue</div>\n            <script>\n              const el = document.querySelector('#s');\n              const sheet = el.sheet;\n              const rules = sheet.cssRules;\n              const rule = rules[0];\n        \n              document.querySelector('.red1').onclick = _ => {\n                sheet.insertRule('.red{background:red}', rules.length);\n                sheet.insertRule('.blue{background:blue}', rules.length);\n              };\n        \n              document.querySelector('.blue1').onclick = _ => {\n                sheet.deleteRule(rules.length - 1);\n              };\n        \n              console.log(\n                Array.from(rules)\n                  .map(v => v.cssText)\n                  .join('\\n')\n              );\n            </script>\n          </body>\n        </html\n  <video controls autoplay loop>\n      <source src=\"./insertRule.mov\" type=\"video/mp4\">\n        Your browser does not support the video tag.\n  </video>\n\n## Compatibility Library 만들기\n\n- Vendor Prefix\n    - Runtime Fetch (**실행 중에 확인해야 한다**.)\n- Unsupported Property\n    - graceful fail (우아하게 처리)\n- Hierarchy Optimize\n    - Sheet.disabled=true;\n\n## Classes\n\n![](Untitled-defacaa0-be84-4651-93d9-bfe4997f6e82.png)\n\n- Vendor Prefix\n    - Runtime Fetch (**실행 중에 확인해야 한다**.)\n    - document body style 에게 물어봐야 한다.\n\n            <!DOCTYPE html>\n            <html lang=\"en\">\n              <head>\n                <meta charset=\"UTF-8\" />\n                <title>Title</title>\n                <style></style>\n              </head>\n            \n              <style id=\"s\">\n                .test {\n                  background: #ff0;\n                }\n              </style>\n            \n              <body>\n                <div class=\"test\">test</div>\n            \n                <script>\n                  const Style = (_ => {\n                    const prop = new Map(),\n                      prefix = 'webkit,moz,ms,chrom,o,khtml'.split(',');\n                    const NONE = Symbol();\n                    const BASE = document.body.style;\n                    const getKey = key => {\n                      if (prop.has(key)) return prop.get(key);\n                      if (key in BASE) prop.set(key, key);\n                      else if (\n                        !prefix.some(v => {\n                          //프리픽스를 붙인 속성은 존재하는가?\n                          const newKey = v + key[0].toUpperCase() + key.substr(1);\n                          if (newKey in BASE) {\n                            prop.set(key, newKey);\n                            key = newKey;\n                            return true;\n                          } else return false;\n                        })\n                      ) {\n                        prop.set(key, NONE);\n                        key = NONE; //프리픽스로도 안되면 없는 키!\n                      }\n                      return key;\n                    };\n                    return class {\n                      constructor(style) {\n                        this._style = style;\n                      }\n                      get(key) {\n                        key = getKey(key);\n                        if (key === NONE) return null;\n                        return this._style[key];\n                      }\n                      set(key, val) {\n                        key = getKey(key);\n                        if (key !== NONE) this._style[key] = val;\n                        return this;\n                      }\n                    };\n                  })();\n            \n                  const Rule = class {\n                    constructor(rule) {\n                      this._rule = rule;\n                      this._style = new Style(rule.style);\n                    }\n                    get(key) {\n                      return this._style.get(key);\n                    }\n                    set(key, val) {\n                      this._style.set(key, val);\n                      return this;\n                    }\n                  };\n            \n                  const Sheet = class {\n                    constructor(sheet) {\n                      this._sheet = sheet;\n                      this._rules = new Map(); //위의 Rule 클래스를 사용하기 위해\n                    }\n                    add(selector) {\n                      const index = this._sheet.cssRules.length;\n                      this._sheet.insertRule(`${selector}{}`, index);\n                      const cssRule = this._sheet.cssRules[index];\n                      const rule = new Rule(cssRule);\n                      this._rules.set(selector, rule);\n                      return rule;\n                    }\n                    remove(selector) {\n                      if (!this._rules.has(selector)) return;\n                      const rule = this._rules.get(selector);\n                      Array.from(this._sheet.cssRules).some((cssRule, index) => {\n                        if (cssRule === rule._rule) {\n                          this._sheet.deleteRule(index);\n                          return true;\n                        }\n                      });\n                    }\n                    get(selector) {\n                      return this._rules.get(selector);\n                    }\n                  };\n            \n                  const sheet = new Sheet(document.styleSheets[1]);\n                  sheet.add('body').set('background', '#f00');\n                  sheet\n                    .add('.test')\n                    .set(\n                      'cssText',\n                      'width:200px; border:1px solid #fff; color:#000; background:#fff'\n                    );\n                  // sheet.remove('.test');\n                </script>\n              </body>\n            </html>\n\n    ![](Untitled-d7753fc5-0d8e-41bf-a8f4-18e52a4f2609.png)\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <title>Title</title>\n            <style></style>\n          </head>\n        \n          <style id=\"s\">\n            .test {\n              background: #f00;\n              animation: size 1s infinite alternate;\n            }\n          </style>\n        \n          <body>\n            <div class=\"test\">test</div>\n        \n            <script>\n              const Style = (_ => {\n                const prop = new Map(),\n                  prefix = 'webkit,moz,ms,chrom,o,khtml'.split(',');\n                const NONE = Symbol();\n                const BASE = document.body.style;\n                const getKey = key => {\n                  if (prop.has(key)) return prop.get(key);\n                  if (key in BASE) prop.set(key, key);\n                  else if (\n                    !prefix.some(v => {\n                      //프리픽스를 붙인 속성은 존재하는가?\n                      const newKey = v + key[0].toUpperCase() + key.substr(1);\n                      if (newKey in BASE) {\n                        prop.set(key, newKey);\n                        key = newKey;\n                        return true;\n                      } else return false;\n                    })\n                  ) {\n                    prop.set(key, NONE);\n                    key = NONE; //프리픽스로도 안되면 없는 키!\n                  }\n                  return key;\n                };\n                return class {\n                  constructor(style) {\n                    this._style = style;\n                  }\n                  get(key) {\n                    key = getKey(key);\n                    if (key === NONE) return null;\n                    return this._style[key];\n                  }\n                  set(key, val) {\n                    key = getKey(key);\n                    if (key !== NONE) this._style[key] = val;\n                    return this;\n                  }\n                };\n              })();\n        \n              const Rule = class {\n                constructor(rule) {\n                  this._rule = rule;\n                  this._style = new Style(rule.style);\n                }\n                get(key) {\n                  return this._style.get(key);\n                }\n                set(key, val) {\n                  this._style.set(key, val);\n                  return this;\n                }\n              };\n        \n              const KeyFrameRule = class {\n                constructor(rule) {\n                  this._keyframe = rule;\n                  this._rules = new Map(); //위의 Rule 클래스를 사용하기 위해\n                }\n                add(selector) {\n                  const index = this._keyframe.cssRules.length;\n                  this._keyframe.appendRule(`${selector}{}`, index);\n                  const cssRule = this._keyframe.cssRules[index];\n                  const rule = new Rule(cssRule);\n                  this._rules.set(selector, rule);\n                  return rule;\n                }\n                remove(selector) {\n                  if (!this._rules.has(selector)) return;\n                  const rule = this._rules.get(selector)._rule;\n                  Array.from(this._keyframe.cssRules).some((cssRule, index) => {\n                    if (cssRule === rule._rule) {\n                      this._keyframe.deleteRule(index);\n                      return true;\n                    }\n                  });\n                }\n              };\n        \n              const Sheet = class {\n                constructor(sheet) {\n                  this._sheet = sheet;\n                  this._rules = new Map(); //위의 Rule 클래스를 사용하기 위해\n                }\n                add(selector) {\n                  const index = this._sheet.cssRules.length;\n                  this._sheet.insertRule(`${selector}{}`, index);\n                  const cssRule = this._sheet.cssRules[index];\n                  let rule;\n                  if (selector.startsWith('@keyframes')) {\n                    rule = new KeyFrameRule(cssRule);\n                  } else {\n                    rule = new Rule(cssRule);\n                  }\n                  this._rules.set(selector, rule);\n                  return rule;\n                }\n                remove(selector) {\n                  if (!this._rules.has(selector)) return;\n                  const rule = this._rules.get(selector);\n                  Array.from(this._sheet.cssRules).some((cssRule, index) => {\n                    if (cssRule === rule._rule) {\n                      this._sheet.deleteRule(index);\n                      return true;\n                    }\n                  });\n                }\n                get(selector) {\n                  return this._rules.get(selector);\n                }\n              };\n        \n              const sheet = new Sheet(document.styleSheets[1]);\n              const size = sheet.add('@keyframes size');\n              size.add('from').set('width', '0');\n              size.add('to').set('width', '500px');\n        \n              // sheet.add('body').set('background', '#f00');\n              // sheet\n              //   .add('.test')\n              //   .set(\n              //     'cssText',\n              //     'width:200px; border:1px solid #fff; color:#000; background:#fff'\n              //   );\n              // sheet.remove('.test');\n            </script>\n          </body>\n        </html>\n  <video controls autoplay loop>\n      <source src=\"./keyframe_ex.mov\" type=\"video/mp4\">\n        Your browser does not support the video tag.\n  </video>\n\n## Typed CSSOM\n\n[CSS Typed OM Level 1](https://drafts.css-houdini.org/css-typed-om/)\n\nw3가 아닌데 표준이라고 불린다.\n\nhoudin - 구글이 협회를  만들어서 css 요구한 바를 만들어서 draft로 제출한다고 하는 프로젝트이다. (구글은 w3를 싫어 한다..구글은 할 수 있는 것이 많은데 w3로 제한 받는 것을 싫어 하는 것 같다.)\n\n- ~~$('#someDiv').style.height= getRandonInt() + 'px'~~\n    - js 애니메이션 프레임워크에서 텍스트를 조립하는 과정이 속도를 저하시킨다.\n    - 구글은 이를 싫어 한다.\n\n            CSS.number(0.5)\n            el.styleMap.set('opacity', CSS.number(0.5)\n            \n            CSS.px(500);\n            el.styleMap.set('height',CSS.px(500));\n\n[CSS](https://developer.mozilla.org/ko/docs/Web/API/CSS)\n\n    CSS{\n    \tnumber, percent\n    \tem, ex, ch, ic, rem, lg, rlh, vw, vh ....... px\n    }"},"frontmatter":{"layout":"post","title":"Css Rendering 3","category":"css","tags":["CSSOM"]}}},{"node":{"fileAbsolutePath":"/Users/baemh/Desktop/bmh8993.github.io/src/pages/---articles/---etc/css/2019-04-01-cssRendering1/index.md","fields":{"slug":"/etc/css-rendering-1/","categorySlug":"/categories/css/"},"internal":{"content":"\n\n# Graphics System\n\n\n[코드스피츠](https://www.youtube.com/channel/UCKXBpFPbho1tp-Ntlfc25kA)\n채널에서 보고 정리한 글입니다.\n\n---\n\n## Fixed number\n\n- 고정되어 있는 fixed number 는 환경에 대해 대응 할 수 없다.\n- 환경적인 요인\n    - Screen size\n    - Chrome size\n    - Hierarchy\n\n## Abstract Calcuator\n\n- `메타포`를 사용 ( 계산식, 함수)\n    - ex) %, bock, left, inline = 함수이다.\n\n## Component\n\n- ex) html,의 구성 하나하나를 component\n\n## Framework\n\n- html 자체를  프레임워크로 볼 수 있다.\n- 일정한 규칙과 사용하는 방법이 구현되어 있다.\n\n---\n\n# Rendering System - Dom 과 무관하다.\n\n- 어떠한 데이터로 그림으로 표현되는 것\n1. Geometry Calculate \n    - 구역을 나누는 것\n    - `reflow`\n2. Fragment Fill\n    - 컴포넌트를 채워넣는 것\n    - `repaint`\n\n---\n\n# Css specifications\n\n> Css 는 버전이 아니라 `level` 로 표현\n\n- Css level 1 - a4 한장 짜리 사양\n- Css level 2 - 관심 분야 별로 Module - ms 가 거의 지배\n- Css level 2.1 - Include level 3 Module 각 모듈별로 level 이 다르다.\n- Module level - 새로운 모듈들도 생겨나고 각 모듈 별로 level 이 다르다.\n\n## Other specifications\n\n> w3 community and business group\n\n현재 W3 에서 만 권고 사양을 봐야 되는 게 아니라 여러 그룹도 확인해야 한다. 이제는 w3 draft 가 아니더라도 각 그룹에 drart 로 지정하고 spec 을 사용하게 된다. crome\n\n- Wicg - web platform incubator community group - google\n- Ricg - Responsive issues community group\n\n---\n\n> 서양의 학문의 용어는 전부 고유 명사이다.(일반 명사를 고유명사로 만들어 버린다.) 고유명사는 한국어로 번역이 안된다.\n\n# Normal Flow\n\n> Css2.1 Visual formatting model - positioning schemes & normal flow\n\n어떻게 화면에 보이는 것을 모델링 할 것인가?\n\n## Position\n\n- **`static` | `relative`** | ~~absolute | fixed | inherit~~\n- 2가지 만 Normal Flow\n\n## Normal flow\n\n> 2가지 계산 공식으로 설명된다. Normal Flow에 만 자동으로 계산이 적용된다.\n\n- `Block Formatting contexts` - `BFC`\n    - `부모`의 가로의 `한 줄`을 다 차지 하는 행위 (부모 만큼)\n    - x =0 , width =는 부모의 크기?\n    - 다음 번 블록이 나올 때 y 자리 가 어디인지 만 고민 하면 된다.\n    - width 지정은 화면의 그리는 Geometry의  Fragment를 지정하는 것이지 공간은 한 줄을 차지한다.\n- `Inline Formatting Contexts` - `IFC`\n    - `나의` 컨텐츠 크기만큼 `가로`를 차지 한다.\n    - x = 첫번째 크기만큼 , inline 요소의 width 의 합이 부모 width 를 넘어가면 다음 행으로 넘어 간다.\n    - 얼만큼 내려 가나?\n        - inline를 구성하는 구성 중 lineheight 가 가장 큰 값 기준으로 다음 행으로 넘어간다.\n    - Block 요소를 집어 넣으면 새로운 BFC 영역으로 간주 된다.\n    - 공백문자를 넣어주지 않으면 하나의 인라인으로 본다.\n    - ex) <div> aaaaaaaaaaaaaaaaaa </div>\n    - word break 를 넣어 주면 하나의 span 태그로 본다.\n    - word break 를 주면 느려진다.\n        - 문자 하나하나를 inline로 본다.\n        - Geometry 로 구역이 나눠 진다.\n- Relative Positioning - position에 속해 있다.\n    - 모든 element 는 default 가 position static 이다.\n    - Relative 는 static 먼저 그리고 상대 적으로 이동하는 것을 의미한다.\n    - static 과 Relative 를 만나면 Relative 가 z-index가 뜬다. (위로 차지 한다.)\n        - 실제로 Geometry 가 변경되는 건 아니다. 그림만 해당 위치에 그려진 것이다.\n\n---\n\n# Float\n\nLeft | Right | None | Inherit\n\n- `new BFC` (새로운 영역이 생긴다.)\n- `Float over normal Flow` (`normal Flow 위에 그려진다.`)\n\n![](Untitled-343e4022-8c3f-4f42-8ea7-960e872d9475.png)\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\"/>\n        <title>Title</title>\n    </head>\n    <body>\n    <div style=\"width:500px\">\n        <div style=\"height: 50px; background-color: red;\"></div>\n        <div style=\"width: 200px; height: 150px; float: left; background: rgba(0, 255,0,0.5)\"></div>\n        <div style=\"height: 50px; background-color: skyblue;\"></div>\n    </div>\n    </body>\n    </html>\n\n- Text, `Inline Guard`(text와 inline 요소에 대해서 Guard 된다.)\n\n![](Untitled-939b2d31-3cc8-489e-9397-ec302db953ec.png)\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\"/>\n        <title>Title</title>\n    </head>\n    <body>\n    <div style=\"width:500px\">\n        <div style=\"height: 50px; background-color: red;\"></div>\n        <div style=\"width: 200px; height: 150px; float: left; background: rgba(0, 255,0,0.5)\"></div>\n        Hello\n        <div style=\"height: 50px; background-color: skyblue;\">WORLD</div>\n        !!\n    </div>\n    </body>\n    </html>\n\n- Line Box\n    - Float 는 Line Box공식으로 그려진다.\n    - Normal Flow 는 BFC, IFC, Relative positioning 으로 그려진다.\n    - Float 가 차지 해 있으면 가용 가능 한 Line Box 의 영역은 줄어 든다.\n    - LineBox 가 다 차지 하면 남아 있는 Line Box의 (가장 가까운)하단을 기준으로 Line Box 가 된다.\n    - inline 과 text는  normal flow BFC 영역(float의 BFC 가 겹침)이 지정되면 남은 line box 에 차지 한다.\n    - base line 기준으로 가능 한 범위 내에 float 가 위치하게 된다.\n    - Text, line Guard 만 적용 될분 Geometry 는 존재 하지 않는다.( 그냥 bfc 한줄만 존재하고 글자만 line Guard 규칙에 의해서 그려진다.\n    - (마지막 ABC8은 7이 float: left 이기 때문에 왼쪽으로는 그리지 못한다.)\n\n    ![](Untitled-e3eb16e5-61e7-46f0-8b7d-cb29b46d6072.png)\n\n        <!DOCTYPE html>\n        <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\"/>\n            <title>Title</title>\n        </head>\n        <style>\n            .left {\n                float: left;\n                background: green;\n            }\n        \n            .right {\n                float: right;\n                background: red;\n            }\n        </style>\n        <body>\n        <div style=\"width:500px\">\n            <div class=\"left\" style=\"width:200px; height: 150px;\">1</div>\n            <div class=\"right\" style=\"width:50px; height: 150px;\">2</div>\n            <div class=\"right\" style=\"width:50px; height: 100px;\">3</div>\n            <div class=\"left\" style=\"width:150px; height: 50px;\">4</div>\n            <div class=\"right\" style=\"width:150px; height: 70px;\">5</div>\n            <div class=\"left\" style=\"width:150px; height: 50px;\">6</div>\n            <div class=\"left\" style=\"width:150px; height: 50px;\">7</div>\n            <div style=\"height: 30px; background: red\">ABC1 ABC2 ABC3 ABC4 ABC5 ABC6 ABC7 ABC8</div>\n        </div>\n        </body>\n        </html>\n\n## OverFlow\n\nCss2.1 Visual formatting model \n\nVisible | **Hidden** | **Scroll**  | Inherit | Auto(default) \n\n- **Hidden, Scroll 만 Flow 와 관련이 있다.**\n    - New BFC\n    - Fist Line Box Bound ( 라인박스의 크기를 고려해서 BFC 가 생성된다.)\n        - 원래는 라인박스를 무시 하고 부모의 크기만큼 width 를 차지 한다.\n        - 라인박스의 경계가 없으면 new BFC 의 width 는  0 이 된다.\n\n        ![](Untitled-e028e86c-f7dc-4ecb-9c2b-44414cbad12a.png)\n\n            <!DOCTYPE html>\n            <html lang=\"en\">\n            <head>\n                <meta charset=\"UTF-8\"/>\n                <title>Title</title>\n            </head>\n            <style>\n                .left {\n                    float: left;\n                    background: green;\n                }\n            \n                .right {\n                    float: right;\n                    background: red;\n                }\n            \n                .hidden {\n                    overflow: hidden;\n                }\n            </style>\n            <body>\n            <div style=\"width:500px\">\n                <div class=\"left\" style=\"width:200px; height: 150px;\">1</div>\n                <div class=\"right\" style=\"width:50px; height: 150px;\">2</div>\n                <div class=\"right\" style=\"width:50px; height: 100px;\">3</div>\n                <div class=\"left\" style=\"width:150px; height: 50px;\">4</div>\n                <div class=\"right\" style=\"width:150px; height: 70px;\">5</div>\n                <div class=\"left\" style=\"width:150px; height: 50px;\">6</div>\n                <div class=\"left\" style=\"width:150px; height: 50px;\">7</div>\n                <div style=\"height: 30px; background: red\">ABC1 ABC2 ABC3 ABC4 ABC5 ABC6 ABC7 ABC8</div>\n            </div>\n            <div style=\"width:500px; clear: both;\">\n                <div class=\"left\" style=\"width:200px; height: 150px;\">1</div>\n                <div class=\"right\" style=\"width:50px; height: 150px;\">2</div>\n                <div class=\"right\" style=\"width:50px; height: 100px;\">3</div>\n                <div class=\"left\" style=\"width:150px; height: 50px;\">4</div>\n                <div class=\"right\" style=\"width:150px; height: 70px;\">5</div>\n                <div class=\"left\" style=\"width:150px; height: 50px;\">6</div>\n                <div class=\"left\" style=\"width:150px; height: 50px;\">7</div>\n                <div class=\"hidden\" style=\"height:30px; background: red;\">A</div>\n                <div class=\"hidden\" style=\"height: 15px; background: orange\">B</div>\n                <div style=\"height: 30px; background: black\"></div>\n                <div class=\"hidden\" style=\"height: 30px; background: orange\">C</div>\n                <div class=\"hidden\" style=\"height: 20px; background: orange\">D</div>\n                <div style=\"height: 30px; background: black\"></div>\n                <div class=\"hidden\" style=\"background: orange\">E</div>\n                <div style=\"height: 30px; background: black\"></div>\n                <div class=\"hidden\" style=\"height: 30px; background: orange\">F</div>\n                <div style=\"height: 30px; background: black\"></div>\n            </div>\n            </body>\n            </html>\n\n## OverFlow-x, -y\n\noverflow module level3 draft\n\nVisible | Hidden | Scroll  | clip | Auto(default) \n\n## Text - OverFlow\n\nCss2.1 Ui module level3\n\nclip | ellipsis\n\n## 현재까지 고전 레이아웃\n\n충분한 연습이 필요 하다."},"frontmatter":{"layout":"post","title":"Css Rendering 1","category":"css","tags":["Graphics System","css","Normal Flow"]}}}]}}}